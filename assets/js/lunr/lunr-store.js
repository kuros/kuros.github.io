var store = [{
        "title": "Java - Introduction to OOPs",
        "excerpt":"Object-oriented programming (OOP) is a programming style that uses “objects” (data structures consisting of data fields and methods together with their interactions) to design applications and computer programs. Programming techniques may include features such as data abstraction, encapsulation, modularity, polymorphism, and inheritance.   Classes  A class is a construct that is used as a blueprint (or template) to create objects of that class. This blueprint describes the state and behavior that the objects of the class all share. An object of a given class is called an instance of the class. The class that contains (and was used to create) that instance can be considered as the type of that object. For e.g. the class BIRD would consist of traits shared by all birds, such as beaks, legs  and wings (characteristics), and the ability to fly (behavior).     Objects  A pattern (exemplar) of a class. The class BIRD defines all possible birds by listing the characteristics and behaviors they can have; the object Eagle is one particular bird, with particular versions of the characteristics. A Bird has beak; Eagle has hooked beaks.   We can create object with some pre initialized state using the constructor for the Class, Suppose in the above example of Bird Class we want to assign the name of the Bird while creating the object, we can do that by using the constructor of the class. We will see how to use constructor in later chapter.         Instance  An instance is the blue print (that is, an actual example) of a class. For example, the class Dog is a pattern or blueprint for dog objects by listing the characteristics and behaviors they can have, the object Lassie is one particular dog.   Another example, the class BankAccountClass provides the pattern or blueprint for bank account objects; an object of type BankAccountClass would be one specific bank account.         Abstraction  Abstraction is the process or result of generalization by reducing the information content of a concept or an observable phenomenon, typically to retain only information which is relevant for a particular purpose.For example, abstracting a leather soccer ball to the more general idea of a ball retains only the information on general ball attributes and behavior, eliminating the characteristics of that particular ball.   In object-oriented programming, abstraction is one of three central principles (along with encapsulation and inheritance). Through the process of abstraction, a programmer hides all but the relevant data about an object in order to reduce complexity and increase efficiency.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-1-introduction-to-oops/",
        "teaser": null
      },{
        "title": "Java - Inheritance",
        "excerpt":"Inheritance is the concept of a child class (sub class) automatically inheriting the variables and methods defined in its parent class (super class).   Why Inheritance?     Once a behavior (method) is defined in a super class, that behavior is automatically inherited by all subclasses. Thus, you write a method only once and it can be used by all subclasses.   Once a set of properties (fields) are defined in a super class, the same set of properties are inherited by all subclasses. So a class and its children share common set of properties   A subclass only needs to implement the differences between itself and the parent.   How to derive a sub-class  Suppose we have a parent class called Person. The person has two attributes name and place. In this program we use the Default constructor to print the value assigned to the attributes. In this case we have set name as Raj and Place as Pune.   Code       //Parent class     public class Person {         String name;         String place;                  // defining a Constructor which initializes the object with         // name as \"Raj\" and place as \"Pune\"         public Person() {              name = \"Raj\";             place = \"Pune\";             System.out.println(name);             System.out.println(place);         }     }              Output      Raj     Pune  In the above code we have used a constructor to initialize the data for the Person object. For now a constructor will have the same name as class name and it will have no return type, and whenever the object is created from the class, the constructor of that class is executed.   Problem Statement  Now we want to add new attributes to person so that is should reflect me the data for a student, so what should I do?      Change the class Person and redefine the attributes and methods of the class   Create a new class for student and define all the methods again   Or Ask the Person class to share its properties and use it.   To solve this problem we use the method of inheritance, we go and define a new class (Student) and inherit the properties of the parent class (Person).        //This is the Child class     public class Student extends Person {              String studentId = \"1\";                  /*          * Default Constructor          */         public Student() {             System.out.println(studentId);             System.out.println(name);             System.out.println(place);         }         public static void main(String[] args) {             Student student = new Student(); // Creating an instance of Class Student         }     }              Output  1 Raj Pune  To derive a child class, we use the extends keyword.  In the student code we did not specified the name and place of the student but since we are inheriting student class from person class, the attributes are passed to the child class.   A subclass inherits all of the “public” and “protected” members (fields or methods) of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the package-default members (fields or methods) of the parent.   What You Can Do in a Sub-class Regarding Variables      The inherited variables can be used directly, just like any other variables.   You can declare new variables in the subclass that are not in the super class   You can declare a variables in the subclass with the same name as the one in the super class, thus hiding it (not recommended).   A subclass does not inherit the private members of its parent class. However, if the super class has public or protected methods for accessing its private variables, these can also be used by the subclass.   What You Can Do in a Sub-class Regarding Methods      The inherited methods can be used directly as they are.   You can write a new instance method in the subclass that has the same signature as the one in the super class, thus overriding it.   You can declare new methods in the subclass that are not in the super class.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-2-inheritence/",
        "teaser": null
      },{
        "title": "Java - Polymorphism & Encapsulation",
        "excerpt":"Polymorphism means when an entity behaves differently depending upon the context its being used. Moreover In other words Polymorphism is the capability of an action or method to do different things based on the object that it is acting upon.   Code      //Parent class     public class Person {         String name;         String place;                  // defining a Constructor which initializes the object with         // name as \"Raj\" and place as \"Pune\"         public Person() {              name = \"Raj\";             place = \"Pune\";         }              public void eat() {             System.out.println(\"Person has nothing to eat\");         }              }          //This is the Child class     public class Student extends Person {          \tpublic void eat(){     \t\tSystem.out.println(\"No food to eat\");     \t}     \t     \tpublic void eat(String food){     \t\tSystem.out.println(name + \" eating delicious \" + food);     \t}     \t     }          //A test class to run the program     public class RunProgram {     \t     \tpublic static void main(String[] args) {     \t\tStudent student = new Student(); // Creating an instance of Class Student     \t\tstudent.eat();     \t\tstudent.eat(\"Pastry\");     \t}          }        Output       No food to eat     Raj eating delicious pastry  We can see here that one function when provided different parameter provides different functionality. Notice, we have defined a eat method in Person class but since we are overriding the eat method in the Student class, the value of student class is printed. So one function can exist in different/multiple forms and hence it is called polymorphism.   Encapsulation   Encapsulation is the technique of making the fields in a class private and providing access to the fields via public methods. If a field is declared private, it cannot be accessed by anyone outside the class, thereby hiding the fields within the class. For this reason, encapsulation is also referred to as data hiding.       public class Employee {                  private String name;                  private String address;                  public String getName() {             return name;         }         public void setName(String name) {             this.name = name;         }         public String getAddress() {             return address;         }         public void setAddress(String address) {             this.address = address;         }     }          Here we have taken an example of an employee, we can access the name/address with the getter and setter methods.   Encapsulation can be described as a protective barrier that prevents the code and data being randomly accessed by other code defined outside the class.       public class BadProgram {         public int width;         public int height = 5;         //we wanted that every time the height should be 5         public void area (int width){             System.out.println(\"Area = \" + width * height);         }     }          //A test class to run the program     public class RunProgram {                  public static void main(String[] args) {             BadProgram prog = new BadProgram();             prog.height = 10;             prog.area(2);\t         }     }    Output  Area = 20  The expected output was 10 but since we are modifying the value of height from different class so we cannot guarantee the output every time. So in order to prevent programmers doing this, the concept of encapsulation was introduced.  ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-3-polymorphism-encapsulation/",
        "teaser": null
      },{
        "title": "Java - Programming Fundamentals (Part 1)",
        "excerpt":"Hello Java is very close to the simplest program that can be done in a language. Nonetheless there’s quite a lot going on in it. Let’s see what it does.   For now the initial class statement may be thought of as defining the program name, in this case HelloJava.   The initial class statement is actually quite a bit more than that since this “program” can be called not just from the command line but also by other parts of the same or different programs. We’ll see more in the section on classes and methods below.   Code      // The first class      public class HelloJava {                  // Entry point of the Program         public static void main(String[] args) {                          System.out.println(\"Hello Java\");//print the output on the class.         }          }  When you are saving the file then remember two things, first, your file name should be same as you class name (HelloJava). Second, you ,must save the file with the extension .java (HelloJava.java).   Output  $ javac HelloJava.java $ java HelloJava Hello Java         Explanation     The HelloJava class contains one method - the main method. This is where an application begins executing.   The main method is the first method, which the Java Virtual Machine executes. When you execute a class with the Java interpreter, the runtime system starts by calling the class’s main() method.   The main() method then calls all the other methods required to run your application. It can be said that the main method is the entry point in the Java program and java program can’t run without this method.   The signature of main() method looks like this:            public static void main(String args[])           The method signature for the main() method contains three modifiers:            public indicates that the main() method can be called by any object.       static indicates that the main() method is a class method. The static method can be invoked without creating object of that class.       void indicates that the main() method has no return value.           Finally we pass any command line arguments to the method in an array of Strings called args. In this simple program there aren’t any command line arguments though.   Finally when the main method is called it does exactly one thing: print “Hello World” to the standard output, generally a terminal monitor or console window. This is accomplished by the System.out.println method. To be more precise:-      System is a built-in class present in java.lang package.   out is a static final field (ie, variable)in System class which is of the type PrintStream (a built-in class, contains methods to print the different data values). i.e. out here denotes the reference variable of the type PrintStream class.Hence we can say that out is an OutputStream Object.   println() is a public method in PrintStream class to print the data values.   We will see these Classes later, so don’t be afraid of it for now just remember, you have to use System.out.println() to print your data on the screen.  ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-1-programming-fundatamentals-part-1/",
        "teaser": null
      },{
        "title": "Java - Programming Fundamentals (Part 2)",
        "excerpt":"In this section we are going to understand how to create a class and add attributes (variables) to it.   Creating class  We start with creating Person class. To start follow the steps given below:-     Create a Text File.   Rename the file as Person.java   Use the text editor or an IDE to write the code   Use keyword “class” to create a class.        //creating the class.     public class Person {              }   Now the Person class is created but still it has no attributes or functionality, so now we will provide a set of attributes to it as variables.   Variables     Every variable has a type   Place the type first, followed by the name of the variable   The semicolon is necessary because a declaration is a complete Java statement.   A variable name must begin with a letter and must be a sequence of letters or digits.   The length of a variable name is essentially unlimited.   You can have multiple declarations on a single line.   Names are highly case sensitive so variable newAccount is different from newaccount   Local variables must be declared and initialized before use.         Initializing Variables  After you declare a variable, you must explicitly initialize it by means of an assignment statement—you can never use the values of uninitialized variables.       public class RunnerClass {              public static void main(String[] args) {             int IntegerVariable;             String StringVariable;                          System.out.println(IntegerVariable);             System.out.println(StringVariable);         }          }    $ javac RunnerClass.java  RunnerClass.java:7: error: variable IntegerVariable might not have been initialized         System.out.println(IntegerVariable);                            ^ RunnerClass.java:8: error: variable StringVariable might not have been initialized         System.out.println(StringVariable);                            ^ 2 errors   To use a local variable, one must declare the variable before using it.   In Java you can put declarations anywhere in your code. For example, the following is valid code in Java:     double salary = 65000.0;   System.out.println(salary);   int vacationDays = 12; // ok to declare a variable here   In Java, it is considered good style to declare variables as closely as possible to the point where they are first used.       public class Main {          \tpublic static void main(String[] args) {     \t\tint IntegerVariable = 1;     \t\tString StringVariable = \"Hello\";     \t\t     \t\tSystem.out.println(IntegerVariable);     \t\tSystem.out.println(StringVariable);     \t}          }          1 Hello   List of key words which cannot be used as variable names                  Keyword       Meaning                       abstract       an abstract class or method                 assert       used to locate internal program errors                 boolean       the Boolean type                 break       breaks out of a switch or loop                 byte       the 8-bit integer type                 case       a case of a switch                 catch       the clause of a try block catching an exception                 char       the Unicode character type                 class       defines a class type                 const       const                 continue       continues at the end of a loop                 default       the default clause of a switch                 do       the top of a do/while loop                 double       the double-precision floating-number type                 else       the else clause of an if statement                 enum       an enumerated type                 extends       an enumerated type                 final       a constant, or a class or method that cannot be overridden                 finally       the part of a try block that is always executed                 float       the single-precision floating-point type                 for       a loop type                 goto       not used                 if       a conditional statement                 implements       defines the interface(s) that a class implements                 import       imports a package                 instanceof       tests if an object is an instance of a class                 int       the 32-bit integer type                 interface       an abstract type with methods that a class can implement                 long       the 64-bit long integer type                 native       a method implemented by the host system                 new       allocates a new object or array                 null       a null reference                 package\t        a package of classes                 private\t        a feature that is accessible only by methods of this class                 protected       a feature that is accessible only by methods of this class,its children, and other classes in the same package                 public\t        a feature that is accessible by methods of all classes                 return\t         returns from a method                 short\t        the 16-bit integer type                 static       a feature that is unique to its class, not to objects of its class                 strictfp\t        Use strict rules for floating-point computations                 super\t        the superclass object or constructor                 switch\t        a selection statement                 synchronized\t        a method or code block that is atomic to a thread                 this\t        the implicit argument of a method, or a constructor of this class                 throw\t        throws an exception                 throws\t         the exceptions that a method can throw                 transient\t        marks data that should not be persistent                 try\t        a block of code that traps exceptions                 void\t        denotes a method that returns no value                 volatile\t        ensures that a field is coherently accessed by multiple threads                 while\t        a loop           Let’s return back to our Problem statement, since we have learned how to declare variables we will add variables to our Person class.        //Adding variables to the class.     public class Person {                  /* The will hold a string data type */         private String firstName;                  /* The will hold a string data type */         private String lastName;                  /* The will hold a string data type */         private String accountNumber;                  /* The will hold a integer data type */         private double balance;              }   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-2-programming-fundatamentals-part-2/",
        "teaser": null
      },{
        "title": "Java - Programming Fundamentals (Part 3)",
        "excerpt":"Now we will look into how to create methods, different types of constructors and how to instantiate an object.   Methods     Every method must have a return type.   Method may or may not have parameters   Method name can have any length, it is advisable to choose the method name such that it reflects the job performed by this method.   Now returning to our problem, Since we have used private modifier for declaring the variables – so we need some way to access these variables. We will use getter and setters for these variables.        public String getFirstName() {     \t\treturn firstName;     \t}          \tpublic void setFirstName(String firstName) {     \t\tthis.firstName = firstName;     \t}          \tpublic String getLastName() {     \t\treturn lastName;     \t}          \tpublic void setLastName(String lastName) {     \t\tthis.lastName = lastName;     \t}          \tpublic String getAccountNumber() {     \t\treturn accountNumber;     \t}          \tpublic void setAccountNumber(String accountNumber) {     \t\tthis.accountNumber = accountNumber;     \t}          \tpublic double getBalance() {     \t\treturn balance;     \t}          \tpublic void setBalance(double balance) {     \t\tthis.balance = balance;     \t}          Explanation  The every get method will return the values associated with the variable for which these get methods are written. For every setter method the values will be set for the variables. For e.g.  public String getFirstName() { \t\treturn firstName; \t}  This method will return the value for firstName variable, since firstName is of String type, hence the method is returning String type.   Similarly, for the setter method:-  public void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t}   For the setFirstName method we do want to return anything so we have used the return type as void. We used this reference to indicate that variable is referring to the class variable and not the variable which we are passing to the method.   Constructors   In object-oriented programming, a constructor  in a class is a special type of subroutine called at the creation of an object. It prepares the new object for use, often accepting parameters which the constructor uses to set any member variables required when the object is first created.   A Java constructor performs the following functions in the following order:     It initializes the class variables to default values. (Byte, short, int, long, float, and double variables default to their respective zero values, booleans to false, chars to the null character (‘\\u0000’) and references of any objects to null.)   It then calls the super class constructor (default constructor of super class only if no constructor is defined).   It then initializes the class variables to the specified values like ex: int var = 10; or float var = 10.0f and so on.   It then executes the body of the constructor.   Rules for Creating Constructor     A constructor has no return type.   Default constructor has no parameters.   We can have more than one constructor.   Constructor name is same as class name.   Default Constructor  The default constructor has no parameters.         public Person() { \t\tSystem.out.println(\"This is the default constructor\");             this.accountNumber = “NA”; \t\tthis.balance = 5000; \t}         Constructor overloading  We can have more one constructor. While overloading a constructor one must keep in mind that the two constructors should never have signature.   \t//this is the default constructor \tpublic Person() { \t\tSystem.out.println(\"This is the default constructor\");             this.accountNumber = “NA”; \t\tthis.balance = 5000; \t} \t \t//In this constructor, we overload it with one parameter \tpublic Person(String accountNumber){ \t\tSystem.out.println(\"This is the overloaded constructor\"); \t\tthis.accountNumber = accountNumber; \t\tthis.balance = 5000; \t} \t \t//In this constructor, we overload it with two parameters \tpublic Person(String accountNumber, double balance){ \t\tSystem.out.println(\"This is the overloaded constructor\"); \t\tthis.accountNumber = accountNumber; \t\tthis.balance = balance; \t}   In the default constructor we set the account number as “NA” and balance as 5000.   In Second constructor we set the account number to the value provided by the parameter and we set the balance as 5000 which is still hard coded.   So we create another constructor with account number and balance which passed as the parameter.   Now our Person class will look like this:-       //Adding variables to the class.     public class Person {     \t     \tpublic String getFirstName() {     \t\treturn firstName;     \t}          \tpublic void setFirstName(String firstName) {     \t\tthis.firstName = firstName;     \t}          \tpublic String getLastName() {     \t\treturn lastName;     \t}          \tpublic void setLastName(String lastName) {     \t\tthis.lastName = lastName;     \t}          \tpublic String getAccountNumber() {     \t\treturn accountNumber;     \t}          \tpublic void setAccountNumber(String accountNumber) {     \t\tthis.accountNumber = accountNumber;     \t}          \tpublic double getBalance() {     \t\treturn balance;     \t}          \tpublic void setBalance(double balance) {     \t\tthis.balance = balance;     \t}          \t/* The will hold a string data type */     \tprivate String firstName;     \t     \t/* The will hold a string data type */     \tprivate String lastName;     \t     \t/* The will hold a string data type */     \tprivate String accountNumber;     \t     \t/* The will hold a integer data type */     \tprivate double balance;     \t     \t//this is the default constructor     \tpublic Person() {     \t\tSystem.out.println(\"This is the default constructor\");     \t\tthis.balance = 5000;     \t}     }         Instantiation  Once you have class created now you want to go ahead using this class. To use this we will create an instance of the class. To do so we will create a runner class whose job will be to use the functionality of other classes. This class will hold the main method.       public class RunnerClass {              public static void main(String[] args) {                  Person person = new Person();             System.out.println(\"Default constructor\");             System.out.println(\"Account Number = \" +                                           person.getAccountNumber());             System.out.println(\"Balance = \" + person.getBalance());             System.out.println(\"***********************************\");                          Person person2 = new Person(\"12345\");             System.out.println(\"Passing the one parameter\");             System.out.println(\"Account Number = \" + person2.getAccountNumber());             System.out.println(\"Balance = \" + person2.getBalance());             System.out.println(\"***********************************\");                          Person person3 = new Person(\"123\", 50);             System.out.println(\"Passing two parameters\");             System.out.println(\"Account Number = \" + person3.getAccountNumber());             System.out.println(\"Balance = \" + person3.getBalance());             System.out.println(\"***********************************\");         }          }  In the runner class we have created three instance of Person class as person, person2 and person3 in three different ways and we see that the respective constructors are called when we pass the parameters respectively.   Default constructor Account Number = null Balance = 5000.0 *********************************** Passing the one parameter Account Number = 12345 Balance = 5000.0 *********************************** Passing two parameters Account Number = 123 Balance = 50.0 ***********************************  ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-3-programming-fundatamentals-part-3/",
        "teaser": null
      },{
        "title": "Java - Programming Fundamentals (Part 4)",
        "excerpt":"We have created our initial classes, so now we want to compile the classes. In order to do that we open the command line (To open command line, go to start menu, click on run, type “cmd” and press ok).Use the command “javac” to compile.   $ javac bash: javac: command not found  Oops! We got a serious problem here, the command line does not recognize the javac command. To resolve this issue we need to add the environment variables.   Setting up Environment varaibles  Set the path using the command:-  // on windows: set path=c:\\program files\\Java\\jdk1.6_0_16\\bin  // on linux export PATH=$PATH:&lt;JDK Location&gt;/bin  (provide the location of \\bin which is located in your system.         now when you type javac, you will get output something like this  $ javac Usage: javac &lt;options&gt; &lt;source files&gt; where possible options include:   -g                         Generate all debugging info   -g:none                    Generate no debugging info   -g:{lines,vars,source}     Generate only some debugging info   -nowarn                    Generate no warnings   -verbose                   Output messages about what the compiler is doing   -deprecation               Output source locations where deprecated APIs are used   -classpath &lt;path&gt;          Specify where to find user class files and annotation processors   -cp &lt;path&gt;                 Specify where to find user class files and annotation processors   -sourcepath &lt;path&gt;         Specify where to find input source files   -bootclasspath &lt;path&gt;      Override location of bootstrap class files   -extdirs &lt;dirs&gt;            Override location of installed extensions   -endorseddirs &lt;dirs&gt;       Override location of endorsed standards path   -proc:{none,only}          Control whether annotation processing and/or compilation is done.   -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] Names of the annotation processors to run;                                  bypasses default discovery process   -processorpath &lt;path&gt;      Specify where to find annotation processors   -parameters                Generate metadata for reflection on method parameters   -d &lt;directory&gt;             Specify where to place generated class files   -s &lt;directory&gt;             Specify where to place generated source files   -h &lt;directory&gt;             Specify where to place generated native header files   -implicit:{none,class}     Specify whether or not to generate class files for                                   implicitly referenced files   -encoding &lt;encoding&gt;       Specify character encoding used by source files   -source &lt;release&gt;          Provide source compatibility with specified release   -target &lt;release&gt;          Generate class files for specific VM version   -profile &lt;profile&gt;         Check that API used is available in the specified profile   -version                   Version information   -help                      Print a synopsis of standard options   -Akey[=value]              Options to pass to annotation processors   -X                         Print a synopsis of nonstandard options   -J&lt;flag&gt;                   Pass &lt;flag&gt; directly to the runtime system   -Werror                    Terminate compilation if warnings occur   @&lt;filename&gt;                Read options and filenames from file    The environment variables can also be added by adding to the system environment variables on windows:-      Go to Computer -&gt; properties -&gt; Environment Variables add a new variable JAVA_HOME and add the path to \\bin to the path variable.            Compiling the program  Now the Environment variables have been added and we have to compile the program.   $ javac RunnerClass.java  When you compile the main class i.e. RunnerClass.java the subordinate class gets compile automatically (Person class). You will observe that two .class files are created.      The every java file is converted into a bytecode and is represented as .class files.   Execute  Once the program is compiled, we are ready to execute the program. To run the program type java followed by the class name (which has the main method). Do not append .class at the end of the command.   $ java RunnerClass Default constructor Account Number = null Balance = 5000.0 *********************************** Passing the one parameter Account Number = 12345 Balance = 5000.0 *********************************** Passing two parameters Account Number = 123 Balance = 50.0 ***********************************  ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-4-programming-fundatamentals-part-4/",
        "teaser": null
      },{
        "title": "Java - Data Types",
        "excerpt":"Java is a strongly typed language. This means that every variable must have a declared type. There are eight primitive types in Java. Four of them are integer types; two are floating-point number types; one is the character type char, used for code units in the Unicode encoding scheme and one is a boolean type for truth values.   Integer Types  The integer types are for numbers without fractional parts. Negative values are allowed.                  Types       Storage Requirements       Range (Inclusive)                       int       4 Bytes       –2,147,483,648 to 2,147,483, 647 (just over 2 billion)                 short       2 Bytes       –32,768 to 32,767                 long       8 Bytes       –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807                 byte       1 Byte       –128 to 127           In most situations, we use the int type to store an integer values but if you want to store a very large number such as total number of people of our planet, you’ll need to resort to a long. The byte and short types are mainly intended for specialized applications, such as low-level file handling, or for large arrays when storage space is at a premium.   Long integer numbers have a suffix L (for example, 4000000000L). Hexadecimal numbers have a prefix 0x (for example, 0xCAFE). Octal numbers have a prefix 0. For example, 010 is 8.         Floating-Point Type  The floating-point types denote numbers with fractional parts.                  Types       Storage Requirements       Range (Inclusive)                       float       4 bytes       approximately ±3.40282347E+38F(6–7 significant decimal digits)                 double       8 bytes       approximately ±1.79769313486231570E+308 (15 significant decimal digits)           The name double refers to the fact that these numbers have twice the precision of the float type. (Some people call these double-precision numbers.) Here, the type to choose in most applications is double. The limited precision of float is simply not sufficient for many situations. Seven significant (decimal) digits may be enough to precisely express your annual salary in dollars and cents, but it won’t be enough for your company president’s salary. The only reasons to use float are in the rare situations in which the slightly faster processing of single-precision numbers is important or when you need to store a large number of them.   Numbers of type float have a suffix F (for example, 3.402F). Floating-point numbers without an F suffix (such as 3.402) are always considered to be of type double. You can optionally supply the D suffix (for example, 3.402D).   In particular, there are three special floating-point values to denote overflows and errors:     Positive infinity (Double.POSITIVE_INFINITY)   Negative infinity (Double.NEGATIVE_INFINITY)   NaN -not a number (Double.NaN)         The char Type  The char type is used to describe individual characters. Most commonly, these will be character constants. For example, ‘A’ is a character constant with value 65. It is different from “A”, a string containing a single character. Unicode code units can be expressed as hexadecimal values that run from \\u0000 to \\uFFFF.   There are several escape sequences for special characters.                  Escape Sequence       Name       Unicode Value                       \\b       Backspace       \\u0008                 \\t       Tab       \\u0009                 \\n       Linefeed       \\u000a                 \\r       Carriage return       \\u000d                 \\”       Double quote       \\u0022                 \\’       Single quote       \\u0027                 \\       Backslash       \\u005c           The boolean Type  The boolean type has two values, false and true. It is used for evaluating logical conditions. You cannot convert between integers and boolean values   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-1-data-types/",
        "teaser": null
      },{
        "title": "Java - Control Structures",
        "excerpt":"Java, like any programming language, supports both conditional statements and loops to determine control flow.   Conditional Statements   The conditional statement in Java has the form   The If Statement   The simple if statement has the following syntax:   if (&lt;conditional expression&gt;) &lt;statement action&gt;  The condition must be surrounded by parentheses.   In Java, as in most programming languages, you will often want to execute multiple statements when a single condition is true. In this case, you use a block statement that takes the form  { statement1 statement2 . . . }      if (yourSales &gt;= target) { \tperformance = \"Satisfactory\"; \tbonus = 100; }   The If-else Statement   The if/else statement is an extension of the ‘if’ statement. If the statements defined in the ‘if’ block fails, the statements in the ‘else’ block are executed. You can either have a single statement or a block of code within if-else blocks.   Note that the conditional expression should result into a Boolean value either true or false.   The if-else statement has the following syntax:   if (&lt;conditional expression&gt;) &lt;statement action&gt; else &lt;statement action&gt;      public class IfElseStatementDemo {  \tpublic static void main(String[] args) { \t\t int testscore = 76; \t        char grade;  \t        if (testscore &gt;= 90) { \t            grade = 'A'; \t        } else if (testscore &gt;= 80) { \t            grade = 'B'; \t        } else if (testscore &gt;= 70) { \t            grade = 'C'; \t        } else if (testscore &gt;= 60) { \t            grade = 'D'; \t        } else { \t            grade = 'F'; \t        } \t        System.out.println(\"Grade = \" + grade);  \t} }         Grade = C   Switch Case Statement  The switch case statement, also called a case statement is a multi-way branch with several choices. A switch is easier to implement than a series of if/else statements. The switch statement begins with a keyword, followed by an expression that equates to a no long integral value. Following the controlling expression is a code block that contains zero or more labeled cases. Each label must equate to an integer constant and each must be unique. When the switch statement executes, it compares the value of the controlling expression to the values of each case label. The program will select the value of the case label that equals the value of the controlling expression and branch down that path to the end of the code block. If none of the case label values match, then none of the codes within the switch statement code block will be executed. Java includes a default label to use in cases where there are no matches. We can have a nested switch within a case block of an outer switch.   Its general form is as follows:   switch (expression){     case label1: &lt;statement1&gt;     case label2: &lt;statement2&gt;     …     case labeln: &lt;statementn&gt;     default: &lt;statement&gt; } // end switch   Note:  A switch’s expression must evaluate to a char, byte, short, int, or an enum.   When executing a switch statement, the program falls through to the next case. Therefore, if you want to exit in the middle of the switch statement code block, you must insert a break statement, which causes the program to continue executing after the current code block.   public class SwitchCaseStatementDemo {  \tpublic static void main(String[] args) { \t\t\t \t\tchar val1 = 'a'; \t\tint val2 = 3; \t\t \t\tswitch (val1) { \t\tcase 'a': \t\t\tSystem.out.println(\"This is 'a'\"); \t\t\tbreak; \t\tcase 'A': \t\t\tSystem.out.println(\"This is 'A'\"); \t\t\tbreak; \t\tdefault: \t\t\tSystem.out.println(\"Cannot be determined\"); \t\t} \t\t \t\tswitch (val2) { \t\tcase 1: \t\t\tSystem.out.println(\"This is number 1\"); \t\t\tbreak; \t\tcase 2: \t\t\tSystem.out.println(\"This is number 2\"); \t\t\tbreak; \t\tcase 3: \t\t\tSystem.out.println(\"This is number 3\"); \t\t\tbreak; \t\tdefault: \t\t\tSystem.out.println(\"Cannot be determined\"); \t\t} \t} }         This is 'a' This is number 3   Let us see one more example on this:-   public class Entry {     public static void main(String[] args) {          int month = 8;         switch (month) {             case 1:  System.out.println(\"January\"); break;             case 2:  System.out.println(\"February\"); break;             case 3:  System.out.println(\"March\"); break;             case 4:  System.out.println(\"April\"); break;             case 5:  System.out.println(\"May\"); break;             case 6:  System.out.println(\"June\"); break;             case 7:  System.out.println(\"July\"); break;             case 8:  System.out.println(\"August\"); break;             case 9:  System.out.println(\"September\"); break;             case 10: System.out.println(\"October\"); break;             case 11: System.out.println(\"November\"); break;             case 12: System.out.println(\"December\"); break;             default: System.out.println(\"Invalid month.\");break;         }     } }   August   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-2-control-structures/",
        "teaser": null
      },{
        "title": "Java - Loop",
        "excerpt":"You may encounter situations, when a block of code needs to be executed several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.   Programming languages provide various control structures that allow for more complicated execution paths.   A loop statement allows us to execute a statement or group of statements multiple times.   While Statement  The while statement is a loop construct control statement that executes a block of code while a condition is true. You can either have a single statement or a block of code within the while loop. The loop will never be executed if the testing expression evaluates to false. The loop condition must evaluate to a Boolean result.   The syntax of the while loop is   while (&lt;loop condition&gt;){ &lt;statements&gt; }      public class WhileLoopDemo {  \tpublic static void main(String[] args) { \t\tint count = 1; \t\tSystem.out.println(\"Printing Numbers from 1 to 10\"); \t\twhile (count &lt;= 10) { \t\t\tcount = count + 1; \t\t\tSystem.out.println(count); \t\t} \t} \t }         Printing Numbers from 1 to 10 2 3 4 5 6 7 8 9 10 11   Do-while Loop Statement  The do-while loop is similar to the while loop, except that the test is performed at the end of the loop instead of at the beginning. This ensures that the loop will be executed at least once. A do-while loop begins with the keyword do, followed by the statements that make up the body of the loop. Finally, the keyword while and the test expression completes the do-while loop. When the loop condition becomes false, the loop is terminated and execution continues with the statement immediately following the loop. You can either have a single statement or a block of code within the do-while loop.   The syntax of the do-while loop is:  do &lt;loop body&gt; while (&lt;loop condition&gt;);     public class DoWhileLoopDemo {  \tpublic static void main(String[] args) { \t\tint count = 1; \t\tSystem.out.println(\"Printing Numbers from 1 to 10\"); \t\tdo { \t\t\tSystem.out.println(count++); \t\t} while (count &lt;= 10); \t} }         Printing Numbers from 1 to 10 2 3 4 5 6 7 8 9 10 11   For Loops  The for loop is a looping construct which can execute a set of instructions a specified number of times. It’s a counter controlled loop.   The syntax of the loop is as follows:  for (&lt;initialization&gt;; &lt;loop condition&gt;; &lt;increment expression&gt;) &lt;loop body&gt;   The first part of a for statement is a starting initialization, which executes once before the loop begins. The  section can also be a comma-separated list of expression statements. The second part of a for statement is a test expression. As long as the expression is true, the loop will continue. If this expression is evaluated as false the first time, the loop will never be executed. The third part of the for statement is the body of the loop. These are the instructions that are repeated each time the program executes the loop. The final part of the for statement is an increment expression that automatically executes after each repetition of the loop body. Typically, this statement changes the value of the counter, which is then tested to see if the loop should continue.   All the sections in the for-header are optional. Any one of them can be left empty, but the two semicolons are mandatory. In particular, leaving out the  signifies that the loop condition is true. The (;;) form of for loop is commonly used to construct an infinite loop.      public class ForLoopDemo {  \tpublic static void main(String[] args) { \t\tfor (int i = 1; i &lt;= 5; i++) { \t\t\tfor (int j = 1; j &lt;= i; j++) { \t\t\t\tSystem.out.print(i); \t\t\t} \t\t\tSystem.out.println(); \t\t} \t} }   1 22 333 4444 55555   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-3-loops/",
        "teaser": null
      },{
        "title": "Java - Operators (Part - 1)",
        "excerpt":"Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups:      Arithmetic Operators   Relational Operators   Bitwise Operators   Logical Operators   Assignment Operators   Misc Operators   The Arithmetic Operators   Arithmetic operators are used in mathematical expressions in the same way that they are used in algebra. The following table lists the arithmetic operators:   Assume integer variable A holds 10 and variable B holds 20 then:                  Operator       Description       Example                       +       Addition - Adds values on either side of the operator       A + B = 30                 -       Subtracts - Subtract right hand operand from left hand operand       A - B = 10                 *       Multiplication - Multiplies values on either side of the operator       A * B = 200                 /       Division - Divides left hand operand by right hand operand       B / A = 2                 %       Modulus - Divides left hand operand by right hand operand and return remainder       B % A = 0                 ++       Increment - Increase value of operand by 1       B++ = 21                 –       Decrement - Decrease value of operand by 1       B– = 19           Pre and Post Increment/Decrement                  Operators       Description                       x++       Post increment: add 1 to the value, The value is returned before the increment is made e.g x= 1, y = x++,  then value of y = 1 &amp; value of x = 2                 x–       Post decrement: subtract 1 from the value, The value is returned before the decrement is made e.g x= 1, y = x–,  then value of y = 1 &amp; value of x = 0                 ++x       Pre increment: add 1 to the value, The value is returned after the increment is made e.g x= 1, y = ++x,  then value of y = 2 &amp; value of x = 2                 –x       Pre decrement: subtract 1 from the value, The value is returned after the decrement is made e.g x= 1, y = –x,  then value of y = 0 &amp; value of x = 0                 The Relational Operators   There are following relational operators supported by Java language. Whenever the relational operators are used, the output results to a Boolean value.   Assume variable A holds 10 and variable B holds 20 then:                  Operator       Description       Example                       ==       Checks if the value of two operands are equal, if yes the condition becomes true       (A == B) is false                 ==       Checks if the value of two operands are not equal, if yes the condition becomes true       (A == B) is true                 &gt;       Checks if the value of left operand is greater than right operand, if yes the condition becomes true       (A &gt; B) is false                 &lt;       Checks if the value of left operand is lesser than right operand, if yes the condition becomes true       (A &lt; B) is true                 &gt;=       Checks if the value of left operand is greater or equal to right operand, if yes the condition becomes true       (A &gt; B) is false                 &lt;=       Checks if the value of left operand is less or equal to right operand, if yes the condition becomes true       (A &lt; B) is true           The Bitwise Operators   Java defines several bitwise operators which can be applied to the integer types, long, int, short, char, and byte.   Bitwise operator works on bits and perform bit by bit operation. Assume if a = 60; and b = 13; Now in binary format they will be as follows:   a = 0011 1100 b = 0000 1101 ----------------- a&amp;b = 0000 1000 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011         Bitwise AND (&amp;)  A bitwise AND takes two binary representations of equal length and performs the logical AND operation on each pair of corresponding bits. In each pair, the result is 1 if the first bit is 1 AND the second bit is 1. Otherwise, the result is 0.   Truth table:                  A       B       Output                       0       0       0                 0       1       0                 1       0       0                 1       1       1           Bitwise OR (|)  A bitwise OR takes two bit patterns of equal length, and produces another one of the same length by matching up corresponding bits (the first of each; the second of each; and so on) and performing the logical inclusive OR operation on each pair of corresponding bits. In each pair, the result is 1 if the first bit is 1 OR the second bit is 1 OR both bits are 1, and otherwise the result is 0.   Truth Table:                  A       B       Output                       0       0       0                 0       1       1                 1       0       1                 1       1       1           Bitwise XOR (^)  A bitwise exclusive or takes two bit patterns of equal length and performs the logical XOR operation on each pair of corresponding bits. The result in each position is 1 if the two bits are different, and 0 if they are the same.   Truth Table:                  A       B       Output                       0       0       0                 0       1       1                 1       0       1                 1       1       0                 Bitwise NOT (~)  The bitwise NOT, or complement, is a unary operation that performs logical negation on each bit, forming the ones’ complement of the given binary value. Digits which were 0 become 1, and vice versa.   Truth Table:                  Input       Output                       0       1                 1       0           Left Shift («)  In a left arithmetic shift, zeros are shifted in on the right. The leftmost digit was shifted past the end of the register, and a new 0 was shifted into the rightmost position.      A left arithmetic shift by n is equivalent to multiplying by 2^n.   Right Shift (»)  In a right arithmetic shift, the sign bit is shifted in on the left, thus preserving the sign of the operand. The rightmost 1 was shifted out (perhaps into the carry flag), and a new 0 was copied into the leftmost position, preserving the sign of the number.      A right arithmetic shift by n of a two’s complement value is equivalent to dividing by 2n and rounding toward negative infinity.   The following table lists the bitwise operators, Assume integer variable A holds 60 and variable B holds 13 then:                  Operator       Description       Example                       &amp;       Binary AND Operator copies a bit to the result if it exists in both operand       (A &amp; B) will give 12 which is 0000 1100                 |       Binary OR Operator copies a bit if it exists in either operand       (A | B) will give 61 which is 0011 1101                 ^       Binary XOR Operator copies a bit if it is set in one operand but not both       (A ^ B) will give 49 which is 0011 0001                 ~       Binary ones complements Operator is Unary and has effect of ‘flipping’ bits       (~A ) will give -60 which is 1100 0011                 «       Binary Left shift operator. The left operand value is moved left by number of bits specified by right operand       A « 2 will give 240 which is 1111 0000                 »       Binary Right shift operator. The left operand value is moved right by number of bits specified by right operand       A » 2 will give 15 which is 1111                 »&gt;       Shift right zero fill operator. the left operands value is moved right by the number of bits specified by the right operand and shifted values are filled up with zeros       A »&gt; 2 will give 15 which is 0000 1111                 public class Entry { \tpublic static void main(String[] args) { \t\t  // create truth table for &amp; (boolean logical AND) operator \t      System.out.printf( \"%s\\n%s: %b\\n%s: %b\\n%s: %b\\n%s: %b\\n\\n\", \t         \"Boolean logical AND (&amp;)\", \"false &amp; false\", ( false &amp; false ), \t         \"false &amp; true\", ( false &amp; true ), \t         \"true &amp; false\", ( true &amp; false ), \t         \"true &amp; true\", ( true &amp; true ) );  \t      // create truth table for | (boolean logical inclusive OR) operator \t      System.out.printf( \"%s\\n%s: %b\\n%s: %b\\n%s: %b\\n%s: %b\\n\\n\", \t         \"Boolean logical inclusive OR (|)\", \t         \"false | false\", ( false | false ), \t         \"false | true\", ( false | true ), \t         \"true | false\", ( true | false ), \t         \"true | true\", ( true | true ) );  \t      // create truth table for ^ (boolean logical exclusive OR) operator \t      System.out.printf( \"%s\\n%s: %b\\n%s: %b\\n%s: %b\\n%s: %b\\n\\n\", \t         \"Boolean logical exclusive OR (^)\",  \t         \"false ^ false\", ( false ^ false ), \t         \"false ^ true\", ( false ^ true ), \t         \"true ^ false\", ( true ^ false ), \t         \"true ^ true\", ( true ^ true ) );     \t} }   Boolean logical AND (&amp;) false &amp; false: false false &amp; true: false true &amp; false: false true &amp; true: true  Boolean logical inclusive OR (|) false | false: false false | true: true true | false: true true | true: true  Boolean logical exclusive OR (^) false ^ false: false false ^ true: true true ^ false: true true ^ true: false   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-4-operators/",
        "teaser": null
      },{
        "title": "Java - Operators (Part - 2)",
        "excerpt":"Few more operators which are used in Java.   The Logical Operators  The following table lists the logical operators. Assume boolean variables A holds true and variable B holds false then:                  Operator       Description       Example                       &amp;&amp;       Called Logical AND operator. If both operands are non zero then the condition becomes true       (A &amp;&amp; B) is false                 ||       Called Logical OR operator. If any of the two operands is non zero then the condition becomes true       (A || B) is true                 !       Called Logical NOT operator. Used to reverse the logical state of its operand. If a condition is true then Logical NOT operator will make false       !(A &amp;&amp; B) is true           public class Entry { \tpublic static void main(String[] args) { \t\t// create truth table for &amp;&amp; (conditional AND) operator \t      System.out.printf( \"%s\\n%s: %b\\n%s: %b\\n%s: %b\\n%s: %b\\n\\n\", \t         \"Conditional AND (&amp;&amp;)\", \"false &amp;&amp; false\", ( false &amp;&amp; false ), \t         \"false &amp;&amp; true\", ( false &amp;&amp; true ),  \t         \"true &amp;&amp; false\", ( true &amp;&amp; false ), \t         \"true &amp;&amp; true\", ( true &amp;&amp; true ) );  \t      // create truth table for || (conditional OR) operator \t      System.out.printf( \"%s\\n%s: %b\\n%s: %b\\n%s: %b\\n%s: %b\\n\\n\", \t         \"Conditional OR (||)\", \"false || false\", ( false || false ), \t         \"false || true\", ( false || true ), \t         \"true || false\", ( true || false ), \t         \"true || true\", ( true || true ) );  \t      // create truth table for ! (logical negation) operator \t      System.out.printf( \"%s\\n%s: %b\\n%s: %b\\n\", \"Logical NOT (!)\", \t         \"!false\", ( !false ), \"!true\", ( !true ) ); \t} }   Conditional AND (&amp;&amp;) false &amp;&amp; false: false false &amp;&amp; true: false true &amp;&amp; false: false true &amp;&amp; true: true  Conditional OR (||) false || false: false false || true: true true || false: true true || true: true  Logical NOT (!) !false: true !true: false         The Assignment Operators  There are following assignment operators supported by Java language:                  Operator       Description       Example                       =       Simple assignment operator, assigns value from right side operand to left side operand       C = A + B will assign value A + B to C                 -=       Subtract AND assignment operator, it subtract right operand from left operand and assign the value to left operand       C -= A is equivalent to C = C - A                 +=       Add AND assignment operator, it adds right operand to left operand and assign the value to left operand       C += A is equivalent to C = C + A                 *=       Multiply AND assignment operator, it multiply right operand and left operand and assign the value to left operand       C *= A is equivalent to C = C * A                 /=       Divide AND assignment operator, it divides left operand with right operand and assign the value to left operand       C /= A is equivalent to C = C / A                 %=       Modulus AND assignment operator, it modulus left operand with right operand and assign the value to left operand       C %= A is equivalent to C = C % A                 «=       Left shift and assign operator       C «=2  is equivalent to C = C « 2                 »=       Right shift and assign operator       C »=2  is equivalent to C = C » 2                 &amp;=       Bitwise AND assignment operator       C &amp;= 2  is equivalent to C = C &amp; 2                 ^=       Bitwise XOR assignment operator       C ^= 2  is equivalent to C = C ^ 2                 |=       Bitwise OR assignment operator       C |= 2  is equivalent to C = C | 2                 Conditional Operator  Conditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as :   variable x = (expression) ? value if true : value if false   public class Test { \tpublic static void main(String args[]){ \t\tint a , b; \t\ta = 10; \t\tb = (a == 1) ? 20: 30; \t\tSystem.out.println( \"Value of b is : \" +  b );  \t\tb = (a == 10) ? 20: 30; \t\tSystem.out.println( \"Value of b is : \" + b ); \t} }  Value of b is : 30 Value of b is : 20   instanceOf Operator  This operator is used only for object reference variables. The operator checks whether the object is of a particular type(class type or interface type), this operator is often used to test that the child class is inherited from the parent class or not. instanceOf operator is wriiten as:   (Object reference variable) instanceof (class/interface type)   If the object referred by the variable on the left side of the operator passes the IS-A check for the class/interface type on the right side then the result will be true. For example   String name = \"James\"; boolean result = name instanceof String; // This will return true since name is of type String         Precedence of Java Operators  Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:   For example x = 7 + 3 * 2; Here x is assigned 13, not 20 because operator * has higher precedenace than + so it first get multiplied with 3*2 and then adds into 7.   Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedenace operators will be evaluated first.                  Category       Operator       Associativity                       Postfix       ()[].(dot operator)       Left to Right                 Unary       ++ – ! ~       Right to Left                 Multiplicative       * / %       Left to Right                 Additive       + -       Left to Right                 Shift       » »&gt; «       Left to Right                 Relational       &gt; &gt;= &lt; &lt;=       Left to Right                 Equality       == !=       Left to Right                 Bitwise       &amp; ^ |       Left to Right                 Logical       &amp;&amp; ||       Left to Right                 Conditional       ? :       Right to Left                 Assignment       = += -= *= /= %= »= «= &amp;= ^= |=       Right to Left                 Comma       ,       Left to Right           ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-5-operators-2/",
        "teaser": null
      },{
        "title": "Java - Arrays",
        "excerpt":"Array, what is it? An array is a group of variables of the same data type and referred to by a common name. An array is an object which is a contiguous block of memory locations referred by a common name.   For e.g. To store the marks of 5000 students, you can declare an array, marks, of size 5000 and can store the marks of as many students.   int marks[] = new int[5000];   Need of Arrays  You might come across a situation where you need to store similar type of values for a large number of data items.   For e.g. To store the marks of all the students of a university, you need to declare thousands of variables. In addition, each variable name needs to be unique. To avoid such situations, you can use arrays.   An array consists of a name and the number of elements of the array. You can refer to a specific array element by the array name and the element number, which is known as the index number.   Note: - Array index element number always starts with 0(zero).         Creating Arrays  The length of an array is fixed at the time of its creation. An array represents related entities having the same data type in contiguous or adjacent memory locations. The related data having data items form a group and are referred to by the same name.   For e.g. employee[5];   Here, the employee is the name of the array and of size 5. The complete set of values is known as an array and the individual entities are called as elements of the array.   A specific value in an array is accessed by placing the index value of the desired element in a square bracket. Once you create an array, you cannot change its size (although you can, of course, change an individual array element).   Advantages of using Arrays:-     You can refer to a large number of elements by just specifying the index number and the array name.   Arrays make it easy to do calculations in a loop   The various types of arrays in java are:     One-dimensional arrays   Two-dimensional arrays   Constructing one Dimensional Array  The most straightforward way to construct an array is to use the keyword new followed by the array type, with a bracket specifying how many elements of that type the array will hold. The following is an example of constructing an array of type int:   int[] testScores = new int[4];  The preceding code puts one new object on the heap—an array object holding four elements—with each element containing an int with a default value of 0.      So what it does the reference points to a memory location which has been allocated in the memory for the array.   int[] EmployeeList = new int[]; // Will not compile; needs a size   Note:-  arrays must always be given a size at the time they are constructed. The JVM needs the size to allocate the appropriate space on the heap for the new array object. It is never legal, for example, to do the following:   public class Entry { \tpublic static void main(String[] args) { \t\tint[] a = new int[5];  \t\tfor(int i=0; i&lt;=4; i++){ \t\t\ta[i] = i; \t\t} \t\t \t\tfor(int i=0; i&lt;=4; i++){ \t\t\tSystem.out.println(a[i]); \t\t} \t} }         0 1 2 3 4   Constructing Multidimensional Arrays   Multidimensional arrays, remember, are simply arrays of arrays. So a two dimensional array of type int is really an object of type int array (int []), with each element in that array holding a reference to another int array. The second dimension holds the actual int primitives.   int[][] myArray = new int[3][];      Here in this case myArray is pointing to a memory location ( to a array) which in turn refer to other arrays which hold actual values.   public class Entry { \t  // Declare constants \t  final static int ROWS = 10;  \t  final static int COLS = 5;  \t  public static void main(String[] args) {  \t    // Local varaibles \t    int rowCount; \t    int colCount; \t    int totalSize;  \t    // Declare and allocate an array of bytes \t    byte[][] screenPix = new byte[ROWS][COLS];  \t    // Obtain and store array dimensions \t    rowCount = screenPix.length; \t    colCount = screenPix[COLS].length; \t    totalSize = rowCount * colCount;  \t    // To obtain the total number of elements of a \t    // two-dimensional ragged array you need to get the size of \t    // each array dimension separately  \t    // Display array dimensions \t    System.out.println(\"Array row size:    \" + rowCount); \t    System.out.println(\"Array column size: \" + colCount); \t    System.out.println(\"Total size:        \" + totalSize);  \t    //************************* \t    //      ragged arrays \t    //************************* \t    // First allocate the rows of an array \t    byte[][] raggedArray = new byte[5][];  \t    // Now allocate the columns \t    raggedArray[0] = new byte[2]; \t    raggedArray[1] = new byte[2]; \t    raggedArray[2] = new byte[4]; \t    raggedArray[3] = new byte[8]; \t    raggedArray[4] = new byte[3];  \t    // The resulting ragged array is as follows: \t    //  x x \t    //  x x \t    //  x x x x \t    //  x x x x x x x x \t    //  x x x  \t    //************************************ \t    //     static array initialization \t    //************************************ \t    byte[][] smallArray = { { 10, 11, 12, 13 }, { 20, 21, 22, 23 }, \t        { 30, 31, 32, 33 }, { 40, 41, 42, 43 }, };  \t    // Display the array element at row 2, column 3 \t    System.out.println(smallArray[1][2]); // Value is 21 \t  } \t}          Array row size:    10 Array column size: 5 Total size:        50 22   Anonymous Array  In java it is perfectly legal to create an anonymous array using the following syntax.  new &lt;type&gt;[] { &lt;list of values&gt;};  Anonymous array example  new int[]{1,2,3};  The above given example creates a nameless array and initializes it. Here, neither name of the array nor the size is specified. It also creates a array which can be assigned to reference or can be passed as a parameter to any method.   public class Entry {  \tpublic static void main(String[] args) { \t\tSystem.out.println(\"Length of array is \" \t\t\t\t+ Entry.findLength(new int[] { 1, 2, 3 })); \t}  \tpublic static int findLength(int[] array) { \t\treturn array.length; \t} }    Length of array is 3   Assigning values to the Elements of an Array   To access a specific array,     You need to specify the name of the array and the index number of the element.   The index position of the first element in the array is 0.   String designations[];  designations = new String[2];  designations[0] = \"General Manager\";  designations[1]= \"Managing Director\";   Accessing values  You can access values from elements in the array by referring to the element by its index number.   String designations[];  designations = new String[3];  designations[1] = \"General Manager\";  designations[2]= \"Managing Director”;  designations[0]=designations[2];   In the above example, the value of the third element of the array is assigned to the first element of the array.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-6-arryas/",
        "teaser": null
      },{
        "title": "Java - Type Casting",
        "excerpt":"The type casting comprises of two subtypes, a) Primitive type casting and b) Object Reference Type casting.   Primitive Type casting  Casting lets you convert primitive values from one type to another. Casts can be implicit or explicit. An implicit cast means you don’t have to write code for the cast; the conversion happens automatically. Typically, an implicit cast happens when you’re doing a widening conversion. In other words, to put a smaller thing (say, a byte) into a bigger container (like an int).   The large-value-into-small-container conversion is referred to as narrowing and requires an explicit cast, where you tell the compiler that you’re aware of the danger and accept full responsibility.   int a = 100; long b = a; // Implicit cast, an int value always fits in a long  Now if we want to assign an decimal value to an integer variable  int x = 345.456;   the compiler will raise an error saying:- Incompatible type for declaration. Explicit cast needed to convert double to int.   To resolve the issue we will have to explicitly typecast the double value to int type So the code now looks like this:-     int x =  (int)345.456;   The following code demonstrates the primitive typecasting:-  public class Test { \tpublic static void main(String args[]){ \t\tfloat f = 123.45f; \t\t \t\tSystem.out.println(\"The value of f = \" + f); \t\t \t\tint i = (int)f; // explicit typecasting  \t\tSystem.out.println(\"The value of i = \" + i); \t\t \t\tdouble d = (double)f; // explicitly typecasting but could also be implicit \t\tSystem.out.println(\"The value of d = \" + d); \t} }         The value of f = 123.45 The value of i = 123 The value of d = 123.44999694824219   Object Reference Type casting  In java object typecasting one object reference can be type cast into another object reference. The cast can be to its own class type or to one of its subclass or superclass types or interfaces.   When we cast a reference along the class hierarchy in a direction from the root class towards the children or subclasses, it is a downcast. When we cast a reference along the class hierarchy in a direction from the sub classes towards the root, it is an upcast. We need not use a cast operator in this case.   The compile-time rules are there to catch attempted casts in cases that are simply not possible. This happens when we try to attempt casts on objects that are totally unrelated (that is not subclass super class relationship or a class-interface relationship) At runtime a ClassCastException is thrown if the object being cast is not compatible with the new type it is being cast to.   //X is a supper class of Y and Z which are sibblings. public class RunTimeCastDemo {  \tpublic static void main(String args[]) { \t\tX x = new X(); \t\tY y = new Y(); \t\tZ z = new Z(); \t\tX xy = new Y(); // compiles ok (up the hierarchy) \t\tX xz = new Z(); // compiles ok (up the hierarchy) \t\t//\t\tY yz = new Z();   incompatible type (siblings) \t\t//\t\tY y1 = new X();   X is not a Y \t\t//\t\tZ z1 = new X();   X is not a Z \t\tX x1 = y; // compiles ok (y is subclass of X) \t\tX x2 = z; // compiles ok (z is subclass of X) \t\tY y1 = (Y) x; // compiles ok but produces runtime error \t\tZ z1 = (Z) x; // compiles ok but produces runtime error \t\tY y2 = (Y) x1; // compiles and runs ok (x1 is type Y) \t\tZ z2 = (Z) x2; // compiles and runs ok (x2 is type Z) \t\t//\t\tY y3 = (Y) z;     inconvertible types (siblings) \t\t//\t\tZ z3 = (Z) y;     inconvertible types (siblings) \t\tObject o = z; \t\tObject o1 = (Y) o; // compiles ok but produces runtime error \t} }   In general cast is done when an Object reference is assigned (cast) to:     A reference variable whose type is the same as the class from which the object was instantiated. An Object as Object is a super class of every Class.   A reference variable whose type is a super class of the class from which the object was instantiated.   A reference variable whose type is an interface that is implemented by the class from which the object was instantiated.   A reference variable whose type is an interface that is implemented by a super class of the class from which the object was instantiated.   Consider an interface Vehicle, a super class Car and its subclass Ford. The following example shows the automatic conversion of object references handled by the compiler         interface Vehicle { } class Car implements Vehicle { }  class Ford extends Car { }   Let c be a variable of type Car class and f be of class Ford and v be an vehicle interface reference. We can assign the Ford reference to the Car variable: i.e. we can do the following   Example 1  c = f; //Ok Compiles fine   Where c = new Car();   And, f = new Ford();   The compiler automatically handles the conversion (assignment) since the types are compatible (sub class - super class relationship), i.e., the type Car can hold the type Ford since a Ford is a Car.   Example 2  v = c; //Ok Compiles fine c = v; // illegal conversion from interface type to class type results in compilation error  Where c = new Car();   And v is a Vehicle interface reference (Vehicle v)   The compiler automatically handles the conversion (assignment) since the types are compatible (class – interface relationship), i.e., the type Car can be cast to Vehicle interface type since Car implements Vehicle Interface. (Car is a Vehicle).   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-7-type-casting/",
        "teaser": null
      },{
        "title": "Java - Inheritance deep dive",
        "excerpt":"Ohh! Its inheritance again….. its freaking me out. I don’t understand what it is? We see this kind of reaction every time we someone is first told about, Let us understand it using a simple example.   Suppose you are a Zoo manager and you want to store the data about the animal of the zoo:-      To solve this we create a class with the name of Animal and it will have some features which is common to all the animals, so all the animals will have a common method.   public class Animal { \t \tpublic Animal(){ \t\tSystem.out.println(\"This a generic Animal class\"); \t} \tString eat = \"Animal eats\"; \t// Some featues goes here regarding Animal \t// .... \t// .... \t }   Now our Zoo manager have different problem he wishes to store specific information about the a type of animal say but this information will not be applicable for other animals, a Monkey.   public class Monkey extends Animal{ \t \tpublic Monkey(){ \t\tSystem.out.println(\"This a Monkey class\"); \t}  \tString eat = \"Eats banana\"; \t// this class holds the information about Monkey \t//.... \t//....  \t }         Now there are different types of Monkey in the Zoo such as Ape, Baboon and Gorilla.   public class Gorilla extends Monkey {  \tString eat = \"Eats banana and leafs\";\t \t// Some details regarding the Gorilla \t//.... \t//.... \t }   IS-A relationship  Interface implementation is not a part of inheritance tree and does not follow IS-A relationship IS-A is a way of saying, “this thing is a type of that thing.”   So now      “Monkey extends Animal” means “Monkey IS-A Animal.”   “Gorilla extends Monkey” means “Gorilla IS-A Monkey.”   So we can also say “Gorilla IS-A Animal.”   Has-A relationship  HAS-A relationships are based on usage, rather than inheritance. In other words, class A HAS-A B if code in class A has a reference to an instance of class B. For e.g. assuming again that Monkey extends from Animal.   Has-A Relationship is also called as Aggregation. And a monkey has teeth hands legs etc.      public class Monkey {  \tString name = \"Gorilla\"; \t \tString teeth = \"Sharp teeth\"; \t \tString hands = \"long thin hands\"; \t \tString legs = \"Short legs\"; }         Method Overriding  In a class hierarchy, when a method in a subclass has the same name and type signature as a method in its superclass, then the method in the subclass is said to override the method in the superclass.   Now in our Animal class let us assume that Animal has an eat method.  public class Animal { \t \tpublic void eat(){ \t\tSystem.out.println(\"Animal is eating\"); \t} \t }  public class Monkey extends Animal{ \t       // overridding the Animal class method eat() \tpublic void eat() {  \t\tSystem.out.println(\"Monkey is eating\"); \t} }  public class RunProgram {  \tpublic static void main(String[] args) { \t\tAnimal animal = new Animal(); // step1 \t\tAnimal animal2 = new Monkey(); //step2 \t\tMonkey monkey = new Monkey(); //step3 \t\t \t\tanimal.eat(); \t\tanimal2.eat(); \t\tmonkey.eat(); \t}  }   Animal is eating Monkey is eating Monkey is eating  So let’s see what happens     At Step1: We create reference of Animal which points to an Animal object. So the output for animal.eat() is as expected (printing the Animal version of eat() method).   At Step2: We create reference of Animal which points to a Monkey object. So this time it will go run the Monkey version of eat () method, i.e. overriding the base class method.   At Step3: Monkey reference refers to Monkey object, so prints the Monkey version of the eat () method)   Now let us modify the previous code and new function to the Monkey class.   public class Animal { \t \tpublic void eat(){ \t\tSystem.out.println(\"Animal is eating\"); \t} \t }  public class Monkey extends Animal{ \t \tpublic void eat() { \t\tSystem.out.println(\"Monkey is eating\"); \t} \t \tpublic void jump() { \t\tSystem.out.println(\"Monkey is jumping\"); \t} }  public class RunProgram {  \tpublic static void main(String[] args) { \t\tAnimal animal = new Animal(); \t\tAnimal animal2 = new Monkey(); \t\tMonkey monkey = new Monkey(); \t\t \t\tanimal.jump();//Line1 \t\t \t\tanimal2.jump();//Line2 \t\t \t\tmonkey.jump(); //Line3 \t} }  Expected   Monkey is jumping Monkey is jumping Monkey is jumping  But it is wrong and you will get the output as   cannot find symbol   symbol:   method jump()   location: variable animal of type Animal cannot find symbol   symbol:   method jump()   location: variable animal2 of type Animal  Let us understand it why does it happen:-     Line1:- The reference type is of Animal and it is pointing to an animal object, since the Animal class does not have any method known as jump(), so it gave a compilation error.   Line2:- The reference type is of Animal but the it pointing to Monkey object, still the reference type being an Animal type does know there exists any method known as jump() so it will give a compilation error.   Line3:- The it works fine since the reference and the object type is same and the jump() method is visible to the monkey reference.         Late Binding   Java uses late-binding to support polymorphism; which means the decision as to which of the many methods should be used is deferred until runtime.   It is Java’s use of late-binding which allows you to declare an object as one type at compile-time but executes based on the actual type at runtime. If we use :   Animal animal = new Monkey();   The object of monkey is bound to the animal reference type. However methods declared in Monkey class will not be visible in animal reference, to access you will have cast animal object to Monkey type.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-1-inheritence-deep-dive/",
        "teaser": null
      },{
        "title": "Java - Super, this, constructor calling, initialization blocks",
        "excerpt":"Time to take a deep dive into creation of objects.   super  Often, you’ll want to take advantage of some of the code in the superclass version of a method, yet still override it to provide some additional specific behavior. It’s like saying, “Run the superclass version of the method, then come back down here and finish with my subclass additional method code.”   public class Animal { \tpublic void eat() { } \tpublic void printYourself() { \t// Useful printing code goes here \t} }  class Monkey extends Animal { \tpublic void printYourself() { \t// Take advantage of Animal code, then add some more \t\tsuper.printYourself(); // Invoke the superclass \t\t// (Animal) code \t\t// Then do Monkey-specific \t\t// print work here \t} }   In this code we use super keyword to call the Animal version of the method.   this   The keyword this is used to reference the current working object, suppose for the given code.      Here we have kept the name of instance and local variable same (val) but in the method setVal() we need to assign the value of local variable to the instance variable so to distinguish between the local and instance variable we use this key word. The Key word this refers to the current working object of a in this case.   Constructor Calling   When we are working with inheritance we have to take care how the constructor is being called. Every class, including abstract classes, MUST have a constructor. Few important points:-      Constructors use access modifier as that of the class.   The constructor name must match the name of the class.   Constructors must not have a return type.   It’s legal (but stupid) to have a method with the same name as the class, but that doesn’t make it a constructor.   Every constructor has, as its first statement, either a call to an overloaded constructor (this()) or a call to the superclass constructor (super())   A call to super() can be either a no-arg call or can include arguments passed to the super constructor.   Compiler inserts a default constructor if there is no constructor defined by the programmer.   Let us take a simple example to understand this concept.   public class Animal { \t \tpublic Animal() { \t\tSystem.out.println(\"In the Animal constructor\"); \t} \t }  public class Monkey extends Animal{ \t \tpublic Monkey() { \t\tSystem.out.println(\"In the Monkey Constructor\"); \t}  \tpublic Monkey(String args) { \t\tSystem.out.println(\"In the Monkey overloaded Constructor \" ); \t} }  public class RunProgram {  \tpublic static void main(String[] args) { \t\t \t\tMonkey monkey = new Monkey(); \t\tSystem.out.println(\"************************\"); \t\tMonkey monkey2 = new Monkey(\"Gorilla\");  \t} }         In the Animal constructor In the Monkey Constructor ************************ In the Animal constructor In the Monkey overloaded Constructor   Note: - we have never called Animal constructor but still we could see that Animal constructor is being executed, how? Let us see how it works              Moneky constructor is invoked. Every constructor invokes the constructor of its superclass with an (implicit) call to super().            Animal constructor is invoked            Object constructor is invoked (Object is the ultimate superclass of all classes)            Object instance variables are given their explicit values.            Object constructor completes.            Animal instance variables are given their explicit values (if any).            Animal constructor completes.            Monkey instance variables are given their explicit values (if any).            Monkey constructor completes.       Using super and this with constructors   You can use the super and this keyword to call the constructors of super class or to call other overloaded constructor of the same class.   class ClassA { \tpublic ClassA() { \t\tSystem.out.println(\"ClassA default constructor\"); \t} \t \tpublic ClassA(String args) { \t\tSystem.out.println(\"ClassA overloaded constructor\"); \t} }   public class ClassB extends ClassA {  \tpublic ClassB() { \t\tthis(\"passing args\"); \t\tSystem.out.println(\"In the ClassB Constructor\"); \t}  \tpublic ClassB(String args) { \t\tsuper(\"overloaded\"); \t\tSystem.out.println(\"In the ClassB overloaded Constructor \"); \t}  \tpublic static void main(String[] args) {  \t\tClassB b = new ClassB(); \t\tSystem.out.println(\"****************************\"); \t\tClassB b2 = new ClassB(\"load\"); \t}  }         ClassA overloaded constructor In the ClassB overloaded Constructor  In the ClassB Constructor **************************** ClassA overloaded constructor In the ClassB overloaded Constructor   Initialization Blocks   We’ve talked about two places in a class where you can put code that performs operations: methods and constructors. Initialization blocks are the third place in a Java program where operations can be performed. Initialization blocks run when the class is first loaded (a static initialization block) or when an instance is created (an instance initialization block).   public class SmallInit {  \tstatic int x; \tint y; \tstatic { x = 7 ; } // static init block \t{ y = x + 1; } // instance init block  \tpublic void printValues(){ \t\tSystem.out.println(x); \t\tSystem.out.println(y); \t\tSystem.out.println(\"****************\"); \t} \tpublic static void main(String[] args) { \t\tSmallInit value1 = new SmallInit();  \t\tvalue1.printValues(); \t} }         7 8 ****************   So we static init block runs first and then the instance initialization block.   A static initialization block runs once, when the class is first loaded. An instance initialization block runs once every time a new instance is created. You can have many initialization blocks in a class. It is important to note that unlike methods or constructors, the order in which initialization blocks appear in a class matters.   public class Init { \t \tInit(int x) { System.out.println(\"1-arg const\"); } //Line 1 \tInit() { System.out.println(\"no-arg const\"); } //Line 2 \tstatic { System.out.println(\"1st static init\"); } //Line 3 \t{ System.out.println(\"1st instance init\"); } //Line 4 \t{ System.out.println(\"2nd instance init\"); } //Line 5 \tstatic { System.out.println(\"2nd static init\"); } //Line 6 \t \tpublic static void main(String [] args) { \t\tnew Init(); \t\tnew Init(7); \t} }   1st static init 2nd static init 1st instance init 2nd instance init no-arg const 1st instance init 2nd instance init 1-arg const   Order of how the program executed:-     When new Init(); is called            Line 3       Line 6       Line 4       Line 5       Line 2           When new Init(7);is called            Line 4       Line 5       Line 1           ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-2-super-this-constructor-init-block/",
        "teaser": null
      },{
        "title": "Java - final variable, method and final class",
        "excerpt":"We can have final methods, final classes, final data members, final local variables and final parameters. A final class implicitly has all the methods as final, but not necessarily the data members. A final class may not be extended; neither may a final method be overridden.   Final primitive data members cannot be changed once they are assigned, neither may final object handle data members (Vector, String, JFrame, etc.) be reassigned to new instances, but if they are mutable (meaning they’ve got methods that allow us to change their state), their contents may be changed.   Final Methods   You can declare some or all of a class’s methods final. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses. The Object class does this—a number of its methods are final.   public class FinalBase { \tpublic final void method (){ \t\tSystem.out.println(\" This the final method\"); \t} }      In this code area we wrote a FinalBase class and a FinalInherit Class but when we try to access the list of methods which we could override we did not get to see the method which we have declared as final in FinalBase class.   Final classes   When you did not wanted the class to be inherited by any other class you use the final keyword.   public final class FinalClass{ \t... \t... }   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-3-final-methods-class/",
        "teaser": null
      },{
        "title": "Java - Object class",
        "excerpt":"The Object class sits at the top of the class hierarchy tree in the Java development environment. Every class in the Java system is a descendent (direct or indirect) of the Object class. The Object class defines the basic state and behavior that all objects must have, such as the ability to compare oneself to another object, to convert to a string, to wait on a condition variable, to notify other objects that a condition variable has changed, and to return the object’s class.   It has some important method declared which are:-      The equals Method  Use the equals to compare two objects for equality. This method returns true if the objects are equal, false otherwise. Note that equality does not mean that the objects are the same object. Consider this code that tests two Integers, one and anotherOne, for equality:   Integer one = new Integer(1), anotherOne = new Integer(1); if (one.equals(anotherOne))     System.out.println(\"objects are equal\");  This code will display objects are equal even though one and anotherOne reference two different, distinct objects. They are considered equal because they contain the same integer value.   Your classes should override this method to provide an appropriate equality test. Your equals method should compare the contents of the objects to see if they are functionally equal and return true if they are.   Let us see an example, we have a Employee class and we will override the equals method and use the employee name to compare the whether the two objects are equal or not.   package inc;  public class Employee {  \tprivate String name; \tprivate int age;  \tpublic Employee(String name, int age) { \t\tthis.name = name; \t\tthis.age = age; \t}  \tpublic String getName() { \t\treturn name; \t}  \tpublic void setName(String name) { \t\tthis.name = name; \t}  \tpublic int getAge() { \t\treturn age; \t}  \tpublic void setAge(int age) { \t\tthis.age = age; \t}  \t@Override \tpublic boolean equals(Object obj) { \t\tif (obj instanceof Employee) {  \t\t\tEmployee employee = (Employee) obj; \t\t\tif (name.equals(employee.getName())) \t\t\t\treturn true; \t\t}  \t\treturn false; \t} }         package inc;  public class Entry {  \tpublic static void main(String[] args) { \t\tEmployee employee = new Employee(\"John\", 21); \t\tEmployee employee2 = new Employee(\"John\", 45); \t\tEmployee employee3 = new Employee(\"Michel\", 25); \t\t \t\tif (employee.equals(employee2)) \t\t\tSystem.out.println(\"The two employee's are equal\"); \t\telse \t\t\tSystem.out.println(\"Sorry, the two employee's are equal\"); \t\t \t\tif (employee.equals(employee3)) \t\t\tSystem.out.println(\"The two employee's are equal\"); \t\telse \t\t\tSystem.out.println(\"Sorry, the two employee's are equal\"); \t} }         The two employee's are equal Sorry, the two employee's are equal   The toString Method  Returns a string representation of the object. In general, the toString method returns a string that “textually represents” this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method.   public class A {  \t@Override \tpublic String toString() { \t\treturn \"this is A String\"; \t} }  public class B {  \tpublic static void main(String[] args) { \t\tA a = new A(); \t\tSystem.out.println(a); \t}  }   this is A String   The Hashcode Method   Anytime you override equals() you should also override hashCode(). The hashCode() method should ideally return the same int for any two objects that compare equal and a different int for any two objects that don’t compare equal, where equality is defined by the equals() method. This is used as an index by the java.util.Hashtable class.   A hash function is any well-defined procedure or mathematical function that converts a large, possibly variable-sized amount of data into a small datum, in this case it uses int values. The values returned by a hash function are called hash codes   Hash codes are used to speed up table lookup or data comparison tasks—such as finding items in a database, detecting duplicated or similar records in a large file   In the Car example equality is determined exclusively by comparing license plates; therefore only the licensePlate field is used to determine the hash code. Since licensePlate is a String, and since the String class has its own hashCode() method, we can sponge off of that.   public int hashCode() { \t       return this.licensePlate.hashCode();      }         Other times you may need to use the bitwise operators to merge hash codes for multiple fields. There are also a variety of useful methods in the type wrapper classes (java.lang.Double, java.lang.Float, etc.) that convert primitive data types to integers that share the same bit string. These can be used to hash primitive data types.   The finalize method   Every class inherits the finalize() method from java.lang.Object .The method is called by the garbage collector when it determines no more references to the object exist. The Object finalize method performs no actions but it may be overridden by any class, normally it should be overridden to clean-up non-Java resources ie closing a file, closing database connections etc.   But best practice is to use a try-catch-finally statement and to always call super.finalize() method. Finalize runs once and only once for every object.       @Override     \tprotected void finalize() throws Throwable {     \t\ttry{     \t\t\tclose(); //close all the open file     \t\t}finally{     \t\t\tsuper.finalize();     \t\t}\t     \t}    ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-4-object-class/",
        "teaser": null
      },{
        "title": "Java - Inner class",
        "excerpt":"Inner classes let you define one class within another. They provide a type of scoping for your classes since you can make one class a member of another class. Just as classes have member variables and methods, a class can also have member classes. They come in several flavors, depending on how and where you define the inner class, including a special kind of inner class known as a “top-level nested class” (an inner class marked static), which technically isn’t really an inner class.   You define an inner class within the curly braces of the outer class:   class MyOuter { \tclass MyInner { } }   When you will compile this class, this class will produce two .class files     MyOuter.class   MyOuter$MyInner.class   Instantiating an Inner Class from Within the Outer Class   Most often, it is the outer class that creates instances of the inner class, since it is usually the outer class wanting to use the inner instance as a helper for its own personal use.   class MyOuter { \tprivate int x = 7; \tpublic void makeInner() { \t\tMyInner in = new MyInner(); // make an inner instance \t\tin.seeOuter(); \t} \tclass MyInner { \t\tpublic void seeOuter() { \t\t\tSystem.out.println(\"Outer x is \" + x); \t\t} \t} }   You can see in the preceding code that the MyOuter code treats MyInner just as though MyInner were any other accessible class—it instantiates it using the class name (new MyInner()), and then invokes a method on the reference variable (in.seeOuter()).         Creating an Inner Class Object from Outside the Outer Class Instance Code   If we want to create an instance of the inner class, we must have an instance of the outer class.   public static void main(String[] args) { \tMyOuter mo = new MyOuter(); // gotta get an instance! \tMyOuter.MyInner inner = mo.new MyInner(); \tinner.seeOuter(); }   The preceding code is the same regardless of whether the main() method is within the MyOuter class or some other class (assuming the other class has access to MyOuter, and sinceMyOuter has default access, that means the code must be in a class within the same package asMyOuter).   package inc;  class FactoryOuter { \tFactoryInner[] fi = new FactoryInner[3]; \tprotected int lastIndex = 0; \tprivate int x = 0;  \tpublic FactoryOuter(int x) { \t\tthis.x = x; \t}  \tpublic int getX() { \t\treturn x; \t}  \tpublic void addInner(int y) { \t\tif (lastIndex &lt; fi.length) { \t\t\tfi[lastIndex++] = new FactoryInner(y); \t\t} else \t\t\tthrow new RuntimeException(\"FactoryInner array full\"); \t}  \tpublic void list() { \t\tfor (int i = 0; i &lt; fi.length; i++) { \t\t\tSystem.out.print(\"I can see into the inner class where y = \" \t\t\t\t\t+ fi[i].y + \" or call display: \"); \t\t\tfi[i].display(); \t\t} \t}  \tpublic class FactoryInner { \t\tprivate int y;  \t\tprotected FactoryInner(int y) { \t\t\tthis.y = y; \t\t}  \t\tpublic void display() { \t\t\tSystem.out.println(\"FactoryInner x = \" + x + \" and y = \" + y); \t\t} \t} }  public class FactoryInnerOuter { \tpublic static void main(String[] args) { \t\tFactoryOuter fo = new FactoryOuter(1); \t\tfo.addInner(101); \t\tfo.addInner(102); \t\tfo.addInner(103); \t\tfo.list(); \t\t// fo.addInner(104); \t} }         The explanation of the code is as below     an instance of FactoryOuter contains a three element array of FactoryInner objects   the addInner method instantiates a FactoryInner object and adds it to the array (note that is still automatically associated with the FactoryOuter instance by the JVM, but we need our own mechanism for keeping track of the inner class instances we create)            a better approach would be to use one of the collections classes instead of an array, to avoid running out of room in the array           I can see into the inner class where y = 101 or call display: FactoryInner x = 1 and y = 101 I can see into the inner class where y = 102 or call display: FactoryInner x = 1 and y = 102 I can see into the inner class where y = 103 or call display: FactoryInner x = 1 and y = 103   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-5-inner-class/",
        "teaser": null
      },{
        "title": "Java - Package - the class Management",
        "excerpt":"Now we are aware of how to write the classes and are able to write simple programs in java, but what if our programs start to grow big, then how are going to manage the classes. There could be a situation where we have to handle more than thousands of classes. To do so Java has provided a concept of creating a collection of classes called packages.   The main reason for using packages is to guarantee the uniqueness of class names. Suppose two programmers come up with the bright idea of supplying an Employee class. As long as both of them place their class into different packages, there is no conflict.   Advantages of packages  Packages provide an alternative to creating procedures and functions as stand-alone schema objects, and they offer the following advantages:      Modularity: Logically related programming structures can be encapsulated in a named module. Each package is easy to understand, and the interface between packages is simple, clear, and well-defined.   Easier Application Design: Package specification and package body can be coded and compiled separately. A package specification can be coded and compiled without its body. Then, stored subprograms that reference the package can also be compiled. A user does not need to fully define the package body until he is ready to complete the application.   Hiding Information: The programming constructs declared in the package specification are public (visible and accessible to applications). The programming constructs declared in the package body are private (hidden and inaccessible to applications). The package body hides the definitions of the private constructs so that only the package is affected (not the application or any calling program) if the definitions change. This enables a user to change the implementation without having to recompile calling programs. Also, hiding the implementation details from users protects the integrity of the package.   Added Functionality: Packaged public variables and cursors persist for the duration of a session. In this way, they can be shared by all subprograms that execute in the calling environment. They also enable a user to maintain data across transactions without having to store it in the database. Private constructs also persist for the duration of the session, but can only be accessed within the package.   Better Performance: When a packaged subprogram is called for the first time, the entire package is loaded into the memory. As a result, later calls to related subprograms in the package do not require any further disk I/O. Packaged subprograms also stop cascading dependencies and thereby avoid unnecessary compilations.   Overloading: Procedures and functions, when used within a package, can be overloaded, i.e., multiple subprograms can be created with the same name in the same package, each taking different number of parameters or different types of parameters.   Class Importation   A class can use all classes from its own package and all public classes from other packages.   There are two ways to access the classes in other packages:-      Add the full package name in front of every class name for e.g.     java.util.Date today = new java.util.Date();           This is a very tedious type of importing the packages which is generally not recommended.   You place import statements at the top of your source files (but below any package statements). For example, you can import all classes in the java.util package with the statement     import java.util.*;           Then you can use     Date today = new Date();           You can also import a specific class inside a package:     import java.util.Date;                 Most of the time, you just import the packages that you need, without worrying too much about them. But if we want to import two classes with the same name from two different packages we have a problem.      So we see compilation error in the above case. To resolve this case what we do is we use the full package name to every class name   import java.util.*; import java.sql.*;  public class LearnPackages { \tjava.util.Date today; \tjava.sql.Date tommorow;  }   Addition of classes into a package   To place classes inside a package, you must put the name of the package at the top of your source file, before the code that defines the classes in the package.   package somePackage;   public class LearnPackages { \tpublic static void main (String args[]){ \t\t \t} }   If you don’t put a package statement in the source file, then the classes in that source file belong to the default package. The default package has no package name. Up to now, all our example classes were located in the default package. The folder structure will be as follows:-   $ src/somePackage/LearnPackages.java   Access Modifiers   In Java code, class and variable and method and constructor declarations can have “access specifiers”, that is one of: private, protected, public. (or none.).   The purpose of access specifiers is to declare which entity cannot be accessed from where. Its effect has different consequences when used on a class, class member (variable or method), and constructor.   Access modifiers for Classes  There are total 2 types of access specifire available.     Public   Default Let us go though each of them one by one   public  A class declaration with the public keyword gives all classes from all packages access to the public class. Means you can access any public class just by importing the class with its package.   Default Access   A class with default access has no modifier preceding it in the declaration! It’s the access control you get when you don’t type a modifier in the class declaration. Think of default access as package-level access, because a class with default access can be seen only by classes within the same package.   Let us consider that         So the class is not visible in the other package if we use the default access specifier, but if we try to access the ClassA in inc.chapter5 package only then all the methods will be visible to the classes declared in the same package         Access modifiers for Methods/Variables  Method and variable members are usually given access control in exactly the same way, whereas a class can use just two of the four access control levels (default or public), members can use all four:     Public   Protected   Default   private   public methods/variables  When a method or variable member is declared public, it means all other classes, regardless of the package they belong to, can access the member (assuming the class itself is visible).   private method/varaible  Members marked private can’t be accessed by code in any class other than the class in which the private member was declared.   Protected and Default Members  The protected and default access control levels are almost identical, but with one critical difference. A default member may be accessed only if the class accessing the member belongs to the same package, whereas a protected member can be accessed (through inheritance) by a subclass even if the subclass is in a different package.                  Access Specifire       Description                       public       Visible to all the classes                 private       Visible only in an implementing class                 protected       Visible in implementing class and subclasses everywhere                 (Default)       Visible only in the current package           package inc;  public class TestPack1 {  \tpublic void pack1PublicMethod(){ \t\tSystem.out.println(\"Public method from pack 1\"); \t} \t \tprotected void pack1ProtectedMethod(){ \t\tSystem.out.println(\"Protected method from pack 1\"); \t} \t \tvoid pack1DefaultMethod(){ \t\tSystem.out.println(\"Default method from pack 1\"); \t} \t \tprivate void pack1PrivateMethod(){ \t\tSystem.out.println(\"private method from pack 1\"); \t}\t }                In the above code we have shown:-     In the same package, available methods are of public, protected and default access modifiers.   In different package, only method of public access modifier is available.   Where as if the class is extending super class of different package, available methods are of public and protected access modifiers.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-6-package/",
        "teaser": null
      },{
        "title": "Java - Classpath",
        "excerpt":"CLASSPATH tells Java where to search for programs.   The Java runtime system needs to know where to find programs that you want to run and libraries that are needed. It knows where the predefined Java packages are, but if you are using additional packages, you must tell specify where they are located.   For example, suppose you want the Java runtime to find a class named Cool.class in the package utility.myapp. If the path to that directory is C:\\java\\MyClasses\\utility\\myapp, you would set the class path so that it contains /src/java/MyClasses. To run that app, you could use the following JVM command:   $ java -classpath /src/java/MyClasses utility.myapp.Cool    When the app runs, the JVM uses the class path settings to find any other classes defined in the utility.myapp package that are used by the Cool class.   Adding Folders and archive files to classpath  When classes are stored in a directory (folder), like /src/java/MyClasses/utility/myapp, then the class path entry points to the directory that contains the first element of the package name. (in this case, /src/java/MyClasses, since the package name is utility.myapp.)   But when classes are stored in an archive file (a .zip or .jar file) the class path entry is the path to and including the .zip or .jar file. For example, to use a class library that is in a .jar file, the command would look something like this:   $ java -classpath /src/java/MyClasses/myclasses.jar utility.myapp.Cool         Multiple specifications  To find class files in the directory /src/java/MyClasses as well as classes in /src/java/OtherClasses, you would set the class path to:  $ java -classpath /src/java/MyClasses;/src/java/OtherClasses   Note that the two paths are separated by a semicolon.   Using the CLASSPATH environment variable  Use the below command to set the CLASSPATH for the system variable.  $ set CLASSPATH=classpath1;classpath2...  For e.g. if my classes are located at the location /src/java/myAppClasses, then to set the classpath in the command line use the following command.   $ set CLASSPATH=/src/java/myAppClasses;   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-7-classpath/",
        "teaser": null
      },{
        "title": "Java - Handling String",
        "excerpt":"In Java, strings are objects. Just like other objects, you can create an instance of a String with the new keyword, as follows:  String s = new String(\"abc\");  This line of code creates a new object of class String, assigns it to the reference variable s and initialized it. So far, String objects seem just like other objects.   Constructors   String()\t\t String(byte[] bytes)\t\t String(byte[] ascii, int hibyte)\t String(byte[] bytes, int offset, int length)\t\t String(byte[] ascii, int hibyte, int offset, int count)\t String(byte[] bytes, String charsetName)\t\t String(char[] value)\tString(String original) String(byte[] bytes, int offset, int length, String charsetName)    We can write it in this way also:-  String s = \"abc\";  Now we create a new reference s2 to s  String s2 = s;  So far this is behaving same as other classes but with next step the expected result is different, Let first see what it he result.   public class TestObjectReference { \tprivate String value;  \tpublic TestObjectReference(String value) { \t\tthis.value = value; \t} \tpublic String getValue() { \t\treturn value; \t} \tpublic void setValue(String value) { \t\tthis.value = value; \t} }  public class StringTest {  \tpublic static void main(String[] args){ \t\t//Working with any Object class \t\tTestObjectReference reference = new TestObjectReference(\"abcd\"); \t\tTestObjectReference reference2 = reference; \t\t \t\treference2.setValue(\"Changed the value\"); \t\tSystem.out.println(reference.getValue()); \t\t \t\tSystem.out.println(\"***********Let us try now with String Class **************\"); \t\t \t\tString str = \"ABCD\"; \t\tString str2 = str; \t\t \t\tstr2 = \"Changed the value\"; \t\t \t\tSystem.out.println(str); \t} }  Changed the value ***********Let us try now with String Class ************** ABCD   We do not get the expected output, so where is the problem, where are we making the mistakes.   The problem is String are immutable objects, means whenever we make any change to the value a new String object is created.      Let us consider another case:-   String str = \"ABC\"; str = \"XYZ\";         In this case too we have      So now we consider a situation in which we have too many String operations then in that case we may run out of memory as every time you modify a String a new memory location is allocated.   To solve this problem we have another Class provided for String manipulation, i.e. the StringBuffer class.   Important Methods in the String Class  The following methods are some of the more commonly used methods in the String class.   public char charAt(int index)  This method returns the character located at the String’s specified index. Remember, String indexes are zero-based—for example  String x = \"airplane\"; System.out.println( x.charAt(2) ); // output is 'r'   public String concat(String s)  This method returns a String with the value of the String passed in to the method appended to the end of the String used to invoke the method.   String x = \"taxi\"; System.out.println( x.concat(\" cab\") ); // output is \"taxi cab\"         public boolean equalsIgnoreCase(String s)  This method returns a boolean value (true or false) depending on whether the value of the String in the argument is the same as the value of the String used to invoke the method. This method will return true even when characters in the String objects being compared have differing cases.   String x = \"Exit\"; System.out.println( x.equalsIgnoreCase(\"EXIT\")); // output is \"true\" System.out.println( x.equalsIgnoreCase(\"tixe\")); // output is \"false\"   public int length()  This method returns the length of the String used to invoke the method   String x = \"01234567\"; System.out.println( x.length() ); // returns \"8\"   public String replace(char old, char new)  This method returns a String whose value is that of the String used to invoke the method, updated so that any occurrence of the char in the first argument is replaced by the char in the second argument   String x = \"oxoxoxox\"; System.out.println( x.replace('x', 'X') ); // output is // \"oXoXoXoX\"   public String substring(int begin) / public String substring(int begin, int end)  The substring() method is used to return a part (or substring) of the String used to invoke the method.   String x = \"0123456789\";// as if by magic, the value  \t\t\t\t//of each char \t\t\t\t//is the same as its index! System.out.println( x.substring(5) ); // output is \"56789\" System.out.println( x.substring(5, 8)); // output is \"567\"         When we are specifying the second argument ‘end index’, it will always take the value till the (end -1) just as in above example, substring (5, 8) will retrieve only “567” as output.   public String toLowerCase()  This method returns a String whose value is the String used to invoke the method, but with any uppercase characters converted to lowercase  String x = \"A New Moon\"; System.out.println( x.toLowerCase() ); // output is \"a new moon\"   public String toString()  This method returns the value of the String used to invoke the method. What? Why would you need such a seemingly “do nothing” method? All objects in Java must have a toString() method, which typically returns a String that in some meaningful way describes the object in question.  String x = \"big surprise\"; System.out.println( x.toString() ); // output is obviously the same.   public String toUpperCase()  String x = \"A New Moon\"; System.out.println( x.toUpperCase() ); // output is \"A NEW MOON\"   public String trim()  This method returns a String whose value is the String used to invoke the method, but with any leading or trailing blank spaces removed.  String x = \" hi \"; System.out.println( x + \"x\" ); // result is \" hi x\" System.out.println( x.trim() + \"x\"); // result is \"hix\"   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-8-String/",
        "teaser": null
      },{
        "title": "Java - StringBuffer",
        "excerpt":"The java.lang.StringBuffer class should be used when you have to make a lot of modifications to strings of characters. String objects are immutable, so if you choose to do a lot of manipulations with String objects, you will end up with a lot of abandoned String objects in the String pool. On the other hand, objects of type StringBuffer can be modified over and over again without leaving behind a great effluence of discarded String objects, i.e. StringBuffer is mutable as compared to String Class which is immutable. There is one more important difference,  that is the StringBuffer is synchronised.   Constructors  StringBuffer() StringBuffer(int length) StringBuffer(String str)  Every string buffer has a capacity. As long as the length of the character sequence contained in the string buffer does not exceed the capacity, it is not necessary to allocate a new internal buffer array. If the internal buffer overflows, it is automatically made larger. The default Buffer size is 16 characters.   String x = \"abc\"; x = x.concat(\"def\"); System.out.println(\"x = \" + x); // output is \"x = abcdef\"  StringBuffer sb = new StringBuffer(\"abc\"); sb.append(\"def\"); System.out.println(\"sb = \" + sb); // output is \"sb = abcdef\"   Important Methods in the StringBuffer Class  public StringBuffer append(String s)   This method will take many different arguments, including boolean, char, double, float, int, long, and others, but the most likely use on the exam will be a String argument.   StringBuffer sb = new StringBuffer(\"set \"); sb.append(\"point\"); System.out.println(sb); // output is \"set point\" StringBuffer sb2 = new StringBuffer(\"pi = \"); sb2.append(3.14159f); System.out.println(sb2); // output is \"pi = 3.14159\"   public StringBuffer delete(int start, int end)  This method returns a StringBuffer object and updates the value of the StringBuffer object that invoked the method call. In both cases, a substring is removed from the original object. The starting index of the substring to be removed is defined by the first argument (which is zero-based), and the ending index of the substring to be removed is defined by the second argument.  StringBuffer sb = new StringBuffer(\"0123456789\"); System.out.println(sb.delete(4,6)); // output is \"01236789\"         public StringBuilder insert(int offset, String s)  This method returns a StringBuffer object and updates the value of the StringBuffer object that invoked the method call. In both cases, the String passed in to the second argument is inserted into the original StringBuffer starting at the offset location represented by the first argument (the offset is zero-based). Again, other types of data can be passed in through the second argument (boolean, char, double, float, int, long, and so on)   StringBuilder sb = new StringBuilder(\"01234567\"); sb.insert(4, \"---\"); System.out.println( sb ); // output is \"0123---4567\"   public synchronized StringBuffer reverse()  This method returns a StringBuffer object and updates the value of the StringBuffer object that invoked the method call. In both cases, the characters in the StringBuffer are reversed, the first character becoming the last, the second becoming the second to the last, and so on.   StringBuffer s = new StringBuffer(\"A man a plan a canal Panama\"); sb.reverse(); System.out.println(sb); // output: \"amanaP lanac a nalp a nam A\"   public String toString()  This method returns the value of the StringBuffer object that invoked the method call as a String.  StringBuffer sb = new StringBuffer(\"test string\"); System.out.println( sb.toString() ); // output is \"test string\"   public class Main {  \tpublic static void main(String[] args) { \t\tStringBuffer sb = new StringBuffer(); \t\tStringBuffer sb2 = sb; \t\tsb.append(true); \t\tsb.append('A');  \t\tchar[] carray = { 'a', 'b', 'c' }; \t\tsb.append(carray); \t\tsb.append(carray, 0, 1); \t\tsb.append(3.5d);  \t\tsb2.append(2.4f); \t\tsb2.append(45); \t\tsb2.append(90000l);  \t\tsb2.append(\"That's all!\");  \t\tSystem.out.println(sb); \t} }  trueAabca3.52.44590000That's all!   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-9-StringBuffer/",
        "teaser": null
      },{
        "title": "Java - Documentation",
        "excerpt":"The JDK contains a very useful tool, called javadoc, that generates HTML documentation from your source files. If you add comments that start with the special delimiter /** to your source code, you too can easily produce professional-looking documentation.   Each comment is placed immediately above the feature it describes. A comment starts with a /** and ends with a */. Each /** . . . */ documentation comment contains free-form text followed by tags. A tag starts with an @, such as @author or @param. In the free-form text, you can use HTML modifiers such as … for emphasis, ... for a monospaced “typewriter” font, … for strong emphasis, and even &lt;img …&gt; to include an image.   Class Comments  The class comment must be placed after any import statements, directly before the class definition.   Here is an example of a class comment:   /** * A &lt;code&gt;Card&lt;/code&gt; object represents a playing card, such * as \"Queen of Hearts\". A card has a suit (Diamond, Heart, * Spade or Club) and a value (1 = Ace, 2 . . . 10, 11 = Jack, * 12 = Queen, 13 = King) */ public class Card {  }   @author name  This tag makes an “author” entry. You can have multiple @author tags, one for each author.   @version text  This tag makes a “version” entry. The text can be any description of the current version.   Method Comments  Each method comment must immediately precede the method that it describes. In addition to the general-purpose tags, you can use the following tags:         @param variable description  This tag adds an entry to the “parameters” section of the current method. The description can span multiple lines and can use HTML tags. All @param tags for one method must be kept together.   @return description  This tag adds a “returns” section to the current method. The description can span multiple lines and can use HTML tags.   @throws class description  This tag adds a note that this method may throw an exception. We will see in later chapter’s  what is an exception   /** * Raises the salary of an employee. * @param byPercent percentage by which to raise the salary (e.g. 10 = 10%) * @return the amount of the raise */ public double raiseSalary(double byPercent) {     double raise = salary * byPercent / 100;     salary += raise;     return raise; }   Field Comments  You only need to document public fields—generally that means static constants.   /** * The \"Hearts\" card suit */ public static final int HEARTS = 1;         Comment Extraction   Let us consider we want to now create actual html documentation.   Suppose we have a package named as javaDocTest which has a class TestDoc and now we want to create documentation and we want to keep the documents in the folder KeepDocFolder then in that case we give the following command   $ javadoc -d keepDocFolder javaDocTest      After this command is executed the following structure will be created      This folder will contain the entire document for classes and methods,      Now if we click on the TestDoc link it will give the details of all the methods declared in the class.      ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-1-java-documentation/",
        "teaser": null
      },{
        "title": "Java - Exception mechanism",
        "excerpt":"An exception is a problem that arises during the execution of a program. An exception can occur for many different reasons, including the following:      A user has entered invalid data.   A file that needs to be opened cannot be found.   A network connection has been lost in the middle of communications, or the JVM has run out of memory.   Some of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.   Let’s take an example of the Car, in which the engine of the car explodes due to heat if the speed of the car reaches beyond 100 miles/hour. Thus, explosion of the car is the exception that is caused against the normal speeding up of the car.      In order to avoid that explosion what one can do is when the car reaches 90 miles/hour, an indicator glows and the driver is forced to retard the car speed.      Hence the analogy that would be apt here would be explosion of the car as the creation of exception and glowing of the indicator as catching the exception in order to avoid that exception to hamper the proper functioning of the car.   Catching Exceptions:  A method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:   try {    //Protected code }catch(ExceptionName e1) {    //Catch block }   The try block contains code that throws exceptions. Code that doesn’t throw exceptions may also be included. The catch keyword is followed by a declaration, which appears in parentheses. Like any declaration, this consists of a type followed by a name. The type must match the type of the exception being thrown in the try block. For e.g.   1. public class ExcepTest{ 2.  3.   public static void main(String args[]){ 4.      try{ 5.         int a[] = new int[2]; 6.         System.out.println(\"Access element three :\" + a[3]); 7.      } 8.      catch(ArrayIndexOutOfBoundsException e){ 9.         System.out.println(\"Exception thrown  :\" + e); 10.      } 11.      System.out.println(\"Out of the block\"); 12.   } 13. }  In the above mentioned code we have declared an array with size 2, but while printing the values we are trying to access the values at memory location 3, which is not a valid condition.   Line 1-3 is just setup. The try block is lines 4–7. Note that only line 6 can throw an exception. Lines 9–12 are the catch block.         Multiple catch Blocks   A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:   try {    //Protected code }catch(ExceptionType1 e1) {    //Catch block }catch(ExceptionType2 e2) {    //Catch block }catch(ExceptionType3 e3) {    //Catch block }   The previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.   Note: The hierarchy order of Exception types for the catch block should such that the parent Exception class is at the last position, i.e. suppose we have three types of exception:  IOException, SQLException,\tException. Then it must be arranged such that Exception is at the last.    public class Main {  \tpublic static void main(String[] args) { \t\tint array[] = { 20, 10, 30 }; \t\tint num1 = 15; \t\tint res = 0;  \t\tfor (int ct = 3; ct &gt;= 0; ct--) { \t\t\ttry { \t\t\t\tres = num1 / ct; \t\t\t\tSystem.out.println(\"The result is: \" + res); \t\t\t\tSystem.out.println(\"The value of array are: \" + array[ct]);  \t\t\t}  \t\t\tcatch (ArrayIndexOutOfBoundsException e) { \t\t\t\tSystem.out.println(\"Error…. Array is out of Bounds\"); \t\t\t}  \t\t\tcatch (ArithmeticException e) { \t\t\t\tSystem.out.println(\"Can't be divided by Zero\"); \t\t\t} \t\t} \t} }  The result is: 5 Error…. Array is out of Bounds The result is: 7 The value of array are: 30 The result is: 15 The value of array are: 10 Can't be divided by Zero         Using finally   The finally block always executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. But finally is useful for more than just exception handling — it allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break. Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated.   If an exception occurs and there is a return statement in catch block, the finally block is still executed. The finally block will not be executed when the System.exit(0) statement is executed earlier or on system shut down earlier or the memory is used up earlier before the thread goes to finally block.   1: try { 2: // This is the first line of the \"guarded region\". 3: } 4: catch(MyFirstException) { 5: // Put code here that handles this exception 6: } 7: catch(MySecondException) { 8: // Put code here that handles this exception 9: } 10: finally { 11: // Put code here to release any resource we 12: // allocated in the try clause. 13: } 14: 15: // More code here   Let us understand the above scenario, we enter the try block at line no 1. There are two possibilities:-      No exception is thrown at line number 2, then in this case the program will execute the following line numbers     1 --&gt; 2 --&gt; 3 --&gt; 10 --&gt; 11 --&gt; 12 --&gt; 13 --&gt; …..           If the exception (of type MySecondException)  is thrown at line no 2, then in this case the program will execute the following line numbers     1 --&gt; 2 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 10 --&gt; 11 --&gt; 12 --&gt; 13 --&gt; …..                 Generally if we are using other resources for e.g. database connection or file access, then in these cases if any exception occurs then we have to take care to close these resources, this condition is taken care in the finally block.   public class Main {  \tpublic static void main(String[] args) { \t\ttry { \t\t\tint a = 25; \t\t\tint b = 0; \t\t\tint c = a / b; \t\t} catch (ArithmeticException e) { \t\t\tSystem.out.println(\"Arithmatic exception caught in main()\"); \t\t} finally { \t\t\tSystem.out.println(\"finally block for second try block in main()\"); \t\t} \t\tSystem.out.println(\"Code after second try block in main()\"); \t} }   Arithmatic exception caught in main() finally block for second try block in main() Code after second try block in main()   The throws Keyword   If a method does not handle a checked exception, the method must declare it using the throws keyword. The throws keyword appears at the end of a method’s signature.   We have a situation where we know that my method may throw an exception but we do not want to deal it with right now, we want the exception to be handled when we are calling these methods.   If you want you want someone else to handle the exception you will use the throws keyword.         public class Test {  \tpublic void printArray (int value) throws ArrayIndexOutOfBoundsException{ \t\tint[] a = new int[2]; \t\ta[0] = 5; \t\ta[1] =10; \t\t \t\tSystem.out.println(a[value]); \t} \tpublic static void main(String[] args){ \t\tTest test = new Test(); \t\t \t\ttry { \t\t\ttest.printArray(1); \t\t\ttest.printArray(3); \t\t} catch (ArrayIndexOutOfBoundsException e) { \t\t\tSystem.out.println(\"oops!! there is an error\"); \t\t} \t\t \t} }   Here we have declared a method named as printArray which throws ArrayIndexOutOfBoundsException so if we try to access the value of index 3, this method will throw an exception which we will have to catch at the time of implementation of the method.   10 oops!! there is an error   The throw Keyword   You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the throw keyword.   Let us consider in the above example:-   public class Main {  \tpublic void printArray(int value) throws ArrayIndexOutOfBoundsException { \t\tint[] a = new int[2]; \t\ta[0] = 5; \t\ta[1] = 10;  \t\tSystem.out.println(a[value]); \t}  \tpublic void accessMethod(int temp) throws Exception { \t\ttry { \t\t\tprintArray(temp); \t\t} catch (ArrayIndexOutOfBoundsException e) { \t\t\tthrow e; \t\t}  \t}  \tpublic static void main(String[] args) { \t\tMain test = new Main();  \t\ttry { \t\t\ttest.accessMethod(1); \t\t\ttest.accessMethod(5); \t\t} catch (Exception e) { \t\t\te.printStackTrace(); \t\t} \t}  }   In this example we are calling accessMethod which in turn calls printArray method, the exception is caught in the accessMethod, but we do not want to handle the exception so we again throw this caught exception to implanting method. When an exception is thrown then we do not return to the calling point.   10 java.lang.ArrayIndexOutOfBoundsException: 5 \tat Main.printArray(scratch_1.java:7) \tat Main.accessMethod(scratch_1.java:12) \tat Main.main(scratch_1.java:24)   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-2-exception-handling/",
        "teaser": null
      },{
        "title": "Java - Exception Hierarchy",
        "excerpt":"All exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.   Errors are not normally trapped form the Java programs. These conditions normally happen in case of severe failures, which are not handled by the java programs. Errors are generated to indicate errors generated by the runtime environment. Example:  JVM is out of Memory. Normally programs cannot recover from errors. The only difference between Exception and Error is that you can handle the exception but cannot handle an error.      Exceptions Methods   Following is the list of important methods available in the Throwable class.                  no       Methods with Description                       1       public String getMessage() Returns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.                 2       public Throwable getCause() Returns the cause of the exception as represented by a Throwable object.                 3       public String toString() Returns the name of the class concatenated with the result of getMessage()                 4       public void printStackTrace() Prints the result of toString() along with the stack trace to System.err, the error output stream.                 5       public StackTraceElement [] getStackTrace() Returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.                 6       public Throwable fillInStackTrace() Fills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.           public class Test {  \tpublic static void main(String[] args){ \t\ttry{ \t\t\tint[] a = new int[1]; \t\t\ta[2] = 5; \t\t}catch (Exception e) { \t\t\tSystem.out.println(e.getMessage()); \t\t\tSystem.out.println(\"***********************\"); \t\t\tSystem.out.println(e.getCause()); \t\t\tSystem.out.println(\"***********************\"); \t\t\tSystem.out.println(e.toString()); \t\t\tSystem.out.println(\"***********************\"); \t\t\te.printStackTrace(); \t\t\tSystem.out.println(\"***********************\"); \t\t\tSystem.out.println(e.getStackTrace()); \t\t\tSystem.out.println(\"***********************\"); \t\t\tSystem.out.println(e.fillInStackTrace()); \t\t} \t} }   2 *********************** null *********************** java.lang.ArrayIndexOutOfBoundsException: 2 *********************** java.lang.ArrayIndexOutOfBoundsException: 2 \tat Scratch.main(scratch_1.java:6) *********************** [Ljava.lang.StackTraceElement;@5e2de80c *********************** java.lang.ArrayIndexOutOfBoundsException: 2   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-3-exception-hierarchy/",
        "teaser": null
      },{
        "title": "Java - Exception Types",
        "excerpt":"There are many predefined Exceptions available in java which are mentioned below, these are some of the common exceptions seen.                  Exception Type       Description                       java.lang.RuntimeException       RuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine.                 ArithmeticException       Thrown when an exceptional arithmetic condition has occurred. For example, an integer “divide by zero” throws an instance of this class.                 ArrayStoreException       Thrown to indicate that an attempt has been made to store the wrong type of object into an array of objects.                 ClassCastException       Thrown to indicate that the code has attempted to cast an object to a subclass of which it is not an instance.                 IndexOutOfBoundsException       Thrown to indicate that an index of some sort (such as to an array, to a string, or to a vector) is out of range.                 NullPointerException       Thrown when an application attempts to use null in a case where an object is required                 ClassNotFoundException       Thrown when an application tries to load in a class through its string name                 IllegalAccessException       An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.                 IOException       Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.           Custom Exception (Declaring you own)   You can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes:      All exceptions must be a child of Throwable.   If you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.   If you want to write a runtime exception, you need to extend the RuntimeException class.   We can define our own Exception class as below:   class MyException extends Exception{ }  You just need to extend the Exception class to create your own Exception class. These are considered to be checked exceptions. The following InsufficientFundsException class is a user-defined exception that extends the Exception class. An exception class is like any other class, containing useful fields and methods.   //Declaring a user defined Exception  public class InsufficientFundsException extends Exception { \t \tprivate double amount; \t \tpublic InsufficientFundsException(double amount) \t{ \t   this.amount = amount; \t} \t \tpublic double getAmount() \t{ \t   return amount; \t} }   public class AccessFund { \t \tprivate double balance; \tprivate int accountNo; \t \tpublic AccessFund(int accountNo, double balance) { \t\tthis.accountNo = accountNo; \t\tthis.balance = balance; \t} \t \tpublic void depositAmount(double amount){ \t\tbalance = balance + amount; \t} \t \tpublic void withdraw (double amount) throws InsufficientFundsException{ \t\tif (balance &gt; amount){ \t\t\tbalance = balance - amount; \t\t\tSystem.out.println(\"Amount withdrawn = \" + amount + \" Now the current balance is \" + balance); \t\t} \t\telse \t\t{ \t\t\tdouble requiredAmount = amount - balance; \t\t\tthrow new InsufficientFundsException(requiredAmount);\t\t \t\t} \t} }   public class Test {  \tpublic static void main(String[] args){ \t\tAccessFund newAccount = new AccessFund(1, 5000); \t\t \t\ttry { \t\t\tnewAccount.depositAmount(1000); \t\t\tnewAccount.withdraw(2000); \t\t\tSystem.out.println(\"trying to withdraw 5000 now\"); \t\t\tnewAccount.withdraw(5000); \t\t} catch (InsufficientFundsException e) { \t\t\tSystem.out.println(e.getAmount() + \" money required\"); \t\t} \t} }   In the above code we have declared a class which has two methods depositAmount and withdraw, but if we try to withdraw money more than the current balance then the method will throw an InsufficientFundsException.         Amount withdrawn = 2000.0 Now the current balance is 4000.0 trying to withdraw 5000 now 1000.0 money required   Checked vs Unchecked Exceptions   In Java the Exception are divided primarily in two different categories     Checked Exceptions   Unchecked Exceptions (also known as Runtime Exceptions)   Checked Exceptions   A checked exception is an exception that is typically a user error or a problem that cannot be foreseen by the programmer. For example, if a file is to be opened, but the file cannot be found, an exception occurs. These exceptions cannot simply be ignored at the time of compilation.   Some of the commonly used checked exceptions are :-                  Exception       Description                       ClassNotFoundException       Thrown when an application tries to load in a class through its string name                 IllegalAccessException       An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor.                 IOException       Signals that an I/O exception of some sort has occurred. This class is the general class of exceptions produced by failed or interrupted I/O operations.                 User defined exceptions       The user defines the exceptions by inheriting the Exception Class.           A custom checked exception  public class CheckedException extends Exception {          public CheckedException(String errorMessage) {         super(errorMessage);     } }         Unchecked Exceptions  An unchecked or runtime exception is an exception that occurs that probably could have been avoided by the programmer. As opposed to checked exceptions, runtime exceptions are ignored at the time of compilation.   Most commonly faced runtime exceptions are :-                  Exception       Description                       ArithmeticException       Thrown when an exceptional arithmetic condition has occurred. For example, an integer “divide by zero” throws an instance of this class.                 ClassCastException       Thrown to indicate that the code has attempted to cast an object to a subclass of which it is not an instance.                 IndexOutOfBoundsException       Thrown to indicate that an index of some sort (such as to an array, to a string, or to a vector) is out of range.                 NullPointerException       Thrown when an application attempts to use null in a case where an object is required           A custom un-checked exception  public class UnCheckedException extends RuntimeException {          public CheckedException(String errorMessage) {         super(errorMessage);     } }   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-4-exception-types/",
        "teaser": null
      },{
        "title": "Java - Assertions",
        "excerpt":"Assertions are used to stop execution when “impossible” situations are detected. Assertions were introduced mainly to help the programmer to debug the application. We use assertion for the below mentioned conditions.           Impossible conditions. Program debugging is filled with “impossible” problems (“But that parameter can’t possibly be null”). If you’re lucky, the problem is detected immediately in some way you can easily diagnose. If not, the error may propagate thru the program, finally crashing, but so far from the original bug that diagnosis is difficult. Even worse, the bug may not produce visible symptoms until after it has altered permanent data. Assert statements provide an easy means to check for impossible conditions, with little or no runtime cost.            Programmer, not user problems. The purpose or asserts is to detect programming errors, and they should not be used in the case of erroneous user input or actions.            Crash as quickly as possible. Discovering bugs as early as possible is good. Every program starts with bugs, and the debugging process is faster and simpler when the bugs are detected early. It’s better to discover a problem at compile time than at run time, and it’s better to discover a run-time bug as early as possible. Often a run-time bug doesn’t cause an immediate, visible, disaster. Instead, the consequences of the bug distort the following execution, and the bad effects may not become visible for a long time. The crippled program may corrupt files or have other bad consequences. Tracing symptoms back to the original cause can be a long, tedious process. The goal is to detect bugs as early as possible. Assertions provide a relatively painless way to stop many bugs before they go too far.       There are two forms of the assert statement:-      Usual form   Abbreviated form   Usual form   An assert statement has two parts separated by a colon. The boolean condition must be true for execution to continue. If it is false, an AssertionError is thrown, which terminates execution and display the message string. Some examples   assert accountNumber &lt;= 1 : \"Account number cannot be less than 1\";  assert connector != null : \"merge: Connector null for \" + rel;   When asserts are enabled, the assert statement checks the condition (account number &lt; 1, connector is not null, etc) which must be true for the program to function correctly. If it’s true, execution continues. If connector is null (expression is false), an exception containing the message is thrown. This message is for the programmer, so it doesn’t have to be user friendly.         Abbreviated form   The simplest form the assert statement specifies only a boolean expression that must be true. This is ok when there’s not much to say, or the likelyhood of failing seems so remote it isn’t worth the extra typing:   assert n &gt; 0;   Enabling Assertion  Assertion checking defaults to off at runtime.  Let us see an example:-   public class Test {  \tpublic static void main(String[] args){ \t\tassert (args[0].equals(\"Hi\")) : \"show me the message\"; \t\tSystem.out.println(\"Hello Assert\"); \t} }   When we compile and run this program we get the output as   $ javac Test.java  $ java Test Hello Assert  So we see that the assert statement is not executing, so in order to run the program with assert statement we will use the following way.   $ java -ea Test  Now we could see that program ends on the assert statement. And hence letting us know that program is now working fine at this condition.   Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0 \tat Scratch.main(scratch_1.java:4)         Disabling Assertion  Similarly we can also disable assertion using the following way to run the program   $ java -da Test   When to use   There are many condition in which you can use assertion:-     To indicate their assumptions concerning a program’s behavior   Place an assertion at any location you assume will not be reached   Use an assertion to test a nonpublic method’s precondition that you believe will be true no matter what a client does with the class.   You can test post condition with assertions in both public and nonpublic methods.   When not to use  You should always take care of using assertion, some points to take care of are:-     Do not use assertions for argument checking in public methods.   Do not use assertions to do any work that your application requires for correct operation.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-5-assertions/",
        "teaser": null
      },{
        "title": "Java - Multi Threading",
        "excerpt":"Nearly every operating system supports the concept of processes – independently running programs that are isolated from each other to some degree.   For e.g. when you are using a computer you can browse internet while listening to the music, or using word processed or accessing other folders at the same time.      Threads are sometimes referred to as lightweight processes. Like processes, threads are independent, concurrent paths of execution through a program, and each thread has its own stack, its own program counter, and its own local variables. However, threads within a process are less insulated from each other than separate processes are. They share memory, file handles, and other per-process state.      A process can support multiple threads, which appear to execute simultaneously and asynchronously to each other. Multiple threads within a process share the same memory address space, which means they have access to the same variables and objects, and they allocate objects from the same heap. While this makes it easy for threads to share information with each other, you must take care to ensure that they do not interfere with other threads in the same process.   Because multiple threads coexist in the same memory space and share the same variables, you must take care to ensure that your threads don’t interfere with each other.   Why use threads?   Some of the reasons for using threads are that they can help to:      Increase the responsiveness of GUI applications   Take advantage of multiprocessor systems   Simplify program logic when there are multiple independent entities   Perform blocking I/O without blocking the entire program   There are several ways to create a thread in a Java program. Every Java program contains at least one thread: the main thread. Additional threads are created instantiating classes that extend the Thread class or by implementing the Runnable interface.   Thread class and Runnable Interface   A new thread is born when we create an instance of the java.lang.Thread class or java.lang.Runnable interface. The Thread object represents a real thread in the Java interpreter and serves as a handle for controlling and synchronizing its execution. With it, we can start the thread, stop the thread, or suspend it temporarily.   You’ll find methods in the Thread class for managing threads including creating, starting, and pausing them. For e.g.      start()   yield()   sleep()   run()   The action happens in the run() method. Think of the code you want to execute in a separate thread as the job to do.   public void run() { \t// your job code goes here }   You always write the code that needs to be run in a separate thread in a run() method. The run() method will call other methods, of course, but the thread of execution—the new call stack—always begins by invoking run().         Defining a Thread  To define a thread, you need a place to put your run() method, and as we just discussed, you can do that by extending the Thread class or by implementing the Runnable interface.   Extending java.lang.Thread  The simplest way to define code to run in a separate thread is to     Extend the java.lang.Thread class.   Override the run() method.   class MyThread extends Thread { \tpublic void run() { \t\tSystem.out.println(\"Important job running in MyThread\"); \t} }  The limitation with this approach (besides being a poor design choice in most cases) is that if you extend Thread, you can’t extend anything else. And it’s not as if you really need that inherited Thread class behavior, because in order to use a thread you’ll need to instantiate one anyway.   Implementing java.lang.Runnable   Implementing the Runnable interface gives you a way to extend from any class you like, but still define behavior that will be run by a separate thread.   class MyRunnable implements Runnable { \tpublic void run() { \t\tSystem.out.println(\"Important job running in MyRunnable\"); \t} }   Instantiating a Thread   Remember, every thread of execution begins as an instance of class Thread. Regardless of whether your run() method is in a Thread subclass or a Runnable implementation class, you still need a Thread object to do the work.   If you extended the Thread class, it is very simple to instantiate:-   MyThread t = new MyThread();   If you are using the Runnable interface then you have to follow some simple steps:-     You instantiate your Runnable class     MyRunnable r = new MyRunnable();               now you get a java.lang.Thread class to execute the thread and pass your runnable class to this thread class.     Thread t = new Thread(r); // Pass your Runnable to the Thread           Now our thread class is ready to be used. You can pass a single Runnable instance to multiple Thread objects, so that the same Runnable becomes the target of multiple threads, as follows:   public class TestThreads { \tpublic static void main (String [] args) { \t\tMyRunnable r = new MyRunnable(); \t\t \t\tThread foo = new Thread(r); \t\tThread bar = new Thread(r); \t\tThread bat = new Thread(r); \t} }   Giving the same Runnable to multiple threads means that several threads of execution will be running the very same job (and that the same job will be done multiple times).         Starting a Thread  Now we have our thread created (this state is of the thread is called to be in new state). And we have to start the thread, in order to start the thread we simply call the start() method of Thread class.       t.start();   When the start method is called the thread now is said to move in Runnable state, in this state the thread is waiting for its turn to come to executed by the JVM. When the run method is fired then the thread is actually running and is said to be in running state.      Putting it all together   Now let us see a simple program which uses the threads to execute. In this case we have create a FooRunnable class which implements Runnable interface.   class FooRunnable implements Runnable { \tpublic void run() { \t\tfor(int x =1; x &lt; 6; x++) { \t\t\tSystem.out.println(\"Runnable running\"); \t\t} \t} }   public class TestThreads { \tpublic static void main (String [] args) { \t\tFooRunnable r = new FooRunnable(); \t \t\tThread t = new Thread(r); \t\tt.start(); \t} }   In this class we have overridden the run() method, in the run() method we wanted to print the string 5 times.   Then we create an instance of FooRunnable and pass this instance to the Thread instance to create a thread.         Starting and Running Multiple Threads  Enough playing around here; let’s actually get multiple threads going (more than two, that is). We already had two threads, because the main() method starts in a thread of its own, and then t.start() started a second thread. Now we’ll do more. The following code creates a single Runnable instance and three Thread instances. All three Thread instances get the same Runnable instance, and each thread is given a unique name. Finally, all three threads are started by invoking start() on the Thread instances.   class NameRunnable implements Runnable { \tpublic void run() { \t\tfor (int x = 1; x &lt;= 3; x++) { \t\tSystem.out.println(\"Run by \" \t\t\t\t+ Thread.currentThread().getName() \t\t\t\t+ \", x is \" + x); \t\t} \t} }   public class ManyNames { \tpublic static void main(String [] args) { \t\t// Make one Runnable \t\tNameRunnable nr = new NameRunnable(); \t\t \t\tThread one = new Thread(nr); \t\tThread two = new Thread(nr); \t\tThread three = new Thread(nr); \t\t \t\tone.setName(\"Fred\"); \t\ttwo.setName(\"Lucy\"); \t\tthree.setName(\"Ricky\"); \t\t \t\tone.start(); \t\ttwo.start(); \t\tthree.start(); \t} }   Let us now understand what we are doing now in the above code, let us take the NameRunnable Class first     NameRunnable implements java.lang.Runnable   Override the run() method.   In the run method we have used the Thread.currentThread() method to get the thread which is now executing in the JVM.   We used the getName() method to get the name of the running thread.   Now let us move our focus to implementing class – ManyNames Class     Instantiate  the NameRunnable Class   Create three different Thread object with same parameter i.e. instance of NameRunnable.   Use the setName() method of Thread class to assign a name to the threads.   Now start() method to start execution of the thread.         Run by Lucy, x is 1 Run by Ricky, x is 1 Run by Fred, x is 1 Run by Ricky, x is 2 Run by Lucy, x is 2 Run by Ricky, x is 3 Run by Fred, x is 2 Run by Lucy, x is 3 Run by Fred, x is 3  Note: Output will vary for each run   Thread Priorities  Threads always run with some priority, usually represented as a number between 1 and 10 (although in some cases the range is less than 10). Priorities are integer values from 1 (lowest priority given by the constant Thread. MIN_PRIORITY) to 10 (highest priority is given by the constant Thread.MAX_PRIORITY). The default priority is 5 (Thread.NORM_PRIORITY).   If a thread enters the runnable state (it means it is waiting for its turn to start executing), and it has a higher priority than any of the threads in the pool and a higher priority than the currently running thread, the lower-priority running thread usually will be bumped back to runnable and the highest-priority thread will be chosen to run. In other words, at any given time the currently running thread usually will not have a priority that is lower than any of the threads in the pool. In most cases, the running thread will be of equal or greater priority than the highest priority threads in the pool. This is as close to a guarantee about scheduling as you’ll get from the JVM specification, so you must never rely on thread priorities to guarantee the correct behavior of your program.   Setting the thread priority   A thread gets a default priority that is the priority of the thread of execution that creates it. For example, in the code the thread referenced by t will have the same priority as the main thread, since the main thread is executing the code that creates the MyThread instance.   You can also set a thread’s priority directly by calling the setPriority() method on a Thread instance as follows:   public class TestThreads { \tpublic static void main (String [] args) { \t\tFooRunnable r = new FooRunnable(); \t\tThread t = new Thread(r); \t\tt.setPriority(8); \t\tt.start(); \t} }         The sleep method ()   Suppose we want to create a stop watch which shows the digit after every one second, i.e. we want to stop the execution of the thread for some time. To do that, we will use the sleep method for the thread to stop executing.   The sleep() method is a static method of class Thread. You use it in your code to “slow a thread down” by forcing it to go into a sleep mode before coming back to runnable (where it still has to beg to be the currently running thread). When a thread sleeps, it drifts off somewhere and doesn’t return to runnable until it wakes up.   You do this by invoking the static Thread.sleep() method, giving it a time in milliseconds as follows:   try { \tThread.sleep(5*60*1000); // Sleep for 5 minutes }    Let’s modify our Fred, Lucy, Ricky code by using sleep() to try to force the threads to alternate rather than letting one thread dominate for any period of time.  class NameRunnable implements Runnable { \tpublic void run() { \t\tfor (int x = 1; x &lt; 4; x++) { \t\t\tSystem.out.println(\"Run by \" \t\t\t\t\t+ Thread.currentThread().getName() \t\t\t\t\t+ \", x is \" + x); \t\t\ttry { \t\t\t\tThread.sleep(1000); \t\t\t} catch (InterruptedException ex) { } \t\t} \t} }   Run by Fred, x is 1 Run by Ricky, x is 1 Run by Lucy, x is 1 Run by Fred, x is 2 Run by Lucy, x is 2 Run by Ricky, x is 2 Run by Ricky, x is 3 Run by Fred, x is 3 Run by Lucy, x is 3  The output may vary as we do not know how the threads are being scheduled during running.         Thread Synchronization - need and mechanism   Threads share the same memory space, that is, they can share resources. However, there are critical situations where it is desirable that only one thread at a time has access to a shared resource. For example, crediting and debiting a shared bank account concurrently amongst several users without proper discipline, will jeopardize the integrity of the account data. Java provides high-level concepts for synchronization in order to control access to shared resources.   To understand the problem let us take  a banking example.   The Banking Example  As an application designer for a major bank, we are assigned to the development team for the automated teller machine (ATM). As our first assignment, we are given the task of designing and implementing the routine that allows a user to withdraw cash from the ATM. A first and simple attempt at an algorithm may be as follows.      Check to make sure that the user has enough cash in the bank account to allow the withdrawal to occur. If the user does not, then go to step 4.   Subtract the amount withdrawn from the user’s account.   Dispense the cash from the teller machine to the user.   Print a receipt for the user.      A simple implementation is mentioned below with some assumption. We will be focusing on mainly the design for now.   public class ATM extends Bank { \tpublic void withdraw(float amount) { \t\tAccount a = getAccount(); \t\tif (a.deduct(amount)) \t\t\tdispense(amount);  //Assume that this method has already been declared in Bank Class \t\tprintReceipt(); //Assume that this method has already been declared in the Bank Class \t} } public class Account { \tprivate float total; \t \tpublic float getTotal() { \t\treturn total; \t}  \tpublic void setTotal(float total) { \t\tthis.total = total; \t} \t \tpublic boolean deduct(float t) { \t\tif (t &lt;= total) { \t\t\ttotal -= t; \t\t\treturn true; \t\t} \t\treturn false; \t} }   This design works fine under normal condition, i.e. if a person wants to withdraw money and he has the required amount in his account then then money will be debited from his account.   But consider a case; it is possible for two people to have access to the same account (e.g., a joint account).   One day, a husband and wife both decide to empty the same account, and purely by chance, they empty the account at the same time. We now have a race condition: if the two users withdraw from the bank at the same time, causing the methods to be called at the same time, it is possible for the two ATMs to confirm that the account has enough cash and dispense it to both parties. In effect, the two users are causing two threads to access the account database at the same time.      The husband thread begins to execute the deduct() method.   The husband thread confirms that the amount to deduct is less than or equal to the total in the account.   The wife thread begins to execute the deduct() method.   The wife thread confirms that the amount to deduct is less than or equal to the total in the account.   The wife thread performs the subtraction statement to deduct the amount, returns true, and the ATM dispenses her cash.   The husband thread performs the subtraction statement to deduct the amount, returns true, and the ATM dispenses his cash.   The Java specification provides certain mechanisms that deal specifically with this problem. The Java language provides the synchronized keyword; in comparison with other threading systems, this keyword allows the programmer access to a resource in a mutually exclusive way.         public class Account { \tprivate float total; \tpublic synchronized boolean deduct(float t) { \t\tif (t &lt;= total) { \t\t\ttotal -= t; \t\t\treturn true; \t\t} \t\treturn false; \t} }   By declaring the method as synchronized, if two users decide to withdraw cash from the ATM at the same time, the first user executes the deduct() method while the second user waits until the first user completes the deduct() method. Since only one user may execute the deduct() method at a time, the race condition is eliminated.   Synchronizing a Block of Code   Let us assume we are writing a method in which we need to synchronized a couple of lines of codes, so what should we do, shall we go ahead and synronize the whole method but in that case efficiency of aur program will be reduced, since large block of code will be executed before releasing the lock.   So rather than synchronizing the whole block we will synchronize only the block of code which we want to make a thread safe.   synchronized (Account) { \tif (t &lt;= total) { \t\ttotal -= t; \t\treturn true; \t} }  In this piece of code we have added synchronized key word followed by the (Account) and then our piece of code goes in the curly braces.   What we are doing here is we are trying to lock the Object Account so that no other thread can access it and then we are executing the thread safe piece of code.         Understanding Deadlocks      We say that a set of processes or threads is deadlocked when each thread is waiting for an event that only another process in the set can cause. Another way to illustrate a deadlock is to build a directed graph whose vertices are threads or processes and whose edges represent the “is-waiting-for” relation. If this graph contains a cycle, the system is deadlocked. Unless the system is designed to recover from deadlocks, a deadlock causes the program or system to hang.   public class Main { \tpublic static void main(String[] args) { \t    final Object resource1 = \"resource1\"; \t    final Object resource2 = \"resource2\"; \t    // t1 tries to lock resource1 then resource2 \t    Thread t1 = new Thread() { \t      public void run() { \t        // Lock resource 1 \t        synchronized (resource1) { \t          System.out.println(\"Thread 1: locked resource 1\");  \t          try { \t            Thread.sleep(50); \t          } catch (InterruptedException e) { \t          }  \t          synchronized (resource2) { \t            System.out.println(\"Thread 1: locked resource 2\"); \t          } \t        } \t      } \t    };  \t    // t2 tries to lock resource2 then resource1 \t    Thread t2 = new Thread() { \t      public void run() { \t        synchronized (resource2) { \t          System.out.println(\"Thread 2: locked resource 2\");  \t          try { \t            Thread.sleep(50); \t          } catch (InterruptedException e) { \t          }  \t          synchronized (resource1) { \t            System.out.println(\"Thread 2: locked resource 1\"); \t          } \t        } \t      } \t    };  \t    // If all goes as planned, deadlock will occur, \t    // and the program will never exit. \t    t1.start(); \t    t2.start(); \t  } }   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-6-threading/",
        "teaser": null
      },{
        "title": "Thread - wait, join & deadlocks",
        "excerpt":"The Java language includes three important methods that effectively allow one thread to signal to another. Without this facility, various constructs used in concurrent programming would be difficult and inefficient to implement, at least prior to Java 5.   The wait() method   Java includes an elegant inter process communication mechanism via the wait(), notify(), and notifyAll() methods. These methods are implemented as final methods in Object, so all classes have them. All three methods can be called only from within a synchronized method. Although conceptually advanced from a computer science perspective, the rules for using these methods are actually quite simple:      wait() tells the calling thread to give up the monitor and go to sleep until some other thread enters the same monitor and calls notify().   notify() wakes up the first thread that called wait() on the same object.   notifyAll() wakes up all the threads that called wait() on the same object. The highest priority thread will run first.   These methods are declared within Object, as shown here:     final void wait() throws InterruptedException   final void notify()   final void notifyAll()   Now let us understand this through an example:-   class MyResource { \t  boolean ready = false; \t  synchronized void waitFor() throws Exception {  //Line 1: declare method as synchronized \t    System.out.println(Thread.currentThread().getName()+ \" is entering waitFor().\"); \t      while (!ready) \t        wait(); //Line 2: calling the wait() method  \t    System.out.println(Thread.currentThread().getName() + \" resuming execution.\"); \t  } \t  synchronized void start() { \t    ready = true; \t    notify(); //Line 3: using notify method to inform the thread that object has been released \t  } \t}  \tclass MyThread implements Runnable { \t  MyResource myResource;  \t  MyThread(String name, MyResource so) { \t    myResource = so; \t    new Thread(this, name).start(); //Line 4: starts the thread, Calling run() of Line 5. \t  }  \t  public void run() { //Line 5: Declared the run method for the Class MyThread \t    \t    try { \t      myResource.waitFor(); \t    } catch (Exception e) { \t      e.printStackTrace(); \t    } \t  } \t}  \tpublic class Main { \t  public static void main(String args[]) throws Exception { \t    MyResource sObj = new MyResource(); //Line 6: creating an object of MyResource \t    new MyThread(\"MyThread\", sObj); //Starting the thread. \t    for (int i = 0; i &lt; 10; i++) {  \t      Thread.sleep(1000); //Making the thread sleep for 1 sec \t      System.out.print(\".\"); \t    } \t    sObj.start(); //finally calling start() method of MyResource to notify the thread. \t  } \t}   In the above code we have a MyResource class, it has two methods:-      waitFor() :- this method is a synchronized method which will wait until the ready is set to true.   start() :- when this method is called it will set the value for ready to true and will call the notify() method         Then we have MyThread Class which implements the runnable interface, in its constructor we have created an instance of Thread class and passed the MyThread Object using this keyword, and after that we have called its start method.   Now let us focus to the Main class, In the main class we have started the thread which in turn calls the waitFor() method of MyResource, went in the loop to sleep (for 1 sec), after 10 sec period of time, we call the start() method of MyResource to notify the waiting thread that the object has been released.   MyThread is entering waitFor(). ..........MyThread resuming execution.   The join() method   The non-static join() method of class Thread lets one thread “join onto the end” of another thread. If you have a thread B that can’t do its work until another thread A has completed its work, then you want thread B to “join” thread A. This means that thread B will not become runnable until A has finished (and entered the dead state).   Thread t = new Thread(); t.start(); t.join();   The preceding code takes the currently running thread (if this were in the main() method, then that would be the main thread) and joins it to the end of the thread referenced by t. This blocks the current thread from becoming runnable until after the thread referenced by t is no longer alive. In other words, the code t.join() means “Join me (the current thread) to the end of t, so that t must finish before I (the current thread) can run again.”   class MyThread implements Runnable {   int count;    MyThread() {     count = 0;   }    public void run() {     System.out.println(\"MyThread starting.\");     try {       do {         Thread.sleep(500);         System.out.println(\"In MyThread, count is \" + count);         count++;       } while (count &lt; 6);     } catch (InterruptedException exc) {       System.out.println(\"MyThread interrupted.\");     }     System.out.println(\"MyThread terminating.\");   } }  public class Main {   public static void main(String args[]) {     System.out.println(\"Main thread starting.\");     Thread thrd = new Thread(new MyThread());     thrd.start();     try {       thrd.join();     } catch (InterruptedException exc) {       System.out.println(\"Main thread interrupted.\");     }     System.out.println(\"Main thread ending.\");   } }   In this above code we are joining the thread thrd to the main thread, telling the main thread to wait for thrd thread to complete and then proceed.   Main thread starting. MyThread starting. In MyThread, count is 0 In MyThread, count is 1 In MyThread, count is 2 In MyThread, count is 3 In MyThread, count is 4 In MyThread, count is 5 MyThread terminating. Main thread ending.   Thread 1: locked resource 1 Thread 2: locked resource 2   In the above program, we have two resources, resource1 and resource2. We create two different threads, t1 and t2. In t1 thread we have locked the resource1 and wait for 50 milliseconds and then we are trying to lock resource2. Where as in t2 we have locked resource2 first and then we are trying to lock resource1. So now we have a problem t1 will try to capture resource which is already locked by t2, hence it will wait for resource2 to be released. Whereas t2 has locked the resource2 and t2 is waiting for the resource1 to be released. So none of the two threads can move forward hence we call that the two threads are in deadlock condition.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-7-threading-deadlocks/",
        "teaser": null
      },{
        "title": "Streams, Readers & Writers",
        "excerpt":"A stream represents a flow of data, or a channel of communication with (at least conceptually) a writer at one end and a reader at the other. When you are working with terminal input and output, reading or writing files, or communicating through sockets in Java, you are using a stream of one type or another.   It is just like two people talking on a phone, which has a speaker and a mike, and all that the person has to do, is to know, how to use the phone.      Streams in Java are one-way streets. The java.io input and output classes represent the ends of a simple stream. For bidirectional conversations, we use one of each type of stream.      InputStream and OutputStream are abstract classes that define the lowest-level interface for all byte streams. They contain methods for reading or writing an unstructured flow of byte-level data. Because these classes are abstract, you can’t create a generic input or output stream. Java implements subclasses of these for activities like reading from and writing to files and communicating with sockets. Because all byte streams inherit the structure of InputStream or OutputStream, the various kinds of byte streams can be used interchangeably. A method specifying an InputStream as an argument can, of course, accept any subclass of InputStream. Specialized types of streams can also be layered to provide features, such as buffering, filtering, or handling larger data types. In Java 1.1, new classes based around Reader and Writer were added to the java.io package. Reader and Writer are very much like InputStream and OutputStream, except that they deal with characters instead of bytes. As true character streams, these classes correctly handle Unicode characters, which was not always the case with the byte streams. However, some sort of bridge is needed between these character streams and the byte streams of physical devices like disks and networks. InputStreamReader and OutputStreamWriter are special classes that use an encoding scheme to translate between character and byte streams.      So if you want to read a file which contains the text data, you should use character stream but if you have some binary file for which you are more focused on the integrity of the file than the speed, you should use a byte stream.   InputStream  The class java.io.InputStream is the base class for all Java IO input streams. If you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it’s subclasses (e.g. FileInputStream).   You typically read data from an InputStream by calling the read() method. The read() method returns a int containing the byte value of the byte read. If there are no more data to be read, the read() method typically returns -1.   Methods  available()\t close()\t\t\t mark(int readlimit)\t\t markSupported() read()\t\t read(byte[] b)\t\t read(byte[] b, int off, int len) reset()\t\t skip(long n)   import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream;   public class Main { \tpublic static void main(String[] args) { \t\ttry { \t\t\tInputStream input = new FileInputStream(\"c:\\\\data\\\\input-file.txt\");  \t\t\tint data = input.read();  \t\t\twhile(data != -1){ \t\t\t  data = input.read();   } \t\t} catch (FileNotFoundException e) { \t\t\te.printStackTrace(); \t\t} catch (IOException e) { \t\t\te.printStackTrace(); \t\t} \t} }   In the above program we used a reference of InputStream which is referencing to object of FileInputStream ( sub class of InputStream) to read from the file (located at c:\\data\\input-file.txt ). We used the read method to read the file.         OutputStream   The class java.io.OutputStream is the base class of all Java IO output streams. If you are writing a component that needs to write output to a stream, try to make sure that component depends on an OutputStream and not one of its subclasses.   Methods  close()\t\t\t flush()\t\t\t write(byte[] b)\t\t write(byte[] b, int off, int len) write(int b)   Here is a simple example pushing some data out to a file:   import java.io.FileOutputStream; import java.io.OutputStream;  public class Main { \tpublic static void main(String[] args) { \t\ttry { \t\t\tOutputStream output = new FileOutputStream(\"c:\\\\data\\\\output-file.txt\"); \t\t\toutput.write(\"Hello World\".getBytes()); \t\t\toutput.close(); \t\t} catch (Exception e) { \t\t\t// TODO Auto-generated catch block \t\t\te.printStackTrace(); \t\t}  \t} }   In the above program we used reference of OutputStream to point to an object of FileOutputStream which is responsible for writing the data in a file.   Reader  The Reader is the baseclass of all Reader’s in the Java IO API. Subclasses include a BufferedReader, PushbackReader etc.   Methods  close()\t\t\t mark(int readAheadLimit)\t\t markSupported()\tread() read(char[] cbuf)\t read(char[] cbuf, int off, int len)\tready() reset()   Here is a simple example:  import java.io.File; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.io.Reader;  public class Main { \tpublic static void main(String[] args) { \t\t try { \t\t\tReader reader = new FileReader(new File(\"c:\\\\data\\\\input-file.txt\"));  \t\t\t    int data = reader.read(); \t\t\t    while(data != -1){ \t\t\t        char dataChar = (char) data; \t\t\t        data = reader.read(); \t\t\t    } \t\t} catch (FileNotFoundException e) { \t\t\te.printStackTrace(); \t\t} catch (IOException e) { \t\t\te.printStackTrace(); \t\t} \t} }   Notice, that while an InputStream returns one byte at a time, meaning a value between -128 and 127, the Reader returns a char at a time, meaning a value between 0 and 65535. This does not necessarily mean that the Reader reads two bytes at a time from the source it is connected to. It may read one or more bytes at a time, depending on the encoding of the text being read.         Writer   The Writer class is the baseclass of all Writer’s in the Java IO API. Subclasses include BufferedWriter and PrintWriter among others.   Methods   close()\t\t flush()\t\t\t write(char[] cbuf)\t\t write(char[] cbuf, int off, int len) write(int c)\t write(String str)\t\t write(String str, int off, int len)   Here is a simple example:   import java.io.FileWriter; import java.io.IOException; import java.io.Writer;  public class Main { \tpublic static void main(String[] args) { \t\ttry { \t\t\tWriter writer = new FileWriter(\"c:\\\\data\\\\file-output.txt\");  \t\t\twriter.write(\"Hello World Writer\"); \t\t\twriter.close(); \t\t} catch (IOException e) { \t\t\te.printStackTrace(); \t\t}  \t} }   The processing is similar to the Reader class except it reads the data in character format.   ","categories": ["java"],
        "tags": ["I/O","InputStream","OutputStream"],
        "url": "https://kuros.in/java/2019/01/java-1-stream-readers/",
        "teaser": null
      },{
        "title": "Console IO",
        "excerpt":"Java was designed for graphical user interfaces (GUI) and industrial strength file and Internet I/O. No attempt was made to have simple input and output facilities like C++’s cin and cout. This isn’t a problem for big programs, but it makes small student examples large and awkward, requiring knowledge of conversion and exceptions from the beginning. In practice console input is rarely used, but programmers often use System.out.println for output during the debugging phase.   There are three predefined I/O streams that use the console. These are equivalent to Unix standard input, error, and output streams.     System.out - standard output stream   System.in - standard input stream   System.err - standard error   Now let us concentrate on the major parts i.e. input and output of data from the console.   The Console  A more advanced alternative to the Standard Streams is the Console. This is a single, predefined object of type Console that has most of the features provided by the Standard Streams, and others besides. The Console is particularly useful for secure password entry. The Console object also provides input and output streams that are true character streams, through its reader and writer methods.   Before a program can use the Console, it must attempt to retrieve the Console object by invoking System.console(). If the Console object is available, this method returns it. If System.console returns NULL, then Console operations are not permitted, either because the OS doesn’t support them or because the program was launched in a non-interactive environment.   The Console object supports secure password entry through its readPassword method. This method helps secure password entry in two ways. First, it suppresses echoing, so the password is not visible on the user’s screen. Second, readPassword returns a character array, not a String, so the password can be overwritten, removing it from memory as soon as it is no longer needed.   import java.io.Console; import java.util.Arrays; import java.io.IOException;  public class Password {          public static void main (String args[]) throws IOException {          Console c = System.console();         if (c == null) {             System.err.println(\"No console.\");             System.exit(1);         }          String login = c.readLine(\"Enter your login: \");         char [] oldPassword = c.readPassword(\"Enter your old password: \");          if (verify(login, oldPassword)) {             boolean noMatch;             do {                 char [] newPassword1 =                     c.readPassword(\"Enter your new password: \");                 char [] newPassword2 =                     c.readPassword(\"Enter new password again: \");                 noMatch = ! Arrays.equals(newPassword1, newPassword2);                 if (noMatch) {                     c.format(\"Passwords don't match. Try again.%n\");                 } else {                     change(login, newPassword1);                     c.format(\"Password for %s changed.%n\", login);                 }                 Arrays.fill(newPassword1, ' ');                 Arrays.fill(newPassword2, ' ');             } while (noMatch);         }          Arrays.fill(oldPassword, ' ');      }      //Dummy verify method.      static boolean verify(String login, char[] password) {         return true;     }      //Dummy change method.     static void change(String login, char[] password) {} }   Let us understand the what does the above program tries to do :-     Attempt to retrieve the Console object. If the object is not available, abort.   Invoke Console.readLine to prompt for and read the user’s login name.   Invoke Console.readPassword to prompt for and read the user’s existing password.   Invoke verify to confirm that the user is authorized to change the password. (In this example, verify is a dummy method that always returns true.)   Repeat the following steps until the user enters the same password twice:            Invoke Console.readPassword twice to prompt for and read a new password.       If the user entered the same password both times, invoke change to change it. (Again, change is a dummy method.)       Overwrite both passwords with blanks.           Overwrite the old password with blanks.   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-console-io/",
        "teaser": null
      },{
        "title": "File Handling",
        "excerpt":"To write anything to a file first of all we need a file name we want to use. The file name is a simple string like like this:   String fileName = \"test.txt\";  If you want to write in a file which is located elsewhere you need to define the complete file name and path in your fileName variable:  String fileName = \"c:\\\\filedemo\\\\test.txt\";   However if you define a path in your file name then you have to take care the path separator. On windows system the ‘' is used and you need to backslash it so you need to write ‘\\’, in Unix, Linux systems the separator is a simple slash ‘/’.   To make your code OS independent you can get the separator character as follows:   String separator = System.getProperty(\"file.separator\");   Open a file  To open a file for writing use the FileWriter class and create an instance from it. The file name is passed in the constructor like this:   FileWriter writer = new FileWriter(fileName);   This code opens the file in overwrite mode. If you want to append to the file then you need to use an other constructor like this:   FileWriter writer = new FileWriter(fileName,true);   Besides this the constructor can throw an IOException so we put all of the code inside a try-catch block.         Write to file  At this point we have a writer object and we can send real content to the file. You can do this using the write() method, which has more variant but the most commonly used requires a string as input parameter.   Calling the write() method doesn’t mean that it immediately writes the data into the file. The output is maybe cached so if you want to send your data immediately to the file you need to call the flush() method.   As last step you should close the file with the close() method and you are done.   \tpublic void writeFile() { \t \t\tString fileName = \"c:\\\\test.txt\"; \t \t\ttry { \t \t\t\tFileWriter writer = new FileWriter(fileName,true); \t \t\t\twriter.write(\"Test text.\"); \t \t\t\twriter.close(); \t \t\t} catch (IOException e) { \t \t\t\te.printStackTrace(); \t \t\t} \t \t}   However, in a real world situation, the FileWriter is usually not used directly. Instead of FileWriter the BufferedWriter or from Java 1.5 the PrintWriter are used. These writer objects, gives you more flexibility to handle your IO. Here is a simple BufferedWriter example:         public void writeFile() { \t    \t\tString fileName = \"c:\\\\test.txt\";  \t\ttry { \t\t\tBufferedWriter writer = new BufferedWriter(new FileWriter(fileName,true)); \t\t\t \t\t\twriter.write(\"Test text.\"); \t\t\twriter.newLine(); \t\t\twriter.write(\"Line2\"); \t\t\twriter.close(); \t  }catch (IOException e) { \t\t  e.printStackTrace(); \t  \t  }  \t}   The Buffered writer helps us to write a chunk of data at time, as the name suggest first it buffers the data and then writes it into a file.   Reading from the file  Now it’s time to read the file content back. Not surprisingly reading from a file is very similar to writing. We only need to use *Reader objects instead of *Writer objects. It means that you can use FileReader or BufferedReader. As a simple FileReader can handle only a single character or a character array it is more convenient to use the BufferedReader which can read a complete line from a file as a string. So using a BufferedReader we can read a text file line by line with the readln() method as you can see in this example:    \tpublic String readFile() { \t    String fileName = \"c:\\\\test.txt\"; \t    String LS = System.getProperty(\"line.separator\"); \t    StringBuffer fileContent = new StringBuffer(); \t  \t    try { \t        FileReader fr = new FileReader(fileName); \t        BufferedReader reader = new BufferedReader(new FileReader(fileName)); \t  \t        String line; \t        while ((line = reader.readLine()) != null) { \t            fileContent.append(line).append(LS); \t        } \t        reader.close(); \t        fr.close(); \t    } catch (IOException e) { \t        e.printStackTrace(); \t    } \t  \t    return fileContent.toString(); \t}  Don’t forget to close the streams after using it; the data might get corrupted if the closing action is not taken care of.         Now since we have seen how to write and read from the file, let us compile our code as a single program which has a capability to first write the data and then read from the file and show the output on the console.   import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException;  public class Main {  \tpublic static void main(String[] args) { \t \t\tMain fd = new Main(); \t\tfd.writeFile(); \t\tString txt = fd.readFile(); \t\tSystem.out.println(txt); \t}  \tpublic void writeFile() { \t \t\tString fileName = \"c:\\\\test.txt\"; \t\ttry { \t\t\tBufferedWriter writer = new BufferedWriter(new FileWriter(fileName,true)); \t\t\twriter.write(\"Test text.\"); \t\t\twriter.newLine(); \t\t\twriter.write(\"Line2\"); \t\t\twriter.close(); \t\t \t\t} catch (IOException e) {\t\t \t\t\te.printStackTrace();\t\t \t\t}\t \t}  \tpublic String readFile() { \t \t\tString fileName = \"c:\\\\test.txt\"; \t\tString LS = System.getProperty(\"line.separator\"); \t\tStringBuffer fileContent = new StringBuffer(); \t\t \t\ttry { \t\t\tFileReader fr = new FileReader(fileName); \t\t\tBufferedReader reader = new BufferedReader(new FileReader(fileName)); \t\t\tString line; \t\t\twhile ((line = reader.readLine()) != null) { \t\t\t\tfileContent.append(line).append(LS); \t\t\t} \t\t\t \t\t} catch (IOException e) {\t\t \t\t\te.printStackTrace();\t\t \t\t}  \t\treturn fileContent.toString();\t \t} }  Test text. Line 2   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/java-file-handling/",
        "teaser": null
      },{
        "title": "File Object",
        "excerpt":"Objects of type File are used to represent the actual files (but not the data in the files) or directories that exist on a computer’s physical disk. First, let’s create a new file and write a few lines of data to it:   import java.io.*;  class Writer1 { \tpublic static void main(String [] args) { \t\tFile file = new File(\"fileWrite1.txt\"); // There's no \t\t\t\t\t\t\t\t\t\t\t\t//file yet! \t} }   If you compile and run this program, when you look at the contents of your current directory, you’ll discover absolutely no indication of a file called fileWrite1.txt. When you make a new instance of the class File, you’re not yet making an actual file, you’re just creating a filename.   Once you have a File object, there are several ways to make an actual file.    import java.io.*;  class Writer1 { \tpublic static void main(String [] args) { \t\ttry { // warning: exceptions possible \t\t\tboolean newFile = false; \t\t\tFile file = new File // it's only an object \t\t\t(\"fileWrite1.txt\"); \t\t\tSystem.out.println(file.exists()); // look for a real file \t\t\tnewFile = file.createNewFile(); // maybe create a file! \t\t\tSystem.out.println(newFile); // already there? \t\t\tSystem.out.println(file.exists()); // look again \t\t} catch(IOException e) { } \t} }   We used exists() method to check whether the file is already present of the disk or not. We use createNewFile() method to create an actual file on the disk.   For the first run, the output will be:-  false true true  When you run the same program for the second time the output will be:-   true false true   i.e. for the second time, since the file is already existing, the createNewFile() method returns null, hence not creating a new file.   Main methods that are used for the file class are:                  Method       Description                       createNewFile()       Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist.                 delete()       Deletes the file or directory denoted by this abstract pathname.                 exists()       Tests whether the file or directory denoted by this abstract pathname exists.                 getAbsolutePath()       Returns the absolute pathname string of this abstract pathname.                 isDirectory()       Tests whether the file denoted by this abstract pathname is a directory.                 isFile()       Tests whether the file denoted by this abstract pathname is a normal file.                 mkdir()       Creates the directory named by this abstract pathname.                 renameTo (File dest)       Renames the file denoted by this abstract pathname.                 Creating directories   import java.io.File;  public class CreateFile { \tpublic static void main(String[] args) throws Exception { \t\tFile dir = new File(\"MyDir\");  \t\tif (!dir.exists()){ \t\t\tdir.mkdir(); \t\t\tSystem.out.println(\"Directory created\"); \t\t} \t\telse \t\t\tSystem.out.println(\"directory already exists\");  \t\tif (dir.exists()) { \t\t\t \t\t\tFile file = new File(dir, \"Myfile\");  \t\t\tif (!file.exists()) { \t\t\t\tboolean result = file.createNewFile();  \t\t\t\tif (result) \t\t\t\t\tSystem.out.println(\"File Created\"); \t\t\t\telse \t\t\t\t\tSystem.out.println(\"File not created\"); \t\t\t} else { \t\t\t\tSystem.out.println(\"File already exists\"); \t\t\t} \t\t} else { \t\t\tSystem.out.println(\"Cannot create directory\"); \t\t} \t} }   Directory created File Created   Renaming files   Now we will look how to rename the file, we will first check if the file exists, then we will rename it.   import java.io.File;  public class RenameFile { \tpublic static void main(String[] args) throws Exception { \t\tFile file = new File(\"MyDir\", \"Myfile\"); \t\t \t\tif (file.exists()){ \t\t\tboolean status = file.renameTo(new File(\"MyDir\", \"RenamedFile.txt\")); \t\t\tif(status) \t\t\t\tSystem.out.println(\"File Renamed\"); \t\t\telse \t\t\t\tSystem.out.println(\"File Not Renamed\"); \t\t}else{ \t\t\tSystem.out.printf(\"File '%s' not found\", file.getName()); \t\t} \t} }         File Renamed   Deleting file  We can also delete the file using the File Object.   import java.io.File;  public class Entry { \tpublic static void main(String[] args) throws Exception { \t\tFile file = new File(\"MyDir\", \"Myfile\"); \t\t \t\tif (file.exists()){ \t\t\tboolean status = file.delete(); \t\t\tif(status) \t\t\t\tSystem.out.println(\"File Deleted\"); \t\t\telse \t\t\t\tSystem.out.println(\"File Not Deleted\"); \t\t}else{ \t\t\tSystem.out.printf(\"File '%s' not found\", file.getName()); \t\t} \t} }         File Deleted   RandomAccessFile  Instances of RandomAccessFile class support both reading and writing to access file randomly. A random access file behaves like a large array of bytes stored in the file system. There is a kind of cursor, or index into the implied array, called the file pointer; input operations read bytes starting at the file pointer and advance the file pointer past the bytes read. If the random access file is created in read/write mode, then output operations are also available; output operations write bytes starting at the file pointer and advance the file pointer past the bytes written.   Let us look at the main methods provided by this class.                  Methods       Description                       read()       Reads a byte of data from this file.                 read(byte[] b)       Reads up to b.length bytes of data from this file into an array of bytes.                 read(byte[] b, int off, int len)       Reads up to len bytes of data from this file into an array of bytes.                 write(byte[] b)       Writes b.length bytes from the specified byte array to this file, starting at the current file pointer.                 write(byte[] b, int off, int len)       Writes len bytes from the specified byte array starting at offset off to this file.                 seek(long pos)       Sets the file-pointer offset, measured from the beginning of this file, at which the next read or write occurs.                 skipBytes(int n)       Attempts to skip over n bytes of input discarding the skipped bytes.                 getFilePointer()       Returns the current offset in this file.           Now let us go and implement these methods in program:-   import java.io.FileNotFoundException; import java.io.IOException;  import java.io.RandomAccessFile;   public class Main {  \t/** * Example method for using the RandomAccessFile class */  \tpublic void testRandomAccessFile(String filename) {  \t\tRandomAccessFile randomAccessFile = null; \t\ttry { \t\t\t//Declare variables that we're going to write  \t\t\tString line1 = \"First line\\n\";  \t\t\tString line2 = \"Second line\\n\";  \t\t\t \t\t\t//Create RandomAccessFile instance with read / write permissions  \t\t\trandomAccessFile = new RandomAccessFile(filename, \"rw\");  \t\t\t \t\t\t//Write two lines to the file  \t\t\trandomAccessFile.writeBytes(line1);  \t\t\trandomAccessFile.writeBytes(line2);  \t\t\t \t\t\t//Place the file pointer at the end of the first line  \t\t\trandomAccessFile.seek(line1.length());  \t\t\t//Declare a buffer with the same length as the second line  \t\t\t \t\t\tlong position = randomAccessFile.getFilePointer(); \t\t\tSystem.out.println(\"Now the pointer is at location \" + position); \t\t\t \t\t\tbyte[] buffer = new byte[line2.length()]; \t\t\t \t\t\t//Read data from the file  \t\t\trandomAccessFile.read(buffer);  \t\t\t \t\t\t//Print out the buffer contents  \t\t\tSystem.out.println(new String(buffer));  \t\t\t \t\t\tposition = randomAccessFile.getFilePointer(); \t\t\tSystem.out.println(\"Now the pointer is at location \" + position); \t\t\t\t \t\t\t}catch (FileNotFoundException ex) { \t\t\t\tex.printStackTrace();  \t\t\t} catch (IOException ex) { \t\t\t\tex.printStackTrace();  \t\t\t} finally {  \t\t\t\ttry {  \t\t\t\t\tif (randomAccessFile != null) randomAccessFile.close(); \t\t\t\t} catch (IOException ex) { ex.printStackTrace();  \t\t\t\t} \t\t\t} \t}\t \t\t\t\t\t\t\t/** * @param args the command line arguments */  \tpublic static void main(String[] args) { \t\tnew Main().testRandomAccessFile(\"myFile.txt\");   \t} }   In this program we first use writeBytes() method to write the data in the file then use seek method to traverse the file, used the getFilePointer()  method to get the current location. Finally reading a chunk of data using the read() method   Now the pointer is at location 11 Second line  Now the pointer is at location 23   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/file-object/",
        "teaser": null
      },{
        "title": "Java Formatters",
        "excerpt":"Like all byte and character stream objects, instances of PrintStream and PrintWriter implement a standard set of write methods for simple byte and character output. In addition, both PrintStream and PrintWriter implement the same set of methods for converting internal data into formatted output. Two levels of formatting are provided:      print and println format individual values in a standard way.   format formats almost any number of values based on a format string, with many options for precise formatting.   The print and println Methods  The methods print() and println() are almost the same, with a slight difference, i.e. when we use println() method a new line character is added to the String at the end which means your cursor will move to the next line.   public class Main {     public static void main(String[] args) {         int i = 2;         double r = Math.sqrt(i);                  System.out.print(\"The square root of \");         System.out.print(i);         System.out.print(\" is \");         System.out.print(r);         System.out.println(\".\");          i = 5;         r = Math.sqrt(i);         System.out.println(\"The square root of \" + i + \" is \" + r + \".\");     } }         The square root of 2 is 1.4142135623730951. The square root of 5 is 2.23606797749979.   The format Method  The format method formats multiple arguments based on a format string. The format string consists of static text embedded with format specifiers; except for the format specifiers, the format string is output unchanged. The formatting is same as using printf() method in C to print the values.   import java.util.Formatter;  public class Main { \tpublic static void main(String args[]) { \t    Formatter fmt = new Formatter();  \t    // Format 4 decimal places. \t    fmt.format(\"%.4f\", 123.1234567); \t    System.out.println(fmt);  \t    // Format to 2 decimal places in a 16 character field. \t    fmt = new Formatter(); \t    fmt.format(\"%16.2e\", 123.1234567); \t    System.out.println(fmt);  \t    // Display at most 15 characters in a string. \t    fmt = new Formatter(); \t    fmt.format(\"%.15s\", \"Formatting with Java is now easy.\"); \t    System.out.println(fmt); \t  } }         123.1235         1.23e+02 Formatting with  The supported conversion types are listed below, along with their meanings, and the corresponding arguments expected in the argument vector:   Date Formatting  A pattern of special characters is used to specify the format of the date. We use the object of Format class to specify these format. We use SimpleDateFormat class which inherit Format class to define our pattern   This example demonstrates some of the characters   import java.text.Format; import java.text.SimpleDateFormat; import java.util.Date;  public class Entry { \tpublic static void main(String[] args) throws Exception {  \t\tFormat formatter;  \t\t// Get today's date \t\tDate date = new Date();  \t\tformatter = new SimpleDateFormat(\"MM/dd/yy\"); \t\tString s = formatter.format(date); \t\tSystem.out.println(s); \t\t// 01/09/02  \t\tformatter = new SimpleDateFormat(\"dd-MMM-yy\"); \t\ts = formatter.format(date); \t\tSystem.out.println(s); \t\t// 29-Jan-02  \t\t// Examples with date and time; see also \t\t// Formatting the Time Using a Custom Format \t\tformatter = new SimpleDateFormat(\"yyyy.MM.dd.HH.mm.ss\"); \t\ts = formatter.format(date); \t\tSystem.out.println(s);  \t\t// 2002.01.29.08.36.33 \t\tformatter = new SimpleDateFormat(\"E, dd MMM yyyy HH:mm:ss Z\"); \t\ts = formatter.format(date); \t\tSystem.out.println(s); \t\t// Tue, 09 Jan 2002 22:14:02 -0500 \t} }         01/29/19 29-Jan-19 2019.01.29.15.18.54 Tue, 29 Jan 2019 15:18:54 +0530   Calendar Formatting   When we are working with we can use an object of Calendar class (an abstract base) for converting between a Date object and a set of integer fields such as YEAR, MONTH, DAY, HOUR, and so on.   Subclasses of Calendar interpret a Date according to the rules of a specific calendar system. The platform provides one concrete subclass of Calendar: GregorianCalendar.   import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar;  public class Entry { \tpublic static void main(String[] args) throws Exception {  \t\tCalendar calendar = new GregorianCalendar();  \t\t// Tell the calendar what date/time to format \t\tcalendar.setTime(new Date());  \t\t// print out most of the known fields \t\tSystem.out.println(\"ERA: \" + calendar.get(Calendar.ERA)); \t\tSystem.out.println(\"YEAR: \" + calendar.get(Calendar.YEAR)); \t\tSystem.out.println(\"MONTH: \" + calendar.get(Calendar.MONTH)); \t\tSystem.out.println(\"WEEK_OF_YEAR: \" \t\t\t\t+ calendar.get(Calendar.WEEK_OF_YEAR)); \t\tSystem.out.println(\"WEEK_OF_MONTH: \" \t\t\t\t+ calendar.get(Calendar.WEEK_OF_MONTH)); \t\tSystem.out.println(\"DATE: \" + calendar.get(Calendar.DATE)); \t\tSystem.out.println(\"DAY_OF_MONTH: \" \t\t\t\t+ calendar.get(Calendar.DAY_OF_MONTH)); \t\tSystem.out \t\t\t\t.println(\"DAY_OF_YEAR: \" + calendar.get(Calendar.DAY_OF_YEAR)); \t\tSystem.out \t\t\t\t.println(\"DAY_OF_WEEK: \" + calendar.get(Calendar.DAY_OF_WEEK)); \t\tSystem.out.println(\"DAY_OF_WEEK_IN_MONTH: \" \t\t\t\t+ calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); \t\tSystem.out.println(\"AM_PM: \" + calendar.get(Calendar.AM_PM)); \t\tSystem.out.println(\"HOUR: \" + calendar.get(Calendar.HOUR)); \t\tSystem.out \t\t\t\t.println(\"HOUR_OF_DAY: \" + calendar.get(Calendar.HOUR_OF_DAY)); \t\tSystem.out.println(\"MINUTE: \" + calendar.get(Calendar.MINUTE)); \t\tSystem.out.println(\"SECOND: \" + calendar.get(Calendar.SECOND)); \t\tSystem.out \t\t\t\t.println(\"MILLISECOND: \" + calendar.get(Calendar.MILLISECOND)); \t\tSystem.out.println(\"ZONE_OFFSET: \" \t\t\t\t+ (calendar.get(Calendar.ZONE_OFFSET) / (60 * 60 * 1000))); \t\tSystem.out.println(\"DST_OFFSET: \" \t\t\t\t+ (calendar.get(Calendar.DST_OFFSET) / (60 * 60 * 1000))); \t} }         ERA: 1 YEAR: 2019 MONTH: 0 WEEK_OF_YEAR: 5 WEEK_OF_MONTH: 5 DATE: 29 DAY_OF_MONTH: 29 DAY_OF_YEAR: 29 DAY_OF_WEEK: 3 DAY_OF_WEEK_IN_MONTH: 5 AM_PM: 1 HOUR: 3 HOUR_OF_DAY: 15 MINUTE: 20 SECOND: 38 MILLISECOND: 620 ZONE_OFFSET: 5 DST_OFFSET: 0   Working with Strings  String class has someimportant methods which are very useful when we are working with strings.   Spilt  The split method splits the string around matches of the given regular expression. The array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are in the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string.   public class Entry { \tpublic static void main(String[] args) throws Exception {  \t\tString string = \"This is 1 test, and 2 we will try\"; \t\tString[] array = string.split(\" \"); // Splitting using space \t\tfor (String s : array) \t\t\tSystem.out.println(s);  \t\tSystem.out.println(\"***************************\"); \t\tarray = string.split(\",\"); // Splitting using comma \t\tfor (String s : array) \t\t\tSystem.out.println(s);  \t\tSystem.out.println(\"********************\");  \t\tarray = string.split(\"[0-9]\"); // Splitting using any digit \t\tfor (String s : array) \t\t\tSystem.out.println(s);  \t\t \t\tSystem.out.println(\"***************************\"); \t\tarray = string.split(\"xyz\"); // Splitting using any digit \t\tfor (String s : array) \t\t\tSystem.out.println(s); \t} }         This is 1 test, and 2 we will try *************************** This is 1 test  and 2 we will try ******************** This is   test, and   we will try *************************** This is 1 test, and 2 we will try   String Tokenizer  StringTokenizer class provides the first step in this parsing process, often called the lexer (lexical analyzer) or scanner. StringTokenizer implements the Enumeration interface. Therefore, given an input string, you can enumerate the individual tokens contained in it using StringTokenizer.   To use StringTokenizer, you specify an input string and a string that contains delimiters. Delimiters are characters that separate tokens. Each character in the delimiters string is considered a valid delimiter—for example, “,;:” sets the delimiters to a comma, semicolon, and colon. The default set of delimiters consists of the whitespace characters: space, tab, newline, and carriage return.   The StringTokenizer constructors are shown here:   StringTokenizer(String str)  StringTokenizer(String str, String delimiters)  StringTokenizer(String str, String delimiters, boolean delimAsToken)   In all versions, str is the string that will be tokenized. In the first version, the default delimiters are used. In the second and third versions, delimiters is a string that specifies the delimiters. In the third version, if delimAsToken is true, then the delimiters are also returned as tokens when the string is parsed. Otherwise, the delimiters are not returned.   import java.util.StringTokenizer;  public class Entry { \tpublic static void main(String[] args) throws Exception {  \t\tString Demo = \"This is a string that we want to tokenize\";  \t\tStringTokenizer Tok = new StringTokenizer(Demo); \t\tint n = 0;  \t\twhile (Tok.hasMoreElements()) \t\t\tSystem.out.println(\"\" + ++n + \": \" + Tok.nextElement()); \t}  }  1: This 2: is 3: a 4: string 5: that 6: we 7: want 8: to 9: tokenize   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/formatting/",
        "teaser": null
      },{
        "title": "Java Serialization & Deserialization",
        "excerpt":"Serialization lets you simply say “save this object state to the persistent store” you’d have to use one of the I/O classes to write out the state of the instance variables of all the objects you want to save.   After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.   Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized on an entirely different platform.   To demonstrate how serialization works in Java, I am going to use the Employee class that we discussed early on in the book. Suppose that we have the following Employee class, which implements the Serializable interface:   public class Employee implements java.io.Serializable {    public String name;    public String address;    public transient int SSN;    public int number;    public void mailCheck()    {       System.out.println(\"Mailing a check to \" + name                            + \" \" + address);    } }   Notice that for a class to be serialized successfully, two conditions must be met:     The class must implement the java.io.Serializable interface.   All of the fields in the class must be serializable. If a field is not serializable, it must be marked transient.   Serializing an Object:  The ObjectOutputStream class is used to serialize an Object. The following SerializeDemo program instantiates an Employee object and serializes it to a file.   import java.io.*;  public class SerializeDemo {    public static void main(String [] args)    {       Employee e = new Employee();       e.name = \"Reyan Ali\";       e.address = \"Phokka Kuan, Ambehta Peer\";       e.SSN = 11122333;       e.number = 101;       try       {          FileOutputStream fileOut =          new FileOutputStream(\"employee.ser\");          ObjectOutputStream out =                             new ObjectOutputStream(fileOut);          out.writeObject(e);          out.close();           fileOut.close();       }catch(IOException i)       {           i.printStackTrace();       }    } }   In the above program we have used classes ObjectInputStream and ObjectOutputStream which are high-level streams that contain the methods for serializing and deserializing an object.   The ObjectOutputStream class contains many write methods for writing various data types, but one method in particular stands out:     public final void writeObject(Object x) throws IOException   The above method serializes an Object and sends it to the output stream. Other than this, we have     public void defaultReadObject() throws IOException,  ClassNotFoundException   This method read the non-static and non-transient fields of the current class from this stream. This may only be called from the readObject method of the class being deserialized. It will throw the NotActiveException if it is called otherwise.         When the program is done executing, a file named employee.ser is created. The program does not generate any output, but study the code and try to determine what the program is doing.   Note: When serializing an object to a file, the standard convention in Java is to give the file a .ser extension. This .ser file is created where we have specified the path, In this case since we have not given relative path, it will create the file at same location where we have executed the class.   Now let us see what happens if we do not implement the Serializable interface.   public class Employee { \tpublic String name; \tpublic String address; \tpublic transient int SSN; \tpublic int number;  \tpublic void mailCheck() { \t\tSystem.out.println(\"Mailing a check to \" + name + \" \" + address); \t} }   Since we have not implemented Serializable interface, the compiler gives an error as not seralizalbe.   java.io.NotSerializableException: Employee \tat java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) \tat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) \tat Employee.main(Employee.java:29)   Deserializing an Object:  The following DeserializeDemo program deserializes the Employee object created in the SerializeDemo program. Study the program and try to determine its output:   import java.io.*; public class DeserializeDemo {    public static void main(String [] args)    {       Employee e = null;       try       {          FileInputStream fileIn =                        new FileInputStream(\"employee.ser\");          ObjectInputStream in = new ObjectInputStream(fileIn);          e = (Employee) in.readObject();          in.close();          fileIn.close();      }catch(IOException i)      {          i.printStackTrace();          return;      }catch(ClassNotFoundException c)      {          System.out.println(\".Employee class not found.\");          c.printStackTrace();          return;      }      System.out.println(\"Deserialized Employee...\");      System.out.println(\"Name: \" + e.name);      System.out.println(\"Address: \" + e.address);      System.out.println(\"SSN: \" + e.SSN);      System.out.println(\"Number: \" + e.number);  } }   Similarly, the ObjectInputStream class contains the following method for deserializing an object:     public final Object readObject() throws IOException, ClassNotFoundException   This method reads the object from the serialized file. Other than this we have another method     public void defaultWriteObject() throws IOException   Writes the non-static and non-transient fields of the current class to this stream. This may only be called from the writeObject method of the class being serialized. It will throw the NotActiveException if it is called otherwise.         Deserialized Employee... Name: Reyan Ali Address: Phokka Kuan, Ambehta Peer SSN: 0 Number: 101  Here are following important points to be noted:     The try/catch block tries to catch a ClassNotFoundException, which is declared by the readObject() method. For a JVM to be able to deserialize an object, it must be able to find the bytecode for the class. If the JVM can’t find a class during the deserialization of an object, it throws a ClassNotFoundException.   Notice that the return value of readObject() is cast to an Employee reference.   The value of the SSN field was 11122333 when the object was serialized, but because the field is transient, this value was not sent to the output stream. The SSN field of the deserialized Employee object is 0 which is the default value.   import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.ArrayList; import java.util.List; import java.util.Random;  abstract class Shape implements Serializable {   public static final int RED = 1, BLUE = 2, GREEN = 3;    private int x, y, size;    private static Random r = new Random();    private static int counter = 0;    public abstract void setColor(int newColor);    public abstract int getColor();    public Shape(int xVal, int yVal, int dim) {     x = xVal;     y = yVal;     size = dim;   }    public String toString() {     return getClass() + \"color[\" + getColor() + \"] xPos[\" + x + \"] yPos[\" + y + \"] dim[\" + size         + \"]\\n\";   }  }  class Circle extends Shape {   private static int color = RED;    public Circle(int xVal, int yVal, int dim) {     super(xVal, yVal, dim);   }    public void setColor(int newColor) {     color = newColor;   }    public int getColor() {     return color;   } }  class Square extends Shape {   private static int color;    public Square(int xVal, int yVal, int dim) {     super(xVal, yVal, dim);     color = RED;   }    public void setColor(int newColor) {     color = newColor;   }    public int getColor() {     return color;   } }  class Line extends Shape {   private static int color = RED;    public static void serializeStaticState(ObjectOutputStream os) throws IOException {     os.writeInt(color);   }    public static void deserializeStaticState(ObjectInputStream os) throws IOException {     color = os.readInt();   }    public Line(int xVal, int yVal, int dim) {     super(xVal, yVal, dim);   }    public void setColor(int newColor) {     color = newColor;   }    public int getColor() {     return color;   } }  public class Entry {   public static void main(String[] args) throws Exception {     List shapeTypes, shapes;     if (args.length == 0) {       shapeTypes = new ArrayList();       shapes = new ArrayList();        shapeTypes.add(Circle.class);       shapeTypes.add(Square.class);       shapeTypes.add(Line.class);        shapes.add(new Square(4, 3, 200));       shapes.add(new Circle(1, 2, 100));       shapes.add(new Line(1, 2, 100));        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"CADState.out\"));       out.writeObject(shapeTypes);       Line.serializeStaticState(out);       out.writeObject(shapes);     } else {       ObjectInputStream in = new ObjectInputStream(new FileInputStream(args[0]));       shapeTypes = (List) in.readObject();       Line.deserializeStaticState(in);       shapes = (List) in.readObject();     }      System.out.println(shapes);   }  }         [class Squarecolor[1] xPos[4] yPos[3] dim[200] , class Circlecolor[1] xPos[1] yPos[2] dim[100] , class Linecolor[1] xPos[1] yPos[2] dim[100] ]   Conclusion     Serialization lets you save, ship, and restore everything you need to know about a live object. And when your object points to other objects, they get saved too.   The java.io.ObjectOutputStream and java.io.ObjectInputStream classes are used to serial and deserialize objects. Typically you wrap them around instances of FileOutputStream and FileInputStream, respectively.   The key method you invoke to serialize an object is writeObject(), and to deserialize an object invoke readMethod().   In order to serialize an object, it must implement the Serializable interface. Mark instance variables transient if you don’t want their state to be part of the serialization process.  ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/serialization/",
        "teaser": null
      },{
        "title": "Configuring Preconditions",
        "excerpt":"You have two independent tables having no relationship between them, but you still want to create them in specific orders. To enforce order during the creation you can add preconditions to jpa context factory.   Let us say you want Account entity to be created before Person entity, although Person doesn’t have a direct relationship with Account   final JPAContextFactory jpaContextFactory      = JPAContextFactory.newInstance(Database.MY_SQL, persistenceService.getEntityManager());  jpaContextFactory.withPreconditions(Before.of(Person.class).create(Account.class));   Note: This is a system level configuration, Random-JPA would try to adjust order but skips if it’s in direct conflict with foreign key relationship  ","categories": ["random-jpa"],
        "tags": [],
        "url": "https://kuros.in/random-jpa/2019/01/preconditions/",
        "teaser": null
      },{
        "title": "Collection framework",
        "excerpt":"A collection allows a group of objects to be treated as a single unit. Arbitrary objects can be stored, retrieved, and manipulated as elements of collections.   The Collection Framework provides a well-designed set if interface and classes for sorting and manipulating groups of data as a single unit, a collection.   So What Do You Do with a Collection?  There are a few basic operations you’ll normally use with collections:     Add objects to the collection.   Remove objects from the collection.   Find out if an object (or group of objects) is in the collection.   Retrieve an object from the collection (without removing it).   Iterate through the collection, looking at each element (object) one after another.   Key Interfaces and Classes of the Collections Framework  The core interfaces allow collections to be manipulated independently of their implementation. These interfaces define the common functionality exhibited by collections and facilitate data exchange between collections. These interfaces are                  Collection       Set       Sorted Set                 List       Map       Sorted Map                 Queue       NavigableMap       NavigableSet              So we have Set and List interface which extend from Collection interfaces, and we have SortedMap which is extending from Map interface.   The different interfaces describe the different types of groups. For the most part, once you understand the interfaces, you understand the framework. While you always need to create specific, implementations of the interfaces, access to the actual collection should be restricted to the use of the interface methods, thus allowing you to change the underlying data structure, without altering the rest of your code.         When designing software with the Collection Framework, it is useful to remember the following hierarchical relationship of the four basic interfaces of the framework.      The Collection interface is a group of objects, with duplicates allowed.   Set extends Collection but forbids duplicates.   List extends Collection also, allows duplicates and introduces positional indexing.   Map extends neither Set nor Collection   The concrete classes which implement these interfaces are:-                  Maps       Sets       Lists       Queues       Utilities                       HashMap       HashSet       ArrayList       PriorityQueue       Collections                 HashTable       LinkedHashSet       Vector                                 TreeMap       TreeSet       LinkedList                                 LinkedHashMap                                           After java 1.6 two more interfaces were introduced which are NavigableMap and NavigableSet these two interfaces extend from the SortedMap and SortedSet respectively. These interfaces provide special methods to sort the elements in ascending order, descending order, also to retrieve the element which is immediately greater than or equal to a given value etc. These methods are used to return the closest matches of elements for the given elements in the collection.   Other than these classes, we have a special class which is used to manipulate the Collection Objects, this class is Collections, this class has some of the very important methods such as sort, shuffle, reverse, binaySearch, etc.         Collection interface   The Collection interface is used to represent any group of objects, or elements. You use the interface when you wish to work with a group of elements in as general a manner as possible.   Listed below are the methods which have to be implemented while implementing Collection interface.                  Method       Return type       Description                       add(Object o)       boolean       Ensures that this collection contains the specified element (optional operation).                 addAll(Collection c)       Boolean       Adds all of the elements in the specified collection to this collection (optional operation)                 clear()       Void       Removes all of the elements from this collection (optional operation).                 contains(Object o)       Boolean       Returns true if this collection contains the specified element.                 containsAll(Collection c)       Boolean       Returns true if this collection contains all of the elements in the specified collection.                 isEmpty()       Boolean       Returns true if this collection contains no elements.                 iterator()       Iterator       Returns an iterator over the elements in this collection.                 remove(Object o)       Boolean       Removes a single instance of the specified element from this collection, if it is present (optional operation).                 removeAll(Collection c)       boolean       Removes all this collection’s elements that are also contained in the specified collection (optional operation).                 retainAll(Collection c)       Boolean       Retains only the elements in this collection that are contained in the specified collection (optional operation).                 size()       Int       Returns the number of elements in this collection.                 toArray()       Object[]       Returns an array containing all of the elements in this collection.                 toArray(Object[] a)       Object[]       Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array.           The interface supports basic operations like adding and removing. When you try to remove an element, only a single instance of the element in the collection is removed, if present.     boolean add (Object o)   boolean remove(Object o)         The Collection interface also supports query operations     int size()   boolean isEmpty()   boolean contains(Object o)   Iterator iterator()   Because the Collection interface is generic, you can write utility methods that operate on any kind of collection. For example, here is a generic method that tests whether an arbitrary collection contains a given element:   public static &lt;E&gt; boolean contains(Collection&lt;E&gt; c, Object obj) { \tfor (E element : c) \t\tif (element.equals(obj)) \t\t\treturn true; \treturn false; }   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/1-collection/",
        "teaser": null
      },{
        "title": "Iterators",
        "excerpt":"When we are having a collection of objects we needed a mechanism to traverse through it. But no two implementations are going to be the same when we are implementing a Collection interface for e.g. if we are using ArrayList or LinkedList, the two implementations are different and in no ways we can use the same algorithm to traverse through the all the collections.   To avoid these problems, in the Collection interface, an iterator method was declared which will return an Iterator object.   So every time someone implements a Collection class, he will have to override the Iterator method and provide a mechanism to traverse through the data structure he is providing.   The iterator has only three methods declared                  Methods       Description                 next()       Returns a reference of type T to the next object that is available from the iterator and throws an exception of type java.util.NoSuchElementException if no further elements are available.                 hasNext()       Returns true if at least one more element is available from the iterator, so calling the next() method for the iterator returns a reference to the object in the container. The method returns false if no more elements are available from the iterator. Thus this method provides a way to check whether calling the next() method for the iterator will return a reference or throw an exception.                 remove()       If the remove operation is supported, this method removes the last element that was retrieved by the preceding next() method call from the collection. If the remove operation is supported, this method throws an exception of type java.lang.UnsupportedOperationException. It will also throw an exception of type java.lang.IllegalStateException if the next() method has not been called for the iterator object prior to calling the remove() method.           Using Iterators   Now let us take an example of using Iterator, I will be using ArrayList to demonstrate how to use the iterator object obtained from the Collection object.   import java.util.ArrayList; import java.util.Iterator;  public class Main {   public static void main(String[] args) {     ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();  //Line 1: Creating an ArrayList      al.add(1);\t//Line 2: Adding values to arrays     al.add(2);     al.add(3);     al.add(4);     al.add(5);             Iterator&lt;Integer&gt; iterate = al.iterator(); //Line 3: Getting an iterator object.           while(iterate.hasNext()) { //Line 4: using the hasNext method to check if there is more element.       Integer integer = iterate.next(); //Line 5: using next() method to get the value.             if(integer == 3){     \t  iterate.remove(); //Line 6: calling the remove() method to delete the value from the list.     \t  System.out.println(integer + \" --&gt; Deleting this element\");       }else{     \t  System.out.println(integer);       }     \t       }          System.out.println(al);   } }  Now let us understand what is happening in the above code,     At line 1: we are creating a reference to the object of ArrayList which will hold the data of type Integer. Here we have used the concept of Generics using &lt;&gt; to define the type of list we want to create( we will see details of Generics in later chapter).   At line 2: we are adding some values to the list.   At line 3: we are using iterator() method of Collections class to get an iterator object.   At line 4: we used hasNext() method of iterator to check whether we have more elements in the list.   At line 5: if we have more elements in the list, we are using next() method to get that next element.   At line 6: if we want to delete any object from the list we just have to call the remove method, and object to which the next() method is referencing will be deleted.         1 2 3 --&gt; Deleting this element 4 5 [1, 2, 4, 5]   Iterators - foreach loop  The basic for loop was extended in Java 5 to make iteration over arrays and other collections more convenient. This newer for statement is called the enhanced for or for-each (because it is called this in other programming languages).   It’s commonly used to iterate over an array or a Collections class (eg, ArrayList). It can also iterate over anything that implements the Iterable interface (must define iterator() method). Many of the Collections classes (eg, ArrayList) implement Iterable, which makes the for-each loop very useful. You can also implement Iterable for your own data structures.   The for-each and equivalent for statements have these forms. The two basic equivalent forms are given, depending one whether it is an array or an Iterable that is being traversed. In both cases an extra variable is required, an index for the array and an iterator for the collection.    public class Main { \tpublic static void main(String args[]) {  \t\tdouble[] ar = { 1.2, 3.0, 0.8 };  \t\tfor (double d : ar) { // d gets successively each value in ar. \t\t\tSystem.out.println(d); \t\t} \t} }  1.2 3.0 0.8   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/2-collection/",
        "teaser": null
      },{
        "title": "List, ArrayList, LinkedList",
        "excerpt":"A List extends Collection interface but it also cares about the index. The one thing that List has that non-lists don’t have is a set of methods related to the index. Those key methods include things like get(int index), indexOf(Object o), add(int index, Object obj), and so on.   Since in list we are more concentrated on the order of the elements, in which order the list has been created and how the elements are arranged in the List.   So let us see the addition methods provided by List method other than the methods provided by the Collection Class.                  Method       Return type       Description                       add(int index, Object element)       void       Inserts the specified element at the specified position in this list (optional operation).                 addAll(int index, Collection c)       boolean       Inserts all of the elements in the specified collection into this list at the specified position (optional operation).                 get(int index)       Object       Returns the element at the specified position in this list.                 remove(int index)       Object       Removes the element at the specified position in this list (optional operation).                 set(int index, Object element)       Object       Replaces the element at the specified position in this list with the specified element (optional operation).                 subList(int fromIndex, int toIndex)       List       Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive.           Now we have learned about the List interface and its method which have to be implemented. Let us the see the concrete classes which implement it.   ArrayList  The ArrayList class extends AbstractList and implements the List interface. ArrayList supports dynamic arrays that can grow as needed. In Java, standard arrays are of a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold. But, sometimes, you may not know until run time precisely how large of an array you need. To handle this situation, the collections framework defines ArrayList. In essence, an ArrayList is a variable-length array of object references. That is, an ArrayList can dynamically increase or decrease in size. Array lists are created with an initial size. When this size is exceeded, the collection is automatically enlarged. When objects are removed, the array may be shrunk.   Some of the advantages ArrayList has over arrays are     It can grow dynamically.   It provides more powerful insertion and search mechanisms than arrays.   Let’s take a look at using an ArrayList that contains Strings.   List myList = new ArrayList(); List&lt;String&gt; myList = new ArrayList&lt;String&gt;();   We have used two types of declaration at Line 1; we have created an array list which can hold any kind of object, where as declaration at Line 2; states that we creating a list which will hold only the data of String type.   In many ways, ArrayList is similar to a String[] in that it declares a container that can hold only Strings, but it's more powerful than a String[] as we have seen the ArrayList grows dynamically and it also provides method of insertion and searching.         Adding and Removing Elements  Now we have our list ready and we want to insert elements to it. Adding element to a list is very easy, you just have to call add() method.   import java.util.ArrayList; import java.util.List;   public class Main { \tpublic static void main(String args[]) throws Exception { \t    // Create/fill collection \t    List&lt;String&gt; list = new ArrayList&lt;String&gt;(); \t    list.add(\"A\"); \t    list.add(\"B\"); \t    list.add(\"C\"); \t    list.add(\"D\"); \t     \t    System.out.println(list); \t     \t    System.out.println(list.size()); \t    System.out.println(list.contains(\"B\")); \t    System.out.println(list.contains(\"BB\")); \t    list.remove(\"C\"); \t    System.out.println(list.size());  \t  } }  [A, B, C, D] 4 true false 3   In the above code we have used add() method to add the elements in the list. Then used the size() method to get the total number of elements in the list and finally used the contains() method to check whether the specific element is present.   To remove an element we use the remove method of the Collection Interface.   Converting Arrays to Lists to Arrays   There are a couple of methods that allow you to convert arrays to Lists, and Lists to arrays. The List and Set classes have toArray() methods, and the Arrays class (extends Object)has a static method called asList(). The Arrays.asList() method copies an array into a List.   Note: When you use the asList() method, the array and the List become joined at the hip. When you update one of them, the other gets updated automatically.   Now let us understand this by an example:   import java.util.Arrays; import java.util.Iterator; import java.util.List;  public class Main { \tpublic static void main(String[] args) { \t\t \t\tString[] sa = { \"one\", \"two\", \"three\", \"four\" }; \t\tList sList = Arrays.asList(sa); // make a List \t\tSystem.out.println(\"size \" + sList.size()); \t\tSystem.out.println(\"idx2 \" + sList.get(2));  \t\tsList.set(3, \"six\"); // change List \t\tsa[1] = \"five\"; // change array \t\t \t\tIterator iterate = sList.iterator(); \t\twhile(iterate.hasNext()){ \t\t\tSystem.out.print(iterate.next() + \" \"); \t\t} \t\t\t \t\tSystem.out.println(\"\\nsl[1] \" + sList.get(1)); \t} }   In this program we are     Creating an array called as ‘sa’.   Then we use Arrays.asList() static method create an a List.   Then we are accessing the values of the sList with its size() method and get() method.   Now we are changing the value of index 3 to ‘Six’ using the List operatios.   Then we are setting the value if index 1 to ‘five’ using the arrays operation.   Finally when print he the values  of array ‘sa’ and value at location 1 of the list.         size 4 idx2 three one five three six sl[1] five   Notice that we have made changes to list which was reflected in array and vice-versa.   This is how an array of String will look like in the memory      So each value will be assigned a memory location consecutively(e.g. value ‘one’ will be stored at location 1001, value ‘two’ will be stored at location 1002 and so on). But when we call the asList() method the value is modified like this      So actually the same array is will start behaving like a List without creating a copy of the Array.   Linked List  A linked list is a data structure that consists of a sequence of data records such that in each record there is a field that contains a reference (i.e., a link) to the next record in the sequence.      A Linked List will look like the above fig, we have two at consecutive two memory locations for e.g. 2 and 2184, in this case 2 is the actual data which we want to store and 2184 is the memory location of another consecutive memory locations where our next data is stored.   In java a LinkedList is actually a doubly linked list i.e. the List will Look like this:-            Using Linked List   Accessing a linked list is same as using ArrayList. Insertions and deletions in a doubly-linked list are very efficient—elements are not shifted, as is the case for an array. The LinkedList class provides extra methods that implement operations that add, get, and remove elements at either end of a LinkedList:                  Method       Return Type                       addFirst(Object obj)       void                 addLast(Object obj)       void                 getFirst()       Object                 getLast()       Object                 removeFirst()       Object                 removeLast()       Object           Let us see an example of these methods implementation, in the below code we will create a list of type Linked List and add the values to this list. Then we will use the above mentioned methods to manipulate the list.   import java.util.LinkedList; import java.util.List;  public class Main { \tpublic static void main(String args[]) throws Exception { \t    // Create/fill collection \t    LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;(); \t     \t    list.add(\"A\"); \t    list.add(\"B\"); \t    list.add(\"C\"); \t    list.add(\"D\"); \t     \t    System.out.println(list); \t     \t    list.addFirst(\"1\"); \t    list.addLast(\"2\"); \t    System.out.println(list); \t     \t    System.out.println(\"The first value = \" + list.getFirst()); \t    System.out.println(\"The last value = \" + list.getLast()); \t     \t    System.out.println(\"The value removed from the first position of list = \" + list.removeFirst()); \t    System.out.println(\"The value removed from the last position of list = \" + list.removeLast()); \t     \t    System.out.println(list);  \t  } }         [A, B, C, D] [1, A, B, C, D, 2] The first value = 1 The last value = 2 The value removed from the first position of list = 1 The value removed from the last position of list = 2 [A, B, C, D]   Similar to the ArrayList, we have one more class the Vector class, the only difference between Vector class and ArrayList is that the methods of Vector class are synchronized, and hence are thread safe, where as the methods of ArrayList is not synchronized.   Which one to choose  So we have three implementations of List interface, ArrayList, LinkedList, Vector, to choose amongst them use the following rule.     ArrayList: When you want to store data in the memory which may vary(think of a growing array).   LinkedList : Prefer LinkedList over ArrayList when you want to store a very large amount of data in the memory.   Vector: Prefer Vector over ArrayList if you want to make the list thread safe since all the methods are synchronized   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/3-collection/",
        "teaser": null
      },{
        "title": "Set, Sorted Set, HashSet, TreeSet",
        "excerpt":"Now let us say that we want to create a list that holds unique objects so what should we do? Should we use the normal list (ArrayList or LinkedList) to keep the data and whenever we want to insert data, should we go and check the list every time that whether the list already contains the object or not.   To simply our life, java has provided us with Sets.   Sets may not contain duplicate elements. If you try to add an object to a Set that already contains that object, the add() call will return false and the Set will not be changed. A true return value from add() means the Set did not formerly contain the object, but now it does.   Hashset  A HashSet is an unsorted, unordered Set. It uses the hashcode of the object being inserted, so the more efficient your hashCode() implementation the better access performance you’ll get. Use this class when you want a collection with no duplicates and you don’t care about order when you iterate through it.   import java.util.HashSet; import java.util.Set;  public class Main { \tpublic static void main(String[] args) {        String name1 = \"John\";        String name2 = \"Michel\";        String name3 = \"John\";        String name4 = \"Harry\";        String name5 = \"abhishek\";                Set&lt;String&gt; set = new HashSet&lt;String&gt;(); //creating a set                //Adding the data        System.out.println(set.add(name1));        System.out.println(set.add(name2));        System.out.println(set.add(name3));        System.out.println(set.add(name4));        System.out.println(set.add(name5));                //Printing the data         System.out.println(set); \t}  }         true true false true true [Michel, Harry, abhishek, John]   In the above example we have created a Set in which we try to add the element of String type. We try to add ‘John’ two times but fail to add the element again.   SortedSet   A SortedSet is an Interface which extends Set Interface. It is a set that further guarantees that its iterator will traverse the set in ascending element order, sorted according to the natural ordering of its elements, or by a Comparator (we will see later in this chapter what is a comparator and how to implement it) provided at sorted set creation time. Several additional operations are provided to take advantage of the ordering.   The following are the methods declared in the SortedSet additional to the methods declared in the Set interface.                  Method       Return Type       Description                       comparator()       Comparator       Returns the comparator associated with this sorted set, or null if it uses its elements’ natural ordering.                 first()       Object       Returns the first (lowest) element currently in this sorted set.                 headSet(Object toElement)       SortedSet       Returns a view of the portion of this sorted set whose elements are strictly less than toElement.                 last()       Object       Returns the last (highest) element currently in this sorted set.                 subSet(Object fromElement, Object toElement)       SortedSet       Returns a view of the portion of this sorted set whose elements range from fromElement, inclusive, to toElement, exclusive.                 tailSet(Object fromElement)       SortedSet       Returns a view of the portion of this sorted set whose elements are greater than or equal to fromElement.                 Treeset   The TreeSet is one of two sorted collections (the other being TreeMap). It uses a Red-Black tree structure (but you knew that), and guarantees that the elements will be in ascending order, according to natural order. Optionally, you can construct a TreeSet with a constructor that lets you give the collection your own rules for what the order should be (rather than relying on the ordering defined by the elements’ class) by using a Comparable or Comparator.  import java.util.SortedSet; import java.util.TreeSet;  public class Main { \tpublic static void main(String[] args) { \t\tSortedSet&lt;String&gt; set = new TreeSet&lt;String&gt;(); // Creating a TreeSet Object \t\t \t\t//Adding elements \t\tset.add(\"b\"); \t\tset.add(\"c\"); \t\tset.add(\"a\"); \t\tset.add(\"d\"); \t\tset.add(\"g\"); \t\t \t\tSystem.out.println(set); // Printing the set \t\t \t\tSystem.out.println(\"First element = \" + set.first()); //Printing the First element of the set. \t\tSystem.out.println(\"Last element = \" + set.last()); //Printing the Last element of the set \t\t \t\t//creating a new Set of first few elements from the given set and printing the set \t\tSystem.out.println(\"creating set for elements before 'd': \" + set.headSet(\"d\")); \t\t \t\t//creating a new Set of elements from the given set and printing the set \t\tSystem.out.println(\"Creating new sub set from 'b' to 'd': \" + set.subSet(\"b\", \"d\")); \t\t \t\t//creating a new Set of last few elements from the given set and printing the set \t\tSystem.out.println(\"Creating set of last elements from 'c' to end: \" + set.tailSet(\"c\")); \t\t \t} }          [a, b, c, d, g] First element = a Last element = g creating set for elements before 'd': [a, b, c] Creating new sub set from 'b' to 'd': [b, c] Creating set of last elements from 'c' to end: [c, d, g]   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/4-collection/",
        "teaser": null
      },{
        "title": "Map collection",
        "excerpt":"A Map cares about unique identifiers. You map a unique key (the ID) to a specific value. You’re probably quite familiar with Maps since many languages support data structures that use a key/value or name/value pair. The Map implementations let you do things like search for a value based on the key, ask for a collection of just the values, or ask for a collection of just the keys. Like Sets, Maps rely on the equals() method to determine whether two keys are the same or different.   A map does not allow duplicate keys, in other words, the keys are unique. Each key maps to one value at the most, implementing what is called a single-valued map.      NOTE: Both the keys and the values must be objects. This means that primitive values must be wrapped in their respective wrapper objects, if they are to be put in a map.   The listed operations constitute the basic functionality provided by a map.                  Method       Return Type       Description                       put(Object key, Object value)       Object       Inserts the &lt;key, value&gt; entry into the map. It returns the value previously associated with the specified key, if any. Otherwise, it returns the null value.                 get(Object key)       Object       Returns the value to which the specified key is mapped, or null if no entry is found.                 remove(Object key)       Object       The remove() method deletes the entry for the specified key. It returns the value previously associated with the specified key, if any. Otherwise, it returns the null value.                 containsKey(Object key)       boolean       Returns true if the specified key is mapped to a value in the map.                 containsValue(Object value)       boolean       Returns true if there exists one or more keys that are mapped to the specified value.                 HashMap   The HashMap gives you an unsorted, unordered Map. When you need a Map and you don’t care about the order (when you iterate through it), then HashMap is the way to go; the other maps add a little more overhead. Where the keys land in the Map is based on the key’s hashcode, so, like HashSet, the more efficient your hashCode() implementation, the better access performance you’ll get. HashMap allows one null key and multiple null values in a collection.      import java.util.Collection; import java.util.HashMap; import java.util.Iterator;  public class Main { \tpublic static void main(String[] args) { \t\tHashMap&lt;String, String&gt; hMap = new HashMap&lt;String, String&gt;(); // Creating \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// a \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// hashMap  \t\t// Adding the values as key, value pair \t\thMap.put(\"1\", \"One\"); \t\thMap.put(\"2\", \"Two\"); \t\thMap.put(\"3\", \"Three\");  \t\t// Using keySet() method get the set of keys and finally getting the \t\t// Iterator Object from it. \t\tIterator itr = hMap.keySet().iterator();  \t\twhile (itr.hasNext()) { \t\t\tString key = (String) itr.next(); \t\t\t// Using the get method to the value refernced by the key \t\t\tSystem.out.println(\"The value at \" + key + \" is \" + hMap.get(key)); \t\t} \t\t \t\tCollection collection = hMap.values(); \t\tSystem.out.println(collection); \t\t \t\tif(hMap.containsKey(\"2\")){ \t\t\thMap.remove(\"2\"); \t\t} \t\t \t\tcollection = hMap.values(); \t\tSystem.out.println(collection); \t} }   In the above code :     We have used put(key, values) method to put a key-value pair in the HashMap   The keySet() Method return a set of elements of keys of HashMap.   We used get(key) Method to get the value for the given key.   We used the containsKey(Key)method to find that whether the key is present in the list.   If the key is present in the list we used the remove(key) method to remove the Key.   The value at 1 is One The value at 2 is Two The value at 3 is Three [One, Two, Three] [One, Three]         TreeMap  You can probably guess by now that a TreeMap is a sorted Map. And you already know that by default, this means “sorted by the natural order of the elements.” Like TreeSet, TreeMap lets you define a custom sort order (via a Comparable or Comparator) when you construct a TreeMap, that specifies how the elements should be compared to one another when they’re being ordered.      import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.TreeMap;  public class Main { \tpublic static void main(String[] args) { \t\tTreeMap&lt;String, String&gt; hMap = new TreeMap&lt;String, String&gt;(); // Creating \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// a \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// TreeMap  \t\t// Adding the values as key, value pair \t\thMap.put(\"1\", \"One\"); \t\thMap.put(\"2\", \"Two\"); \t\thMap.put(\"3\", \"Three\");  \t\t// Using keySet() method get the set of keys and finally getting the \t\t// Iterator Object from it. \t\tIterator itr = hMap.keySet().iterator();  \t\twhile (itr.hasNext()) { \t\t\tString key = (String) itr.next(); \t\t\t// Using the get method to the value refernced by the key \t\t\tSystem.out.println(\"The value at \" + key + \" is \" + hMap.get(key)); \t\t} \t\t \t\tCollection collection = hMap.values(); \t\tSystem.out.println(collection); \t\t \t\tif(hMap.containsKey(\"2\")){ \t\t\thMap.remove(\"2\"); \t\t} \t\t \t\tcollection = hMap.values(); \t\tSystem.out.println(collection); \t} }   The value at 1 is One The value at 2 is Two The value at 3 is Three [One, Two, Three] [One, Three]   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/5-collection/",
        "teaser": null
      },{
        "title": "Comparable & Comparator",
        "excerpt":"While writing the object-oriented programs, comparison of two instances of the same class is often required. Once instances are comparable, we can sort them in any order. Comparable interface is defined in java.lang package and is used to define the natural sort order of a class. The interface java.lang.Comparator defines an auxiliary sort order for a class.   Comparable interface can be implemented by implementing only one method: compareTo. Implement the existing class by defining the the natural order of that class. compareTo() method compares the two object of same type and returns a numerical result based on the comparison. If the result is negative, then the object sorts less than the other; if 0, the two are equal, and if positive, this object sorts greater than the other. To translate this into boolean, simply performs object1.compareTo(object2)  object,  where op is one of &lt;, &lt;=, =, !=, &gt;, or &gt;=.   import java.util.Arrays; import java.util.Set; import java.util.TreeSet;  public class Person implements Comparable {   String firstName, lastName;    public Person(String f, String l) {     this.firstName = f;     this.lastName = l;   }    public String getFirstName() {     return firstName;   }    public String getLastName() {     return lastName;   }    public String toString() {     return \"\\n[First Name=\" + firstName + \", Last name=\" + lastName + \"]\";   }    public int compareTo(Object obj) {     Person emp = (Person) obj;     int deptComp = firstName.compareTo(emp.getFirstName());      return ((deptComp == 0) ? lastName.compareTo(emp.getLastName())         : deptComp);   }    public boolean equals(Object obj) {     if (!(obj instanceof Person)) {       return false;     }     Person emp = (Person) obj;     return firstName.equals(emp.getFirstName())         &amp;&amp; lastName.equals(emp.getLastName());   }    public static void main(String args[]) {     Person emps[] = { new Person(\"Debbie\", \"Deg\"),         new Person(\"Geri\", \"Gradus\"), new Person(\"Ester\", \"Exy\"),         new Person(\"Mary\", \"Meas\"),         new Person(\"Anastasia\", \"Fredo\") };     Set set = new TreeSet(Arrays.asList(emps));     System.out.println(set);   } }  [ [First Name=Anastasia, Last name=Fredo],  [First Name=Debbie, Last name=Deg],  [First Name=Ester, Last name=Exy],  [First Name=Geri, Last name=Gradus],  [First Name=Mary, Last name=Meas]]         Comparator Interface   While you were looking up the Collections.sort() method you might have noticed that there is an overloaded version of sort() that takes a List, AND something called a Comparator. The Comparator interface gives you the capability to sort a given collection any number of different ways. The other handy thing about the Comparator interface is that you can use it to sort instances of any class—even classes you can’t modify. The Comparator interface is also very easy to implement, having only one method, compare ().   The compare () method returns an int with the following characteristics:      negative If thisObject &lt; anotherObject   zero If thisObject == anotherObject   positive If thisObject &gt; anotherObject   import java.util.*;  class Employee {  \tprivate int age;  \tprivate String name;  \tpublic void setAge(int age) {  \t\tthis.age = age;  \t}  \tpublic int getAge() {  \t\treturn this.age;  \t}  \tpublic void setName(String name) {  \t\tthis.name = name;  \t}  \tpublic String getName() {  \t\treturn this.name;  \t}  }  /*  *   * User defined java comaprator.  *   * To create custom java comparator Implement Comparator interface and  *   * define compare method.  *   * The below given comparator compares employees on the basis of their age.  */  class AgeComparator implements Comparator {  \tpublic int compare(Object emp1, Object emp2) {  \t\t// parameter are of type Object, so we have to downcast it to Employee \t\t// objects  \t\tint emp1Age = ((Employee) emp1).getAge();  \t\tint emp2Age = ((Employee) emp2).getAge();  \t\tif (emp1Age &gt; emp2Age)  \t\t\treturn 1;  \t\telse if (emp1Age &lt; emp2Age)  \t\t\treturn -1;  \t\telse  \t\t\treturn 0;  \t}  }  /*  *   * The below given comparator compares employees on the basis of their name.  */  class NameComparator implements Comparator {  \tpublic int compare(Object emp1, Object emp2) {  \t\t// parameter are of type Object, so we have to downcast it to Employee \t\t// objects  \t\tString emp1Name = ((Employee) emp1).getName();  \t\tString emp2Name = ((Employee) emp2).getName();  \t\t// uses compareTo method of String class to compare names of the \t\t// employee  \t\treturn emp1Name.compareTo(emp2Name);  \t}  }  /*  *   * This Java comparator example compares employees on the basis of  *   * their age and name and sort it in that order.  */  public class Main {  \tpublic static void main(String args[]) {  \t\t/* \t\t *  \t\t * Employee array which will hold employees \t\t */  \t\tEmployee employee[] = new Employee[2];  \t\t// set different attributes of the individual employee.  \t\temployee[0] = new Employee();  \t\temployee[0].setAge(40);  \t\temployee[0].setName(\"Joe\");  \t\temployee[1] = new Employee();  \t\temployee[1].setAge(20);  \t\temployee[1].setName(\"Mark\");  \t\tSystem.out.println(\"Order of employee before sorting is\");  \t\t// print array as is.  \t\tfor (int i = 0; i &lt; employee.length; i++) {  \t\t\tSystem.out.println(\"Employee \" + (i + 1) + \" name :: \" \t\t\t\t\t+ employee[i].getName() + \", Age :: \" \t\t\t\t\t+ employee[i].getAge());  \t\t}  \t\t/* \t\t *  \t\t * Sorting array on the basis of employee age by passing AgeComparator \t\t */  \t\tArrays.sort(employee, new AgeComparator());  \t\tSystem.out \t\t\t\t.println(\"\\n\\nOrder of employee after sorting by employee age is\");  \t\tfor (int i = 0; i &lt; employee.length; i++) {  \t\t\tSystem.out.println(\"Employee \" + (i + 1) + \" name :: \" \t\t\t\t\t+ employee[i].getName() + \", Age :: \" \t\t\t\t\t+ employee[i].getAge());  \t\t}  \t\t/* \t\t *  \t\t * Sorting array on the basis of employee Name by passing NameComparator \t\t */  \t\tArrays.sort(employee, new NameComparator());  \t\tSystem.out \t\t\t\t.println(\"\\n\\nOrder of employee after sorting by employee name is\");  \t\tfor (int i = 0; i &lt; employee.length; i++) {  \t\t\tSystem.out.println(\"Employee \" + (i + 1) + \" name :: \" \t\t\t\t\t+ employee[i].getName() + \", Age :: \" \t\t\t\t\t+ employee[i].getAge());  \t\t}  \t}  }  In the above code we have declared a class Employee with two variables name and age. Now we will sort the list of employee depending on his name and age for which we used two classes NameComparator and AgeComparator respectively.   Let us take AgeComparator to understand how the comparator works. For a class to be Comparator, it must implement comparator interface. In this class we override the compareTo(object1, object2) method, So we get the Employee age from the object1 and object2. And we returned the values as -1, 0 or +1 depending on the criteria.   Once we have our comparator ready we use this comparator and pass it through the Arrays.sort() method. Once the sorting is done the original list gets sorted according to the criteria.         Order of employee before sorting is Employee 1 name :: Joe, Age :: 40 Employee 2 name :: Mark, Age :: 20   Order of employee after sorting by employee age is Employee 1 name :: Mark, Age :: 20 Employee 2 name :: Joe, Age :: 40   Order of employee after sorting by employee name is Employee 1 name :: Joe, Age :: 40 Employee 2 name :: Mark, Age :: 20   Comparator vs. Comparable   You say class is Comparable so it indicates that this class is self-comparable, or it is able-to-compare-it-self to some other object. It is self compared to or as its method says compareTo(Object o).   Comparable (able-to-compares-itself) uses compareTo(Object o)   Secondly, you say class is Comparator because it is comparing objects of other class. So what it do is to, as its method says, compare(Object o1, Object o2). Remember that Comparator itself is not compared to anything, it just compare(…)-s two objects of some other class.  Comparator ( compares two other objects)uses compare(Object o1, Object o2)   ","categories": ["java"],
        "tags": [],
        "url": "https://kuros.in/java/2019/01/6-collection/",
        "teaser": null
      },{
        "title": "Configuring Trigger Tables",
        "excerpt":"Random-JPA provides a way to load tables generated by triggers. Although it only supports fetching of tables generated by trigger and does load entities if only column values are modified.   Note: If entity is declared as Trigger tables, random values will not be generated for this entity.   Let us say that we have trigger which logs history of all the bank transaction taking place. “Transaction” has two foreign keys, one maps to personId and other to accountId.   final JPAContextFactory jpaContextFactory = JPAContextFactory     .newInstance(Database.MY_SQL, entityManager); jpaContextFactory.withTriggers(Trigger.of(Transaction.class)         .withLink(Transaction_.personId, Person_.id)         .withLink(Transaction_.accountId, Account_.accountId));   So when you load trigger table “Transaction” it will query the table to fetch row with mapped personId &amp; accountId  ","categories": ["random-jpa"],
        "tags": [],
        "url": "https://kuros.in/random-jpa/2019/01/trigger-tables/",
        "teaser": null
      },{
        "title": "Adding custom generator in Random-JPA",
        "excerpt":"Random-JPA provides mechanism to configure generation of random values. This can be done by adding custom generator. You need to provide generator to the JPAContextFactory in order to create JPAContext.       @Bean     public JPAContext createJpaContext() {         final Dependencies dependencies = getDependencies();         final Generator generators = Generator.newInstance();                  return JPAContextFactory                 .newInstance(Database.MY_SQL, entityManager)                 .with(generators)                 .with(dependencies)                 .generate();     }   There are two types of generator supported      Class Generator   Attribute Generator   Random Class Generator  Add random class generator which controls, how random object is generated for a given class type.   RandomClassGenerator has two methods   getTypes() - List of all the classes for which this generator will be applied. doGenerate(Class&lt;?&gt; type) - provides method to generate random object, you are provided with a handle of the class for which generation is taking place.   Let us say that you want your restrict numerical values to range from 0-10000 system wide, i.e, all random values for type Integer/Long/int/long should be between 0-10000   generator.addClassGenerator(new RandomClassGenerator() {     @Override     public Collection&lt;Class&lt;?&gt;&gt; getTypes() {         final List&lt;Class&lt;?&gt;&gt; classes = Lists.newArrayList();         classes.add(Integer.class);         classes.add(Integer.TYPE);         classes.add(Long.class);         classes.add(Long.TYPE);         return classes;     }      @Override     public Object doGenerate(Class&lt;?&gt; aClass) {         if (aClass == Integer.class || aClass == Integer.TYPE) {             return RandomUtils.nextInt(10000);             }                              return RandomUtils.nextLong(10000);     } });         Random Attribute Generator  As the name states you can explicitly manage random generation of specific attribute.   RandomAttributeGenerator has two methods   getAttributes() - List of all the attributes for which this generator is applicable.  doGenerate() - how to generate random values.   Let us say you want to every Employee’s name &amp; Department’s name to start with “Test-“   generator.addAttributeGenerator(new RandomAttributeGenerator() {     @Override     public List&lt;? extends Attribute&gt; getAttributes() {         final List&lt;Attribute&lt;?, ?&gt;&gt; attributes = Lists.newArrayList();         attributes.add(Employee_.firstName);         attributes.add(Employee_.lastName);         attributes.add(Department_.deptName);         return attributes;     }      @Override     public Object doGenerate() {         return \"Test-\" + RandomStringUtils.randomAlphanumeric(10);     } });         Order in which generator is applied   Below is the following order in which generation takes place. If the condition is met, next step is not evaluated.      Apply specific value (if provided in Plan).   Set null values for attribute (if provided in plan).   Apply RandomAttributeGenerator (if available).   Apply RandomClassGenerator (if available).   Apply default random generator.  ","categories": ["random-jpa"],
        "tags": [],
        "url": "https://kuros.in/random-jpa/2019/01/custom_generators/",
        "teaser": null
      },{
        "title": "Adding custom dependency in Random-JPA",
        "excerpt":"There are many systems which doesn’t have proper foreign key relationship. In order to create relationship with other entities, random-jpa provides dependencies to be added to JPAContextFactory. Based on these provided custom dependencies and foreign key relationship, a JPAContext is created.   Let us continue with our application, suppose application want to maintain an audit trail of all the inventories ordered by an employee. But there is no foreign key relationship between the tables.   Problem statement  I want to create new EmployeeInventoryAudit entries for a customer. So during my complete application lifcycle, EmployeeInventoryAudit depends on Employee, but there is no foreign key relationship in table so random-JPA will not be able to derive this relationship automatically.   We will have to provide custom dependency at the application level(random-JPA also provides test level dependency as softLinks);   Table setup  Add Table:  CREATE TABLE employee_inventory_audit (     id           INT             NOT NULL AUTO_INCREMENT,     emp_no      INT             NOT NULL,     inventory   VARCHAR(40)     NOT NULL,     quantity   INT     NOT NULL,     PRIMARY KEY (id) );  Entity:  @Entity @Table(name = \"employee_inventory_audit\") public class EmployeeInventoryAudit {      @Id     @Column(name = \"id\")     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Integer id;      @Basic     @Column(name = \"emp_no\")     private Integer employeeNumber;      @Basic     @Column(name = \"inventory\")     private String inventory;      @Basic     @Column(name = \"quantity\")     private Integer quantity;      @Basic     @Column(name = \"purchase_date\")     private LocalDate purchaseDate;      // Getter &amp; Setter         }         And static meta model:  @StaticMetamodel(EmployeeInventoryAudit.class) public class EmployeeInventoryAudit_ {      public static volatile SingularAttribute&lt;EmployeeInventoryAudit, Integer&gt; id;     public static volatile SingularAttribute&lt;EmployeeInventoryAudit, Integer&gt; employeeNumber;     public static volatile SingularAttribute&lt;EmployeeInventoryAudit, String&gt; inventory;     public static volatile SingularAttribute&lt;EmployeeInventoryAudit, Integer&gt; quantity;     public static volatile SingularAttribute&lt;EmployeeInventoryAudit, LocalDate&gt; purchaseDate;  }   Adding custom dependency in Random-JPA   So as per the business logic, employeeNumber attribute of EmployeeInventoryAudit depends on employee’s customerNumber.   And we will tell the same thing to Random-JPA context factory while creating jpaContext.       final Dependencies dependencies = Dependencies.newInstance();     dependencies.withLink(Link.newLink(EmployeeInventoryAudit_.employeeNumber, Employee_.empNo));          final JPAContext jpaContext = JPAContextFactory                     .newInstance(Database.MY_SQL, entityManager)                     .with(dependencies)                     .generate();   Now if you generate EmployeeInventoryAudit using JPAContext:       @Test @Transactional     public void createEmployeeInventoryAudit() {          final ResultMap resultMap = jpaContext.createAndPersist(Entity.of(EmployeeInventoryAudit.class));          resultMap.print(System.out::println);      }  It would create employee followed by employee_inventory_audit.  └── *ROOT*     └── in.kuros.randomjpa.blogexample.entity.Employee|0 [empNo: 10023]         └── in.kuros.randomjpa.blogexample.entity.EmployeeInventoryAudit|0 [id: 1]   It behaves same as if employee_inventory_audit(emp_no) has foreign key to employees(emp_no) table.         Complete configuration  @Configuration public class TestConfig {      @Autowired private EntityManager entityManager;      @Bean     public JPAContext createJpaContext() {         return JPAContextFactory                 .newInstance(Database.MY_SQL, entityManager)                 .with(getDependencies())                 .generate();     }      private Dependencies getDependencies() {         final Dependencies dependencies = Dependencies.newInstance();         dependencies.withLink(Link.newLink(EmployeeInventoryAudit_.employeeNumber, Employee_.empNo));          return dependencies;     } }   checkout the Commit History on github  ","categories": ["random-jpa"],
        "tags": [],
        "url": "https://kuros.in/random-jpa/2019/01/custom_dependecy/",
        "teaser": null
      },{
        "title": "Random-JPA Integration (Contd.)",
        "excerpt":"In my previous post, we have written a jpa query to fetch latest salary of employees but there was an error in response, so we are first writing a failing tests to capture the error and then we will fix the bug.   Before we proceed with the new test, lets create a StaticMetaModel.   package in.kuros.randomjpa.blogexample.entity;  import javax.persistence.metamodel.SingularAttribute; import javax.persistence.metamodel.StaticMetamodel; import java.time.LocalDate;  @StaticMetamodel(Salary.class) public class Salary_ {      public static volatile SingularAttribute&lt;Salary, Integer&gt; id;     public static volatile SingularAttribute&lt;Salary, Integer&gt; employeeId;     public static volatile SingularAttribute&lt;Salary, Integer&gt; salary;     public static volatile SingularAttribute&lt;Salary, LocalDate&gt; fromDate;     public static volatile SingularAttribute&lt;Salary, LocalDate&gt; toDate;  }   It’s time to test our query with more intensive data. In this scenario, we want to create two salary records for a given employee with custom from and to dates, and fetch his latest salary.       @Test @Transactional     public void shouldTestToFetchLatestSalaryRecordForMultipleEntry() {         final JPAContext jpaContext = JPAContextFactory.newInstance(Database.MY_SQL, entityManager)                 .generate();          final LocalDate oldFromDate = LocalDate.now().minusDays(2);         final LocalDate oldToDate = LocalDate.now().minusDays(1);          final LocalDate newFromDate = LocalDate.now();         final LocalDate newToDate = LocalDate.now().plusDays(1);           final ResultMap resultMap = jpaContext.createAndPersist(                 Entity.of(Salary.class, 2)                         .with(0, Salary_.fromDate, oldFromDate)                         .with(0, Salary_.toDate, oldToDate)                         .with(1, Salary_.fromDate, newFromDate)                         .with(1, Salary_.toDate, newToDate));          resultMap.print(System.out::println); //just for debugging          final Salary salary1 = resultMap.get(Salary.class, 0);         final Salary salary2 = resultMap.get(Salary.class, 1);          final List&lt;Salary&gt; latestSalaries = salaryRepository.findLatestSalaries();          final Optional&lt;Salary&gt; result = latestSalaries                 .stream()                 .filter(sal -&gt; sal.getEmployeeId().equals(salary1.getEmployeeId())).findFirst();          Assert.assertTrue(result.isPresent());          Assert.assertEquals(\"The salary id should match with latest salary\", salary2.getId(), result.get().getId());         Assert.assertEquals(salary2.getSalary(), result.get().getSalary());         Assert.assertEquals(salary2.getFromDate(), result.get().getFromDate());         Assert.assertEquals(salary2.getToDate(), result.get().getToDate());     }  And when you run the test it fails  └── *ROOT*     └── in.kuros.randomjpa.blogexample.entity.Employee|0 [empNo: 10019]         ├── in.kuros.randomjpa.blogexample.entity.Salary|0 [id: 19]         └── in.kuros.randomjpa.blogexample.entity.Salary|1 [id: 20]    java.lang.AssertionError: The salary id should match with latest salary  Expected :20 Actual   :19  &lt;Click to see difference&gt;   \tat org.junit.Assert.fail(Assert.java:88) \tat org.junit.Assert.failNotEquals(Assert.java:834) \tat org.junit.Assert.assertEquals(Assert.java:118) \tat in.kuros.randomjpa.blogexample.repository.SalaryRepositoryTest.shouldTestToFetchLatestSalaryRecordForMultipleEntry(SalaryRepositoryTest.java:84) \tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) \tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) \tat java.lang.reflect.Method.invoke(Method.java:498) \tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) \tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) \tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) \tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) \tat org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) \tat org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) \tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) \tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) \tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) \tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) \tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) \tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) \tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) \tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) \tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) \tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) \tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) \tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) \tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) \tat org.junit.runners.ParentRunner.run(ParentRunner.java:363) \tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) \tat org.junit.runner.JUnitCore.run(JUnitCore.java:137) \tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) \tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) \tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) \tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)   So now we have a failing test, but before we move to fixing our query let’s understand the syntax.         Test Breakdown  Our aim was to create two salaries for 1 employee with different date ranges:   final ResultMap resultMap = jpaContext.createAndPersist(                 Entity.of(Salary.class, 2)                         .with(0, Salary_.fromDate, oldFromDate)                         .with(0, Salary_.toDate, oldToDate)                         .with(1, Salary_.fromDate, newFromDate)                         .with(1, Salary_.toDate, newToDate));   Here we told random-JPA to create 2 copies of Salary, in the background it determined its parent structure and created two rows Salary object.  Also you are providing custom values of each attributes you want to override, for entity referenced by index of creation order.   So here we are saying we want to set oldFromDate/oldToDate to Salary row 1 &amp; newFromDate/newToDate to salary row 2.   Simple isn’t it.   checkout the Commit History on github   Time to fix the test   @RepositoryRestResource(collectionResourceRel = \"salary\", path = \"salary\") public interface SalaryRepository extends PagingAndSortingRepository&lt;Salary, Integer&gt; {      @RestResource(path = \"latest\")     @Query(\"FROM Salary s WHERE NOT EXISTS (select 1 FROM Salary s2 WHERE s.employeeId = s2.employeeId and s.fromDate &lt; s2.fromDate and s.toDate &lt; s2.toDate) \")     List&lt;Salary&gt; findLatestSalaries(); }   You run the test and it passes. Hurray !!!   checkout the Commit History on github         Make JPAContext Singleton   Before we end the tutorial, one important thing remaining.   We should make JPAContext as a singleton object since loading the context is an heavy operation as build an internal hierarchy graph and entity mappings.   In this tutorial we will create JPAContext bean.   import com.github.kuros.random.jpa.Database; import com.github.kuros.random.jpa.JPAContext; import com.github.kuros.random.jpa.JPAContextFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;  import javax.persistence.EntityManager;  @Configuration public class TestConfig {      @Autowired private EntityManager entityManager;      @Bean     public JPAContext createJpaContext() {         return JPAContextFactory.newInstance(Database.MY_SQL, entityManager).generate();     } }   And modified our test to use autowired JPAContext. Now you made sure you are loading JPAContext only once.         Complete Test  package in.kuros.randomjpa.blogexample.repository;  import com.github.kuros.random.jpa.JPAContext; import com.github.kuros.random.jpa.persistor.model.ResultMap; import com.github.kuros.random.jpa.types.Entity; import in.kuros.randomjpa.blogexample.entity.Salary; import in.kuros.randomjpa.blogexample.entity.Salary_; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.transaction.annotation.Transactional;  import java.time.LocalDate; import java.util.List; import java.util.Optional;  @RunWith(SpringRunner.class) @SpringBootTest public class SalaryRepositoryTest {      @Autowired private JPAContext jpaContext;     @Autowired private SalaryRepository salaryRepository;      @Test @Transactional     public void shouldTestForFetchingSalaryRecordForOnlyOneEntry() {          final ResultMap resultMap = jpaContext.createAndPersist(Entity.of(Salary.class));         resultMap.print(System.out::println);          final Salary salary = resultMap.get(Salary.class);          final List&lt;Salary&gt; latestSalaries = salaryRepository.findLatestSalaries();          final Optional&lt;Salary&gt; result = latestSalaries                 .stream()                 .filter(sal -&gt; sal.getId().equals(salary.getId())).findFirst();          Assert.assertTrue(result.isPresent());         Assert.assertEquals(salary.getSalary(), result.get().getSalary());         Assert.assertEquals(salary.getFromDate(), result.get().getFromDate());         Assert.assertEquals(salary.getToDate(), result.get().getToDate());     }      @Test @Transactional     public void shouldTestToFetchLatestSalaryRecordForMultipleEntry() {          final LocalDate oldFromDate = LocalDate.now().minusDays(2);         final LocalDate oldToDate = LocalDate.now().minusDays(1);          final LocalDate newFromDate = LocalDate.now();         final LocalDate newToDate = LocalDate.now().plusDays(1);           final ResultMap resultMap = jpaContext.createAndPersist(                 Entity.of(Salary.class, 2)                         .with(0, Salary_.fromDate, oldFromDate)                         .with(0, Salary_.toDate, oldToDate)                         .with(1, Salary_.fromDate, newFromDate)                         .with(1, Salary_.toDate, newToDate));          resultMap.print(System.out::println); //just for debugging          final Salary salary1 = resultMap.get(Salary.class, 0);         final Salary salary2 = resultMap.get(Salary.class, 1);          final List&lt;Salary&gt; latestSalaries = salaryRepository.findLatestSalaries();          final Optional&lt;Salary&gt; result = latestSalaries                 .stream()                 .filter(sal -&gt; sal.getEmployeeId().equals(salary1.getEmployeeId())).findFirst();          Assert.assertTrue(result.isPresent());          Assert.assertEquals(\"The salary id should match with latest salary\", salary2.getId(), result.get().getId());         Assert.assertEquals(salary2.getSalary(), result.get().getSalary());         Assert.assertEquals(salary2.getFromDate(), result.get().getFromDate());         Assert.assertEquals(salary2.getToDate(), result.get().getToDate());     } }   checkout the Commit History on github   ","categories": ["random-jpa"],
        "tags": [],
        "url": "https://kuros.in/random-jpa/2019/01/rjpa-2-integration/",
        "teaser": null
      },{
        "title": "Random-JPA Integration",
        "excerpt":"As we have already setup an application, we will go ahead to add latest random-JPA dependency    Just add the dependency to your pom.xml, at the time writing this article latest version is 1.0.3          &lt;dependency&gt;             &lt;groupId&gt;com.github.kuros&lt;/groupId&gt;             &lt;artifactId&gt;random-jpa&lt;/artifactId&gt;             &lt;version&gt;1.0.3&lt;/version&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;   Problem Statement  Let’s say we want to write a query to fetch the latest salaries each employee.   Schema relation:      So our sql query will look like this:  select * from salaries s where not exists(select 1 from salaries s2 where s.emp_no = s2.emp_no and s.from_date &lt; s2.from_date and s.to_date &lt; s2.to_date );                        id       emp_no       salary       from_date       to_date                       3       10001       88958       2002-06-22       9999-01-01                 6       10002       72527       2001-08-02       9999-01-01                 8       10003       43311       2001-12-01       9999-01-01                 12       10004       74057       2001-11-27       9999-01-01                 14       10005       59755       2001-08-02       9999-01-01           Adding JPA Repository  package in.kuros.randomjpa.blogexample.repository;  import in.kuros.randomjpa.blogexample.entity.Salary; import org.springframework.data.jpa.repository.Query; import org.springframework.data.repository.PagingAndSortingRepository; import org.springframework.data.rest.core.annotation.RepositoryRestResource; import org.springframework.data.rest.core.annotation.RestResource;  import java.util.List;  @RepositoryRestResource(collectionResourceRel = \"salary\", path = \"salary\") public interface SalaryRepository extends PagingAndSortingRepository&lt;Salary, Integer&gt; {      @RestResource(path = \"latest\")     @Query(\"FROM Salary s WHERE NOT EXISTS (select 1 FROM Salary s2 WHERE s.employeeId = s2.employeeId and s2.fromDate &lt; s.fromDate and s2.toDate &lt; s.toDate) \")     List&lt;Salary&gt; findLatestSalaries(); }   Now we access the service using the endpoint   http://localhost:8080/salary/search/latest   you will get response as:  {   \"_embedded\" : {     \"salary\" : [ {       \"employeeId\" : 10001,       \"salary\" : 85112,       \"fromDate\" : \"2000-06-22\",       \"toDate\" : \"2001-06-22\",       \"_links\" : {         \"self\" : {           \"href\" : \"http://localhost:8080/salary/1\"         },         \"salaries\" : {           \"href\" : \"http://localhost:8080/salary/1\"         }       }     }, {       \"employeeId\" : 10002,       \"salary\" : 69366,       \"fromDate\" : \"1999-08-03\",       \"toDate\" : \"2000-08-02\",       \"_links\" : {         \"self\" : {           \"href\" : \"http://localhost:8080/salary/4\"         },         \"salaries\" : {           \"href\" : \"http://localhost:8080/salary/4\"         }       }     }, {       \"employeeId\" : 10003,       \"salary\" : 43699,       \"fromDate\" : \"2000-12-01\",       \"toDate\" : \"2001-12-01\",       \"_links\" : {         \"self\" : {           \"href\" : \"http://localhost:8080/salary/7\"         },         \"salaries\" : {           \"href\" : \"http://localhost:8080/salary/7\"         }       }     }, {       \"employeeId\" : 10004,       \"salary\" : 67096,       \"fromDate\" : \"1998-11-28\",       \"toDate\" : \"1999-11-28\",       \"_links\" : {         \"self\" : {           \"href\" : \"http://localhost:8080/salary/9\"         },         \"salaries\" : {           \"href\" : \"http://localhost:8080/salary/9\"         }       }     }, {       \"employeeId\" : 10005,       \"salary\" : 60098,       \"fromDate\" : \"2000-08-02\",       \"toDate\" : \"2001-08-02\",       \"_links\" : {         \"self\" : {           \"href\" : \"http://localhost:8080/salary/13\"         },         \"salaries\" : {           \"href\" : \"http://localhost:8080/salary/13\"         }       }     } ]   },   \"_links\" : {     \"self\" : {       \"href\" : \"http://localhost:8080/salary/search/latest\"     }   } }   But something is wrong, this endpoint is returning incorrect values, eg. Employee 10001 has salary as 85112 but as per our earlier query it should be 88958.         There is a bug in our query, that’s why we need integration tests to validate our queries.   Time to write test   Earlier we had mainly two option either we had fixed employee data backup against which the test suite runs, but there were high chances that the data corruption leading to test failures.   Or, developer maintains test fixtures responsible for creating relevant data, but maintaining relationship was the real pain.   Random-JPA in Action   Lets start by writing a simple test   package in.kuros.randomjpa.blogexample.repository;  import com.github.kuros.random.jpa.Database; import com.github.kuros.random.jpa.JPAContext; import com.github.kuros.random.jpa.JPAContextFactory; import com.github.kuros.random.jpa.persistor.model.ResultMap; import com.github.kuros.random.jpa.types.Entity; import in.kuros.randomjpa.blogexample.entity.Salary; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.transaction.annotation.Transactional;  import javax.persistence.EntityManager; import java.util.List; import java.util.Optional;  @RunWith(SpringRunner.class) @SpringBootTest public class SalaryRepositoryTest {      @Autowired private EntityManager entityManager;     @Autowired private SalaryRepository salaryRepository;      @Test @Transactional     public void shouldTestForFetchingSalaryRecordForOnlyOneEntry() {         final JPAContext jpaContext = JPAContextFactory.newInstance(Database.MY_SQL, entityManager)                 .generate();          final ResultMap resultMap = jpaContext.createAndPersist(Entity.of(Salary.class));         resultMap.print(System.out::println);          final Salary salary = resultMap.get(Salary.class);          final List&lt;Salary&gt; latestSalaries = salaryRepository.findLatestSalaries();          final Optional&lt;Salary&gt; result = latestSalaries                 .stream()                 .filter(sal -&gt; sal.getId().equals(salary.getId())).findFirst();          Assert.assertTrue(result.isPresent());         Assert.assertEquals(salary.getSalary(), result.get().getSalary());         Assert.assertEquals(salary.getFromDate(), result.get().getFromDate());         Assert.assertEquals(salary.getToDate(), result.get().getToDate());     } }  The test passed and it prints below output:  └── *ROOT*     └── in.kuros.randomjpa.blogexample.entity.Employees|0 [empNo: 10016]         └── in.kuros.randomjpa.blogexample.entity.Salaries|0 [id: 15]         Understanding test components   In the first line of test  final JPAContext jpaContext = JPAContextFactory.newInstance(Database.MY_SQL, entityManager)                 .generate();  We generated JPAContext using the factory, we provided the database type (in this case MySQL) and the entity manager.   next we told jpaContext to create an entry for Salary  final ResultMap resultMap = jpaContext.createAndPersist(Entity.of(Salaries.class));   Just for auditing/debugging purpose, we printed the hierarchy created by  resultMap.print(System.out::println);  which prints  └── *ROOT*     └── in.kuros.randomjpa.blogexample.entity.Employees|0 [empNo: 10016]         └── in.kuros.randomjpa.blogexample.entity.Salaries|0 [id: 15]  Under the hood, random-jpa has created new employee (id: 10016) &amp; salary (id: 15) record for respective employee.   Once the record is created, random-jpa returns a resultMap which consist of all the entities which has been created, to access the entity you simply get from result map  final Salary salary = resultMap.get(Salary.class);   And you can use this test data for writing your tests.   ","categories": ["random-jpa"],
        "tags": [],
        "url": "https://kuros.in/random-jpa/2019/01/rjpa-1-integration/",
        "teaser": null
      },{
        "title": "Setup database & spring boot application",
        "excerpt":"Before we start with Random-JPA, we need to simulate an application. I will be creating a simple spring boot application using MySql as my database for this purpose.   If you want to skip, download the latest code zip and proceed to the next tutorial.   Next task is to setup our spring project, we will create a maven project with the given pom dependencies  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;     &lt;groupId&gt;in.kuros.randomjpa&lt;/groupId&gt;     &lt;artifactId&gt;blog-example&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;name&gt;blog-example&lt;/name&gt;     &lt;description&gt;Demo project for Random-JPA&lt;/description&gt;      &lt;properties&gt;         &lt;java.version&gt;1.8&lt;/java.version&gt;     &lt;/properties&gt;      &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;mysql&lt;/groupId&gt;             &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;             &lt;scope&gt;runtime&lt;/scope&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;  &lt;/project&gt;         Create a spring boot application   package in.kuros.randomjpa.blogexample;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class BlogExampleApplication {      public static void main(final String[] args) {         SpringApplication.run(BlogExampleApplication.class, args);     }  }   Next step is to configure spring boot with mysql datasource. Create a application.properties in your resources folder  spring.datasource.url=jdbc:mysql://localhost:3306/employees spring.datasource.username=root spring.datasource.password=passwd  Let us create employee table in MySql:  CREATE DATBASE employees; USE employees;  CREATE TABLE employee (                          emp_no      INT             NOT NULL AUTO_INCREMENT,                          birth_date  DATE            NOT NULL,                          first_name  VARCHAR(14)     NOT NULL,                          last_name   VARCHAR(16)     NOT NULL,                          gender      ENUM ('M','F')  NOT NULL,                          hire_date   DATE            NOT NULL,                          PRIMARY KEY (emp_no) );   Let’s respective entity class in our application:   @Entity @Table(name = \"employee\") public class Employee {      @Id     @Column(name = \"emp_no\")     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Integer empNo;      @Basic     @Column(name = \"birth_date\")     private LocalDate birthDate;      @Basic     @Column(name = \"first_name\")     private String firstName;      @Basic     @Column(name = \"last_name\")     private String lastName;      @Basic     @Column(name = \"gender\")     @Convert(converter = Gender.GenderConverter.class)     private Gender gender;      @Basic     @Column(name = \"hire_date\")     private LocalDate hireDate;      // Getters &amp; Setters ... }          Create Employee Repository  Next step is to add a repository to access data, for now we will just add repository for Employee   Creating spring data repository for entity is very easy, you just need to extend Repository interface. Here we are using PagingAndSortingRepository, you just need to specify Entity and Id type and you are done.  public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employees, Integer&gt; { }   Next we want to expose the data through rest endpoint, so will will user spring-data-rest here by adding @RepositoryRestResource annotation to our repository. so our repository looks like   package in.kuros.randomjpa.blogexample.repository;  import in.kuros.randomjpa.blogexample.entity.Employees; import org.springframework.data.repository.PagingAndSortingRepository; import org.springframework.data.rest.core.annotation.RepositoryRestResource;  @RepositoryRestResource(collectionResourceRel = \"employee\", path = \"employee\") public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employees, Integer&gt; { }   Your base application is ready to serve data, just start the application and hit the endpoint  http://localhost:8080/employee  you will get this response on your browser  {   \"_embedded\" : {     \"employee\" : [ {       \"birthDate\" : \"1953-09-02\",       \"firstName\" : \"Georgi\",       \"lastName\" : \"Facello\",       \"gender\" : null,       \"hireDate\" : \"1986-06-26\",       \"_links\" : {         \"self\" : {           \"href\" : \"http://localhost:8080/employee/10001\"         },         \"employees\" : {           \"href\" : \"http://localhost:8080/employee/10001\"         }       }     }, {       \"birthDate\" : \"1964-06-02\",       \"firstName\" : \"Bezalel\",       \"lastName\" : \"Simmel\",       \"gender\" : null,       \"hireDate\" : \"1985-11-21\",       \"_links\" : {         \"self\" : {           \"href\" : \"http://localhost:8080/employee/10002\"         },         \"employees\" : {           \"href\" : \"http://localhost:8080/employee/10002\"         }       }     } ]   },   \"_links\" : {     \"first\" : {       \"href\" : \"http://localhost:8080/employee?page=0&amp;size=2\"     },     \"self\" : {       \"href\" : \"http://localhost:8080/employee{&amp;sort}\",       \"templated\" : true     },     \"next\" : {       \"href\" : \"http://localhost:8080/employee?page=1&amp;size=2\"     },     \"last\" : {       \"href\" : \"http://localhost:8080/employee?page=7&amp;size=2\"     },     \"profile\" : {       \"href\" : \"http://localhost:8080/profile/employee\"     }   },   \"page\" : {     \"size\" : 2,     \"totalElements\" : 15,     \"totalPages\" : 8,     \"number\" : 0   } }         Sample Database Schema  The MySQL sample database schema consists of the following tables:     Employees: stores employee’s data.   Departments: stores department details.   dept_manager: store manager of each department.   dept_emp: store employees under each department.   titles: store the titles of each employee.   salaries: store the salaries of each employee.   customer: store customer’s data.   play_group: store the list of play groups. (both employee &amp; external customers can join the group).   play_group_member: store the list of member for each group.      Download base application  Till now we have only added entity mapping.   We have a total of 15 employees in this database. So this request give two employee details with links to fetch rest of records under _link   Congrats you have your first app running.   Now as have a base application to work with, we can proceed with exploring random-JPA.   ","categories": ["random-jpa"],
        "tags": ["spring-boot","spring-data-jpa","spring-data-rest"],
        "url": "https://kuros.in/random-jpa/2019/01/1-data-setup/",
        "teaser": null
      },{
        "title": "Why Random-JPA?",
        "excerpt":"In today’s software world, testing is treated as important as the production code.   The products are moving towards the goal of continuous delivery. And the prerequisite for achieving this goal is to have a complete automation suite.   Testing Java code is fairly easy as a developer have many tools available to achieve it, such as junit, testng, mockito. But when it comes to testing SQL queries a developer faces a lot of problems, and spends a lot of time just to create data set in order to test the queries. In most of the scenarios it takes more time to write test than writing the production code.   To list some of the main challenges a developer has.      Know the relationship between tables.   Spends a lot of time creating test fixtures for each entity.   Management/Maintenance of relationship in complex data scenario.   Rewriting a lot of fixture if a new entity is introduced in the hierarchy.   A developer finds hard to create data if there is many joined tables.   Creating random object for unit testing.         Random-JPA was created as a lightweight utility to help developers create test data with minimum configuration. Random-JPA takes care of the relationship between tables and creates a hierarchy for all the parent entities. When using this utility a developer, will just have to specify the list of all the entities which he wants to create. Its random-JPA’s job to manage and create all the entities. It provides easy access to all the entities created and prints all the.   A typical project will consist of hundreds of entities, thousands of queries and tens of models, and your test should focus on all the data conditions, rather focusing on the conditions, developer spends all his efforts and time in just creating a data set, in this process, miss out to test critical data condition. You can utilize random-JPA to create random data for both unit &amp; integration tests.   This approach makes sure that every time we are working with integration test we will have a complete, new set of data to work with, reducing the chances of data corruption.   Nothing wastes more time than to manage dependency of entities and create random data and persist it to database.   And so Random-JPA was born…  ","categories": ["random-jpa"],
        "tags": [],
        "url": "https://kuros.in/random-jpa/2019/01/1-birth/",
        "teaser": null
      },{
        "title": "gRPC & Java",
        "excerpt":"Google released gRPC as the new open source framework in the year 2015, since then it has changing the way data is exchanged between services across multiple data centers.   If you looking to build a truly language independent micro service which is reliable, high performing, easily scalable in distributed environment. Then definitely gRPC must be your choice.   What is gRPC?   In gRPC, a client application can directly call server methods as if they are local to the client. This makes developer’s task easy to create distributed services.      To put it simply, You create a prototype of a service with its request &amp; response, share it across server &amp; client and they generate respective methods and implement them, now client invokes the method with request which is transferred to server, the method executes on server and returns the response back to client, but at client’s end it would seem as working with a local method.         In the real world, the biggest challenge is handling database in micro services, having a distributed persistence layer could work wonders.   Core Feature   Some of the important features of gRPC:      It support 10+ languages, you can write your service in java and even a python client will be able to access it.   It uses http 2 protocol, its highly efficient for working with large volume of data.   It provides are very simple service declaration, easy to understand.   It support bidirectional streams.   It provides lot of plugins such as authentication, tracing, load balancing &amp; health check.   Maven Dependencies  Lets add grpc dependencies:       &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.grpc&lt;/groupId&gt;             &lt;artifactId&gt;grpc-all&lt;/artifactId&gt;             &lt;version&gt;1.18.0&lt;/version&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;  Define Service   Let us create a simple calculator service to add two value:   We will start by defining a method with parameters and return value, but this has to be a prototype.   We do this by creating .proto file using protocol buffers, there are used to describe messages.   So we create calculator.proto under /src/main/proto   syntax = \"proto3\"; //this directs compiler to use version 3  option java_multiple_files = true; //we want generate different java files after compilation. By default all the classes are generated in a single file. package in.kuros.grpc; // defines the package structure of generated classes.  //request payload message OperandRequest {     int32 X = 1; // message with type, along with tag: 1     int32 Y = 2; // tag: 2 }  //response payload message AddResponse {     int64 result = 1; }  // service contract service Calculator {     rpc add(OperandRequest) returns (AddResponse); // method name: add, parameter type: OperandRequest, response type: AddResponse  }  A unique number needs to be assigned to each attribute, called as the tag. This tag is used by the protocol buffer to represent the attribute instead of using the attribute name. So, unlike JSON where we would pass attribute name X every single time, protocol buffer would use the number 1 to represent X. Response payload definition is similar to the request.         So at the end after generation, we will have three classes (in terms of java), Operands, AddResponse &amp; Calculator which takes operands and returns addResponse;   Generating class files for java.   Now we pass the HelloService.proto file to the protocol buffer compiler protoc to generate the Java files. There are multiple ways to trigger this.   Protocol Buffer compiler   Download the compiler, and follow readme.txt   Use the command to generate code  $ protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/proto/calculator.proto   Maven compiler plugin   You don’t want to execute command to generate code every time, so we will make use of maven plugin to execute at build time       &lt;build&gt;         &lt;extensions&gt;             &lt;extension&gt;                 &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;                 &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;1.6.1&lt;/version&gt;             &lt;/extension&gt;         &lt;/extensions&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;0.6.1&lt;/version&gt;                 &lt;configuration&gt;                     &lt;protocArtifact&gt;                         com.google.protobuf:protoc:3.5.1:exe:${os.detected.classifier}                     &lt;/protocArtifact&gt;                     &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;                     &lt;pluginArtifact&gt;                         io.grpc:protoc-gen-grpc-java:1.18.0:exe:${os.detected.classifier}                     &lt;/pluginArtifact&gt;                 &lt;/configuration&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;goals&gt;                             &lt;goal&gt;compile&lt;/goal&gt;                             &lt;goal&gt;compile-custom&lt;/goal&gt;                         &lt;/goals&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;   The os-maven-plugin extension/plugin generates various useful platform-dependent project properties like ${os.detected.classifier}          Generated files   Once you the run the generation, some key files will be generated under /target/generated-sources/protobuf     OperandRequest.java - contains the OperandRequest definition.   AddResponse.java - contains the AddResponse definition.   CalculatorGrpc.java - this contains abstract inner class CalculatorImplBase which provides an implementation wrapper.   Server Side Implementation   Now its time write the addition logic on the server side. so we will create an implementation class CalculatorImpl which will extend CalculatorImplBase and provide implementation.   import in.kuros.grpc.AddResponse; import in.kuros.grpc.CalculatorGrpc.CalculatorImplBase; import in.kuros.grpc.OperandRequest; import io.grpc.stub.StreamObserver;  public class CalculatorImpl extends CalculatorImplBase {      @Override     public void add(final OperandRequest request, final StreamObserver&lt;AddResponse&gt; responseObserver) {         final long sum = request.getX() + request.getY();          final AddResponse addResponse = AddResponse                 .newBuilder()                 .setResult(sum)                 .build();          try {             System.out.println(\"Sleeping to 5 sec\");             Thread.sleep(5 * 1000);         } catch (InterruptedException e) {             e.printStackTrace();         }         responseObserver.onNext(addResponse);         responseObserver.onCompleted();     } }  We have provide a sleep of 5 sec to simulate long taking operations.   start the gRPC server  Next, we need to start the gRPC server to listen for incoming requests:   import io.grpc.Server; import io.grpc.ServerBuilder;  public class GrpcServer {      public static void main(String[] args) throws Exception {         final Server server = ServerBuilder.forPort(8080)                 .addService(new CalculatorImpl())                 .build();          server.start();         server.awaitTermination();     } }   So, here we have created a serve to listen at port 8080 for incoming request, registered our calculator service. In our example, we will call awaitTermination() to keep the server running in foreground blocking the prompt.          Creating a client   First we need to create a gRPC channel for our stub, specifying the server address and port we want to connect to.   We use a ManagedChannelBuilder to create the channel.  ManagedChannel channel = ManagedChannelBuilder.forAddress(\"localhost\", 8080)                 .usePlaintext()                 .build();  Now we can use the channel to create our stubs using the newStub and newBlockingStub methods provided in the RouteGuideGrpc class we generated from our .proto.   making sync calls   We create a blocking stub      final CalculatorGrpc.CalculatorBlockingStub blockingStub = CalculatorGrpc.newBlockingStub(channel);      System.out.println(\"Making blocking call\");     final AddResponse blockResponse = blockingStub.add(OperandRequest.newBuilder().setX(10).setY(20).build());     System.out.println(\"blocking call result: \" + blockResponse.getResult());   making async calls   We use newStub method to make aysnc calls, but we need to provide a StreamObserver implementation to it.       final CalculatorGrpc.CalculatorStub asyncStub = CalculatorGrpc.newStub(channel);              StreamObserver&lt;AddResponse&gt; streamObserver = new StreamObserver&lt;AddResponse&gt;() {         public void onNext(final AddResponse addResponse) {             System.out.println(\"async call result: \" + addResponse.getResult());         }              public void onError(final Throwable throwable) {             System.out.println(throwable);         }              public void onCompleted() {             System.out.println(\"Async call stopped listening\");         }     };       System.out.println(\"Making blocking call\");     asyncStub.add(OperandRequest.newBuilder().setX(10).setY(20).build(), streamObserver);     System.out.println(\"Async invoked\" + blockResponse.getResult());      channel.awaitTermination(10, TimeUnit.SECONDS);          complete client code:  import in.kuros.grpc.AddResponse; import in.kuros.grpc.CalculatorGrpc; import in.kuros.grpc.OperandRequest; import io.grpc.ManagedChannel; import io.grpc.ManagedChannelBuilder; import io.grpc.stub.StreamObserver;  import java.util.concurrent.TimeUnit;  public class GrpcClient {      public static void main(String[] args) throws InterruptedException {         ManagedChannel channel = ManagedChannelBuilder.forAddress(\"localhost\", 8080)                 .usePlaintext()                 .build();          final CalculatorGrpc.CalculatorBlockingStub blockingStub = CalculatorGrpc.newBlockingStub(channel);          System.out.println(\"Making blocking call\");         final AddResponse blockResponse = blockingStub.add(OperandRequest.newBuilder().setX(10).setY(20).build());         System.out.println(\"blocking call result: \" + blockResponse.getResult());           final CalculatorGrpc.CalculatorStub asyncStub = CalculatorGrpc.newStub(channel);          StreamObserver&lt;AddResponse&gt; streamObserver = new StreamObserver&lt;AddResponse&gt;() {             public void onNext(final AddResponse addResponse) {                 System.out.println(\"async call result: \" + addResponse.getResult());             }              public void onError(final Throwable throwable) {                 System.out.println(throwable);             }              public void onCompleted() {                 System.out.println(\"Async call stopped listening\");             }         };           System.out.println(\"Making blocking call\");         asyncStub.add(OperandRequest.newBuilder().setX(10).setY(20).build(), streamObserver);         System.out.println(\"Async invoked\" + blockResponse.getResult());          channel.awaitTermination(10, TimeUnit.SECONDS);      } }   Next, we need to create a stub which we’ll use to make the actual remote call to hello(). The stub is the primary way for clients to interacts with the server. When using auto generate stubs, the stub class will have constructors for wrapping the channel.   Conclusion   In this post we have learned how to work with a gRPC Server/Client in java. As usual find the complete code   ","categories": ["gRPC"],
        "tags": [],
        "url": "https://kuros.in/grpc/2019/01/grpc/",
        "teaser": null
      },{
        "title": "gRPC Authentication in Java",
        "excerpt":"Setting up gRPC is great and simple but what about its security. how hard it is? Lets see.   Generating Certificates &amp; Keys  Similar to http server, you can configure gRPC server communication to be encrypted, Since we are developing a local example, we will generate our own certificate(you will need certificate from Certificate Authority if you want to make your api’s public).   For this tutorial, we will use openssl to generate our certificate &amp; keys.   $ openssl req -x509 -newkey rsa:4096 -keyout src/main/resources/my-private-key.pem -out src/main/resources/my-public-key-cert.pem -days 365 -nodes -subj '/CN=localhost'   Our keys will be generated in resources folder, this key has expiration of 365 days, algorithm detail (RSA: 4096), format standard (X.509) and our server’s common name (CN) which is just a localhost in our case.   Adding certificates to gRPC server   To enable TLS on a server, a certificate chain and private key need to be specified in PEM format, which we have generated in earlier.   Private key should not be using a password   (When you are generating chain certificates, remember, the order of certificates in the chain matters: more specifically, the certificate at the top has to be the host CA, while the one at the very bottom has to be the root CA.)         For this tutorial’s purpose, we will use 8443 below to avoid needing extra permissions from the OS.   import io.grpc.Server; import io.grpc.ServerBuilder;  import java.io.File;  public class GrpcServer {      public static void main(String[] args) throws Exception {          final Server server = ServerBuilder.forPort(8443)                 .addService(new CalculatorImpl())                  //enable TLS                 .useTransportSecurity(                         getFile(\"/my-public-key-cert.pem\"), //public Key                         getFile(\"/my-private-key.pem\")) // private key                 .build();          server.start();         server.awaitTermination();     }      private static File getFile(final String fileName) {         return new File(GrpcServer.class.getResource(fileName).getFile());     } }   Let’s start the server, oops!!! we got an error:  Jan 27, 2019 4:08:22 PM io.grpc.netty.GrpcSslContexts defaultSslProvider INFO: netty-tcnative unavailable (this may be normal) java.lang.ClassNotFoundException: io.netty.internal.tcnative.SSL \tat java.net.URLClassLoader.findClass(URLClassLoader.java:381) \tat java.lang.ClassLoader.loadClass(ClassLoader.java:424) \tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) \tat java.lang.ClassLoader.loadClass(ClassLoader.java:357) \tat java.lang.Class.forName0(Native Method) \tat java.lang.Class.forName(Class.java:348) \tat io.netty.handler.ssl.OpenSsl.&lt;clinit&gt;(OpenSsl.java:81) \tat io.grpc.netty.GrpcSslContexts.defaultSslProvider(GrpcSslContexts.java:244) \tat io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:171) \tat io.grpc.netty.GrpcSslContexts.forServer(GrpcSslContexts.java:130) \tat io.grpc.netty.NettyServerBuilder.useTransportSecurity(NettyServerBuilder.java:460) \tat io.grpc.netty.NettyServerBuilder.useTransportSecurity(NettyServerBuilder.java:53) \tat in.kuros.blog.grpc.GrpcServer.main(GrpcServer.java:16)  Jan 27, 2019 4:08:22 PM io.grpc.netty.GrpcSslContexts defaultSslProvider INFO: Conscrypt not found (this may be normal) Jan 27, 2019 4:08:22 PM io.grpc.netty.GrpcSslContexts defaultSslProvider INFO: Jetty ALPN unavailable (this may be normal) java.lang.ClassNotFoundException: org/eclipse/jetty/alpn/ALPN \tat java.lang.Class.forName0(Native Method) \tat java.lang.Class.forName(Class.java:348) \tat io.grpc.netty.JettyTlsUtil.isJettyAlpnConfigured(JettyTlsUtil.java:64) \tat io.grpc.netty.GrpcSslContexts.findJdkProvider(GrpcSslContexts.java:266) \tat io.grpc.netty.GrpcSslContexts.defaultSslProvider(GrpcSslContexts.java:248) \tat io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:171) \tat io.grpc.netty.GrpcSslContexts.forServer(GrpcSslContexts.java:130) \tat io.grpc.netty.NettyServerBuilder.useTransportSecurity(NettyServerBuilder.java:460) \tat io.grpc.netty.NettyServerBuilder.useTransportSecurity(NettyServerBuilder.java:53) \tat in.kuros.blog.grpc.GrpcServer.main(GrpcServer.java:16)  Exception in thread \"main\" java.lang.IllegalStateException: Could not find TLS ALPN provider; no working netty-tcnative, Conscrypt, or Jetty NPN/ALPN available \tat io.grpc.netty.GrpcSslContexts.defaultSslProvider(GrpcSslContexts.java:258) \tat io.grpc.netty.GrpcSslContexts.configure(GrpcSslContexts.java:171) \tat io.grpc.netty.GrpcSslContexts.forServer(GrpcSslContexts.java:130) \tat io.grpc.netty.NettyServerBuilder.useTransportSecurity(NettyServerBuilder.java:460) \tat io.grpc.netty.NettyServerBuilder.useTransportSecurity(NettyServerBuilder.java:53) \tat in.kuros.blog.grpc.GrpcServer.main(GrpcServer.java:16)   Time to fix it by providing below maven dependency in your pom file:   &lt;dependency&gt;     &lt;groupId&gt;io.netty&lt;/groupId&gt;     &lt;artifactId&gt;netty-tcnative-boringssl-static&lt;/artifactId&gt;     &lt;version&gt;2.0.20.Final&lt;/version&gt; &lt;/dependency&gt;   The Server Starts.         Now let try to use our old client to execute our add method.   Old Client   import io.grpc.ManagedChannel; import io.grpc.ManagedChannelBuilder;  public class GrpcOldClient {      public static void main(String[] args) {         ManagedChannel channel = ManagedChannelBuilder.forAddress(\"localhost\", 8443)                 .usePlaintext()                 .build();          final CalculatorGrpc.CalculatorBlockingStub blockingStub = CalculatorGrpc.newBlockingStub(channel);          final AddResponse blockResponse = blockingStub.add(OperandRequest.newBuilder().setX(10).setY(20).build());         System.out.println(\"call result: \" + blockResponse.getResult());          channel.shutdown();     } }   Notice we have configured ManagedChannel as .usePlaintext(), which specifies we do not want any authentication.   When we execute the program we get an error response like:   Exception in thread \"main\" io.grpc.StatusRuntimeException: UNAVAILABLE: Network closed for unknown reason \tat io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:233) \tat io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:214) \tat io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:139) \tat in.kuros.blog.grpc.CalculatorGrpc$CalculatorBlockingStub.add(CalculatorGrpc.java:157) \tat in.kuros.blog.grpc.GrpcOldClient.main(GrpcOldClient.java:15)          SSL enabled clients   When you are using ssl certificate with the issuing authority known to the client, simply create a ManagedChannel by   // With server authentication SSL/TLS ManagedChannel channel = ManagedChannelBuilder.forAddress(\"localhost\", 443)     .build(); CalculatorGrpc.CalculatorBlockingStub blockingStub = CalculatorGrpc.newBlockingStub(channel);   But in our case we are using our custom certificates, so we need to provide SSL context to channel builder, for this we will use NettyChannelBuilder.   We will be providing our public certificate only to the client.   import io.grpc.ManagedChannel; import io.grpc.netty.GrpcSslContexts; import io.grpc.netty.NettyChannelBuilder;  import javax.net.ssl.SSLException; import java.io.File;  public class GrpcNewClient {      public static void main(String[] args) throws SSLException {          final ManagedChannel channel = NettyChannelBuilder.forAddress(\"localhost\", 8443)                 .sslContext(GrpcSslContexts                         .forClient()                         .trustManager(getFile(\"/my-public-key-cert.pem\")) // public key                         .build())                 .build();          final CalculatorGrpc.CalculatorBlockingStub blockingStub = CalculatorGrpc.newBlockingStub(channel);          System.out.println(\"Making call\");         final AddResponse blockResponse = blockingStub.add(OperandRequest.newBuilder().setX(10).setY(20).build());         System.out.println(\"call result: \" + blockResponse.getResult());          channel.shutdown();      }      private static File getFile(final String fileName) {         return new File(GrpcNewClient                 .class                 .getResource(fileName)                 .getFile());     } }   Now when we run the new client, we are able to make calls.   Conclusion   So till now we have seen, how to secure our server-client communication over gRPC. Find the code here.   ","categories": ["gRPC"],
        "tags": [],
        "url": "https://kuros.in/grpc/2019/01/grpc-authentication/",
        "teaser": null
      },{
        "title": "gRPC Authorization using Interceptors in Java",
        "excerpt":"We have secured our application with by using ssl configuration, that’s great. But its hard to authenticate which client is making the request, after all the certificate will be shared amongst all the client.   In order to recognize who is using our service, we need to store some type of authentication token. Normally, you will be validating tokens using IAM/Authentication services, but for this tutorial, I will use a simple token mechanism.   Time to take care of the authorization mechanism, provided in gRPC. We wil be using Interceptors.   Interceptors   By using Interceptors, you can intercept the execution of RPC methods on both the client and the server.   There are two types of interceptors:     Server Interceptors   Client Interceptors   Server Interceptors   As the name suggest, we are going to implement ServerInterceptor. We need to implementation interceptCall method.   import io.grpc.Metadata; import io.grpc.Metadata.Key; import io.grpc.ServerCall; import io.grpc.ServerCall.Listener; import io.grpc.ServerCallHandler; import io.grpc.ServerInterceptor; import io.grpc.Status; import io.grpc.StatusRuntimeException;  public class AuthorizationInterceptor implements ServerInterceptor {      public &lt;ReqT, RespT&gt; Listener&lt;ReqT&gt; interceptCall(final ServerCall&lt;ReqT, RespT&gt; serverCall, final Metadata metadata, final ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler) {          final String auth_token = metadata.get(Key.of(\"auth_token\", Metadata.ASCII_STRING_MARSHALLER));          if (auth_token == null || !auth_token.equals(\"valid_token\")) {             throw new StatusRuntimeException(Status.FAILED_PRECONDITION);         }          return serverCallHandler.startCall(serverCall, metadata);     } }  Its a simple validation, which expects auth_token to be present and it should be equal to ‘valid_token’         Add to our server configuration.   import io.grpc.Server; import io.grpc.ServerBuilder;  public class GrpcServer {      public static void main(String[] args) throws Exception {         final Server server = ServerBuilder.forPort(8080)                 .addService(new CalculatorImpl())                 .intercept(new AuthorizationInterceptor())                 .build();          server.start();         server.awaitTermination();     } }   Now if we run the client, we will get an error:   Exception in thread \"main\" io.grpc.StatusRuntimeException: FAILED_PRECONDITION \tat io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:233) \tat io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:214) \tat io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:139) \tat in.kuros.blog.grpc.CalculatorGrpc$CalculatorBlockingStub.add(CalculatorGrpc.java:157) \tat in.kuros.blog.grpc.client.GrpcClient.main(GrpcClient.java:19)   Now to setup our client.   Client Interceptors   We will create a client interceptor. Add auth_token.   import io.grpc.CallOptions; import io.grpc.Channel; import io.grpc.ClientCall; import io.grpc.ClientInterceptor; import io.grpc.ForwardingClientCall; import io.grpc.Metadata; import io.grpc.Metadata.Key; import io.grpc.MethodDescriptor;  public class AuthTokenProvideInterceptor implements ClientInterceptor {      public &lt;ReqT, RespT&gt; ClientCall&lt;ReqT, RespT&gt; interceptCall(final MethodDescriptor&lt;ReqT, RespT&gt; methodDescriptor, final CallOptions callOptions, final Channel channel) {         return new ForwardingClientCall.SimpleForwardingClientCall&lt;ReqT, RespT&gt;(channel.newCall(methodDescriptor, callOptions)) {             @Override             public void start(final Listener&lt;RespT&gt; responseListener, final Metadata headers) {                 headers.put(Key.of(\"auth_token\", Metadata.ASCII_STRING_MARSHALLER), \"valid_token\");                 super.start(responseListener, headers);             }         };     } }   Run the client and you are done. Find the code here.   ","categories": ["gRPC"],
        "tags": [],
        "url": "https://kuros.in/grpc/2019/01/grpc-interceptors/",
        "teaser": null
      },{
        "title": "Kubernetes(k8s) Basics",
        "excerpt":"So we all have heard of docker, it has taken industry by a storm and completely changed the way application are deployed to servers, I mean having independent environment for every app is great, everyone loves it. But it also created challenges around managing deployments.   Though there have been many container management tools such as Docker Swarm, CoreOs rkt, Mesos etc. But Kubernetes has emerged as favorite.   Let take a look, what makes Kubernetes such an important player in recent times.   If you are familiar with the basic nomenclature, you can skip this tutorial.   What is Kubernetes(k8s)   Kubernetes (k8s) is an open-source system for automating deployment, scaling, and management of containerized applications.   Basically Kubernetes is a container orchestrator, that helps you with the deployment, lifecycle &amp; management of the container. It provides a set of services and deployment configuration for you to work with and hides all the complexity of infrastructure management such as cpu, memory, storage etc.   K8s is directed towards reaching desired state, it could be deployment of set of webservices, database engines, caching solutions.   Benefits of using Kubernetes   Although there are many things to talk about, here are few main points I would like to mention.     Speed of Deployment: Deployment on k8s is fast, I mean super fast. you provide the configuration, and it would bring all the application to the desired state.   Version Management: Have you had troubles, deploying new version of your app to server, k8s helps you do that simply without any downtime, and you can revert to your original state if anything goes wrong, almost instantly.   Ability to recover: If anything goes wrong k8s engine takes care of bringing back to the desired state, for example, if you wanted 3 instances of your service to be running at all times, and something goes wrong and instance is down, k8s would start a new instance so at the end of the day, you will have your application up &amp; running all the time.   Hides complexity of cluster: Setting up application cluster is a big pain for devops, but with k8s, its very easy.         Operating principles   So k8s works on a very simple principle, always maintain the desired state.You provide a desired state config, and k8s will download image, run it, and will maintain the required number of instances.   It provides controllers(Control Loops), which has sole purpose to monitor and bring container to its desired state.   There is an api server, which is the only way to communicate with k8s cluster, its core hub of all the information. You can interact with api server using rest api call or a command line tool called kubectl.   Building Blocks (Key Players)   Lets take a look at some of the building blocks of k8s:      Pods  Pod forms the basic unit. It can contain one or more containers running inside it. Pods are ephemeral, i.e. once a pod is dead its not resurrected, if k8s find that the pod has died, it will start a complete new pod.   Pods ensures the atomicity, means either the pod is available or not its not, there is no state as starting or dying, its simply up or down. Each pod maintains the health of all the apps, if any app is down, k8s drops the whole pod and starts a completely new one.         Controllers   Controllers are responsible for maintaining the state of the pods, number of replica’s, deployment state etc. It will monitor the state of Pod and also the health of all the apps inside a pod. Controllers also manages the change in replica-sets &amp; container versions.   Services   Services adds persistency to k8s engine, it forms the networking abstraction to pods. For e.g. if a pod dies and a new pod is generated in its place, it IP/hostname etc might change, so k8s service forms the facade, and takes care of IP &amp; DNS, it dynamically updates its mapping.   Next important task, these services take care are scalability and load balancing.   Storage   In the earlier version of k8s, volume was directly mapped to the containers. This created a very tight coupling between volume &amp; pods.   But now k8s engine has come up with the concept of Persisted Volumes. It is defined at the cluster level, so whenever a new pod comes up, it claims the desired store required by it from this Persisted Volume, this is called Persisted Volume Chains.         Kubernetes Cluster  Now that we have seen basic building blocks, lets focus on how the k8s cluster is organized. Each custer comprises of mainly three components.      Master  Only a single master can reside in one cluster. Master is one which co-ordinates cluster operation, monitoring and scheduling. It is the primary data access point, and provides administration of the cluster.   A master is composed of the following components:      Api Server   Api Server is the communication hub of the cluster, it completely stateless, and all the configuration are passed into k8s cluster through api server. Its a simple restful endpoint, whenever it receives the request, it validates and passes the information to Cluster Store(etcd)         Cluster Store  As the name suggests, a Cluster Store, persists the values as key-value pair in etcd. Cluster Store also proves watcher on keys for any change in value.   Scheduler  The Job of scheduler is to select nodes based on prod requirement, suppose a pod requires 4gb ram to run, scheduler will decide on which is the best suited node for it within the multi node cluster.   It also keeps a watch on Api Server for any changes and drives the current state to the desire state. It evaluates the resources available on nodes, and schedules the pod accordingly, we can also provide constraints, that I want two pods to be deployed on same node or different nodes.   Controller Management  It manages the lifecycle of Controllers, and drives the current state to the desired state. Runs the controller loops (mentioned above), watches and update the api server. It also maintains the replica set.   kubectl  Although kubectl is not the part of master, but it is the command line tool which talks with the api server (connects to master).         Node   Node is the place where the pods run, its the responsibility of node to monitor pods state as well as application health, the main component that runs on all the nodes are kubelet, kubeproxy, container-runtime &amp; networking.      We will take a closer look at the features of each component in detail.   Kubelet   Kubelet handles the pod lifecycle, reports the node &amp; pods state, monitors api server for any changes and keeps probing the pod for liveliness.   Kube-proxy  Kube-proxy takes care of the networking, inside a node, a pod can die and new pod is generated in place, somehow the k8s needs to mechanism to connect to these newly connected pods, and direct the traffic to it. This is done by Kube-proxy.   Kube-Proxy maintains an ip-table, mapping of all the ip’s of respective pods, when a pod is added or deleted, this ip-table is updated by kube-proxy.   In addition to this kube-proxy is also manages routing and load balancing between the pods. It also listens to api-server in any change to the configuration.   Container-runtime  This the actual runtime environment, it will download and run the images. By default, k8s support Docker as container, but you can use any container implementation which implements Container Runtime Interface.         Networking   Before we conclude, let see how k8s manages the networking. There are few rules to which k8s adhere:     No node should implement Network Address Translation (NAT).   All Pods should communicate with all the nodes in cluster.   All the nodes should communicate with all the pods in cluster.   K8s uses localhost as hostname to communicate between apps within the same pod.   K8s uses bridge network to communicate between different pods but within same node.   k8s uses IP’s to communicate between different nodes within a cluster.   Finally, k8s uses kube-proxy to connect cluster with external service.   Conclusion   So, till now we have seen basic building blocks for kubernetes, we spent time getting to know main keywords. Next we will be looking at how to install kubernetes.   ","categories": ["kubernetes"],
        "tags": [],
        "url": "https://kuros.in/kubernetes/2019/01/kubernetes-basics/",
        "teaser": null
      },{
        "title": "Running First Kubernetes Pod on Mac (Windows)",
        "excerpt":"All you need is 60 minutes to run your first application in Kubernetes, in this post we will install docker with kubernetes on our local machine, create a simple app and its docker image and finally deploy it on our kubernetes cluster.   Note: The minimum docker desktop version required for kubernetes is 18.09.1   Installing Docker Desktop  First thing first, we need to install Docker Desktop, download the latest version   Installation of docker is easy, I will installing docker on Mac (for Windows, process is similar). Please follow the instruction provided on site and download the installer.   Install it  Double-click Docker.dmg to start the install process.   When the installation completes and Docker starts, the whale in the top status bar shows that Docker is running, and accessible from a terminal.      Verify   Open command line terminal, and try if docker is installed.   $ docker version Client: Docker Engine - Community  Version:           18.09.1  API version:       1.39  Go version:        go1.10.6  Git commit:        4c52b90  Built:             Wed Jan  9 19:33:12 2019  OS/Arch:           darwin/amd64  Experimental:      false  Server: Docker Engine - Community  Engine:   Version:          18.09.1   API version:      1.39 (minimum version 1.12)   Go version:       go1.10.6   Git commit:       4c52b90   Built:            Wed Jan  9 19:41:49 2019   OS/Arch:          linux/amd64   Experimental:     true         Enable Kubernetes  Open Docker preferences/settings, go to Kubernetes tab(only available after version 18.09.1) &amp; enable it.      Once the Kubernetes is started, you will see green indicator for both k8s &amp; docker.      Congratulations !!! you have a single node cluster ready.   Exploring the cluster  Docker Desktop also install kubectl at location /usr/local/bin/kubectl, we will verify that we have a running node.   Use the below command get the running nodes  $ kubectl get nodes NAME                 STATUS   ROLES    AGE   VERSION docker-for-desktop   Ready    master   12m   v1.10.11   We will check for running services  $ kubectl get services NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   12m   We can also verify cluster information  $ kubectl cluster-info Kubernetes master is running at https://localhost:6443 KubeDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy  To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.         But when we try access the url in browser, we get an authentication failure.  https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy  {   \"kind\": \"Status\",   \"apiVersion\": \"v1\",   \"metadata\": {},   \"status\": \"Failure\",   \"message\": \"services \\\"kube-dns:dns\\\" is forbidden: User \\\"system:anonymous\\\" cannot get services/proxy in the namespace \\\"kube-system\\\"\",   \"reason\": \"Forbidden\",   \"details\": {     \"name\": \"kube-dns:dns\",     \"kind\": \"services\"   },   \"code\": 403 }   It looks like we’re being blocked by the cluster’s RBAC policies. The system:anonymous user is being prevented from listing the namespaces in the cluster.   We need to create a clusterrolebinding that adds the system:anonymous user to the cluster-admin role.   $ kubectl create clusterrolebinding cluster-system-anonymous --clusterrole=cluster-admin --user=system:anonymous   Now if you will access  https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy  You will get response something like this, it gives all the details related to the running service  {   \"kind\": \"Service\",   \"apiVersion\": \"v1\",   \"metadata\": {     \"name\": \"kube-dns\",     \"namespace\": \"kube-system\",     \"selfLink\": \"/api/v1/namespaces/kube-system/services/kube-dns\",     \"uid\": \"c25ab536-2b7a-11e9-a713-025000000001\",     \"resourceVersion\": \"175\",     \"creationTimestamp\": \"2019-02-08T08:23:05Z\",     \"labels\": {       \"k8s-app\": \"kube-dns\",       \"kubernetes.io/cluster-service\": \"true\",       \"kubernetes.io/name\": \"KubeDNS\"     }   },   \"spec\": {     \"ports\": [       {         \"name\": \"dns\",         \"protocol\": \"UDP\",         \"port\": 53,         \"targetPort\": 53       },       {         \"name\": \"dns-tcp\",         \"protocol\": \"TCP\",         \"port\": 53,         \"targetPort\": 53       }     ],     \"selector\": {       \"k8s-app\": \"kube-dns\"     },     \"clusterIP\": \"10.96.0.10\",     \"type\": \"ClusterIP\",     \"sessionAffinity\": \"None\"   },   \"status\": {     \"loadBalancer\": {}   } }   So now since we have a running cluster we will create a simple app &amp; deploy it.         The Java App   We will create a simple java app which will return the IP of the machine. we will create a spring boot application.   The Pom file:  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;     &lt;groupId&gt;in.kuros.k8s&lt;/groupId&gt;     &lt;artifactId&gt;machine-ip&lt;/artifactId&gt;     &lt;version&gt;0.0.1&lt;/version&gt;     &lt;name&gt;machine-ip&lt;/name&gt;     &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;      &lt;properties&gt;         &lt;java.version&gt;1.8&lt;/java.version&gt;     &lt;/properties&gt;      &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;  &lt;/project&gt;  We will initialize Spring Boot Application:         import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class MachineIpApplication {      public static void main(final String[] args) {         SpringApplication.run(MachineIpApplication.class, args);     }  }   And are simple rest controller which returns ip of the machine.   import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.net.InetAddress; import java.net.UnknownHostException;  @RestController public class IpController {      @GetMapping(path = \"/ip\")     public ResponseModel getIp() throws UnknownHostException {         InetAddress inetAddress = InetAddress.getLocalHost();         return new ResponseModel(inetAddress.getHostAddress(), inetAddress.getHostName());     }      private class ResponseModel {         private final String ip;         private final String hostname;          public ResponseModel(final String ip, final String hostname) {             this.ip = ip;             this.hostname = hostname;         }          public String getIp() {             return ip;         }          public String getHostname() {             return hostname;         }     } }   Time to test, run the application after mvn build:   $ mvn install $ java -jar target/machine-ip-0.0.1.jar   Once the application is up, we will hit exposed rest method and it will return the ip &amp; hostname (something like this)  $ curl localhost:8080/ip {\"ip\":\"192.168.0.104\",\"hostname\":\"kuros-MacBook-Pro.local\"}   So now we have our sample application ready, time to create docker image.         Dockerfile   We will create a file named as Dockerfile in our home folder.   FROM openjdk:8-jdk-alpine COPY target/machine-ip-0.0.1.jar app.jar EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]   Let’s look at this dockerfile line by line.      Line 1: we are specifying docker to download openjdk image (tag: 8-jdk-alpine).   Line 2: copy the generated jar file to docker image with name app.jar   Line 3: We are exposing 8080 port from the container   Line 4: finally we are giving command to run the app.jar when container starts.   Building the Docker image  So we have created our dockerfile, now time to build an image.   We will user docker build command. We are provinding a tag (/machine-ip:0.0.1) using _-t_. Do not forget to add \" . \" at the end, this specifies the location of the docker file (if you are using a custom location use -f arg for file location).  $  docker build -t incrediblevicky/machine-ip:0.0.1 .  Sending build context to Docker daemon  33.46MB Step 1/4 : FROM openjdk:8-jdk-alpine  ---&gt; 792ff45a2a17 Step 2/4 : COPY target/machine-ip-0.0.1.jar app.jar  ---&gt; Using cache  ---&gt; 436597bf8464 Step 3/4 : EXPOSE 8080  ---&gt; Using cache  ---&gt; 0737665c2f88 Step 4/4 : ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]  ---&gt; Using cache  ---&gt; 62ee4df459e4 Successfully built 62ee4df459e4 Successfully tagged incrediblevicky/machine-ip:0.0.1   We can verify the image created:  $ docker images  REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE incrediblevicky/machine-ip      0.0.1               62ee4df459e4        2 hours ago         122MB         Running Docker image   To run the docker image we will use   docker run -p 8080:8080 -t incrediblevicky/machine-ip:0.0.1   Here, we are mapping 8080 port of host machine to port 8080 of docker container, and running the container by tag name.   And as expected, we can now hit “http://localhost:8080/ip”. But this time hostname and ip has changed. Its the containers ip &amp; hostname.  $ curl localhost:8080/ip  {\"ip\":\"172.17.0.2\",\"hostname\":\"38abfd9a4016\"}   Push the images to docker-hub  First we need to login to docker, just provide your docker id &amp; password when asked, in my case, my username is incrediblevicky  $ docker login  Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: incrediblevicky Password:  Login Succeeded  Once, you have successfully logged in we will push the image to docker hub. *use docker push /machine-ip:0.0.1   $ docker push incrediblevicky/machine-ip:0.0.1         Now we are ready with our setup, time for Kubernetes.   Creating Deployment descriptor for Kubernetes  Create a new yaml file. For this exercise we will use Deployment.yaml   apiVersion: apps/v1 kind: Deployment metadata:   name: machine-ip   labels:     app: machine-ip spec:   replicas: 1   template:     metadata:       name: machine-ip       labels:         app: machine-ip     spec:       containers:         - name: machine-ip           image: incrediblevicky/machine-ip:0.0.1           imagePullPolicy: IfNotPresent           ports:             - containerPort: 8080       restartPolicy: Always   selector:     matchLabels:       app: machine-ip   In this example:      A Deployment named machine-ip is created, indicated by the .metadata.name field.   The Deployment creates 1 replicated Pods, indicated by the replicas field.   The selector field defines how the Deployment finds which Pods to manage. In this case, you simply select a label that is defined in the Pod template (app: machine-ip). However, more sophisticated selection rules are possible, as long as the Pod template itself satisfies the rule.   The template field contains the following sub-fields:            The Pods are labeled app: machine-ip using the labels field.       The Pod template’s specification, or .template.spec field, indicates that the Pods run one container, machine-ip, which runs the incrediblevicky/machine-ip Docker Hub image at version 0.0.1.       Create one container and name it machine-ip using the name field       Run the incrediblevicky/machine-ip image at version 0.0.1       Open port 8080 so that the container can send and accept traffic.           To create this Deployment, run the following command:   $ kubectl create -f Deployment.yaml         Next, run kubectl get deployments. The output is similar to the following:   $ kubectl get deployments  NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE machine-ip   1         1         1            1           31s   When you inspect the Deployments in your cluster, the following fields are displayed:      NAME lists the names of the Deployments in the cluster.   DESIRED displays the desired number of replicas of the application, which you define when you create the Deployment. This is the desired state.   CURRENT displays how many replicas are currently running.   UP-TO-DATE displays the number of replicas that have been updated to achieve the desired state.   AVAILABLE displays how many replicas of the application are available to your users.   AGE displays the amount of time that the application has been running.   Running get pods should now show the new Pods:   $ kubectl get pods  NAME                          READY     STATUS    RESTARTS   AGE machine-ip-5764588bdf-rtmr4   1/1       Running   0          12m   We have successfully deployed our first app to docker, but we still can’t access the url, So we need create service.   Creating Service descriptor for Kubernetes  A Service in Kubernetes is a REST object, similar to a Pod. Like all of the REST objects, a Service definition can be POSTed to the apiserver to create a new instance. For example, suppose you have a set of Pods that each expose port 8080 and carry a label “app=machine-ip”.   Create another yaml file. For this exercise we will use Service.yaml   apiVersion: v1 kind: Service metadata:   name: machine-ip-service spec:   selector:     app: machine-ip   ports:     - port: 8080       targetPort: 8080   type: LoadBalancer   This specification will create a new Service object named “machine-ip-service” which targets TCP port 8080 on any Pod with the “app=machine-ip” label. This Service will also be assigned an IP address (sometimes called the “cluster IP”), which is used by the service proxies. The Service’s selector will be evaluated continuously and the results will be POSTed to an Endpoints object also named “machine-ip-service”.   To create this Deployment, run the following command:   $ kubectl create -f Service.yaml  service \"machine-ip-service\" created   Run the following command to verify  if Service has been created successfully.   $ kubectl get services  NAME                 TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE kubernetes           ClusterIP      10.96.0.1        &lt;none&gt;        443/TCP          5h machine-ip-service   LoadBalancer   10.104.164.245   localhost     8080:30420/TCP   5s   Since a machine-ip-service has been created, lets try to access the endpoint:   $ curl localhost:8080/ip  {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"}   Congratulations you have you first app deployed on kubernetes         A simple client  Before we move to last section, let create a simple client to make multiple rest calls.   #!/bin/sh  for i in {1..10} do    response=$(curl -sb -H \"Accept: application/json\" \"http://localhost:8080/ip\")    echo ${response} done   When we run this client, we get 10 response, which is from the same machine.   $ ./client.sh   {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"}   LoadBalancing with Kubernetes   Currently, we have only one pod running, suddenly the traffic has increased tremendously and we need to scale our app, what to do …   Simply increase the replica set &amp; let kubernetes handle the complexity.   $ kubectl scale --replicas=5 deployment/machine-ip  deployment.extensions \"machine-ip\" scaled   Now, lets check the available pods:  $ kubectl get pods                                  NAME                          READY     STATUS    RESTARTS   AGE machine-ip-5764588bdf-2sfxs   1/1       Running   0          13s machine-ip-5764588bdf-5g9wc   1/1       Running   0          13s machine-ip-5764588bdf-fh4v5   1/1       Running   0          13s machine-ip-5764588bdf-nh4mh   1/1       Running   0          13s machine-ip-5764588bdf-rtmr4   1/1       Running   0          1h         We see 4 new pods have been created instantly. Lets see what happens when make multiple client requests   $ ./client.sh  {\"ip\":\"10.1.0.8\",\"hostname\":\"machine-ip-5764588bdf-2sfxs\"} {\"ip\":\"10.1.0.5\",\"hostname\":\"machine-ip-5764588bdf-5g9wc\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.6\",\"hostname\":\"machine-ip-5764588bdf-fh4v5\"} {\"ip\":\"10.1.0.6\",\"hostname\":\"machine-ip-5764588bdf-fh4v5\"} {\"ip\":\"10.1.0.5\",\"hostname\":\"machine-ip-5764588bdf-5g9wc\"} {\"ip\":\"10.1.0.7\",\"hostname\":\"machine-ip-5764588bdf-nh4mh\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.5\",\"hostname\":\"machine-ip-5764588bdf-5g9wc\"} {\"ip\":\"10.1.0.6\",\"hostname\":\"machine-ip-5764588bdf-fh4v5\"}  If you observe, the requests are catered through different containers.   Similarly we can scale down, test the endpoint again   $ kubectl scale --replicas=2 deployment/machine-ip  deployment.extensions \"machine-ip\" scaled  $ kubectl get pods  NAME                          READY     STATUS        RESTARTS   AGE machine-ip-5764588bdf-fh4v5   0/1       Terminating   0          7m machine-ip-5764588bdf-nh4mh   1/1       Running       0          7m machine-ip-5764588bdf-rtmr4   1/1       Running       0          1h   $ ./client.sh   {\"ip\":\"10.1.0.7\",\"hostname\":\"machine-ip-5764588bdf-nh4mh\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.7\",\"hostname\":\"machine-ip-5764588bdf-nh4mh\"} {\"ip\":\"10.1.0.7\",\"hostname\":\"machine-ip-5764588bdf-nh4mh\"} {\"ip\":\"10.1.0.7\",\"hostname\":\"machine-ip-5764588bdf-nh4mh\"} {\"ip\":\"10.1.0.7\",\"hostname\":\"machine-ip-5764588bdf-nh4mh\"} {\"ip\":\"10.1.0.7\",\"hostname\":\"machine-ip-5764588bdf-nh4mh\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"} {\"ip\":\"10.1.0.4\",\"hostname\":\"machine-ip-5764588bdf-rtmr4\"}   We successfully scaled down our application.   Conclusion  In this article we installed docker with kubernetes, created a docker image of a java app, pushed it to docker-hub. Then we created our Kubernetes deployment &amp; services, and started our first pod. We also looked at how kubernetes handles scaling effortlessly.   You can find the complete code on github  ","categories": ["kubernetes"],
        "tags": [],
        "url": "https://kuros.in/kubernetes/2019/02/running-first-kubernetes-pod-on-mac/",
        "teaser": null
      },{
        "title": "Create React App Using Typescript",
        "excerpt":"When we talk of UI tech stack, two of the web technologies have emerged as main competitors, Angular(supported by Google) &amp; React(supported by Facebook).   Although comparing Angular &amp; React is like comparing apples vs oranges, Angular is framework which gives all the functions you need in build, whereas React is a library designed specifically for view rendering, for everything else you need to pull dependencies specifically   In this post we are going to focus on React with typescript. Lets talk about typescript before we proceed.   Typescript   Though typescript has been in market since 2012, it gained popularity after Angular adapted it. Typescript is superset of Javascript, provides you static typechecking, which I think is very beneficial to find errors early in product lifecycle. Its always better to find errors at compile time rather than breaking at runtime in production. And this makes life of the developer easier.   React  Coming back to React lets create our first react app. For only prerequisite is to have node installed on your system.         React has come up with a package which simplifies basic infrastructure for you, lets install the package on our local system.   $ npx create-react-app first-app   Wait for a minute!!!   This would create a react app, but wait… it has created a normal react app with javascript, but we want to work with typescript, we have two options either to add typescript manually or leverage react-create-app package to do the same.   So this time we will use the same command but will pass the argument –typescript  $ npx create-react-app first-app --typescript   Now that we have regenerated our app, lets see if it runs. You need to go to first-app folder and run the below commands:   $ cd first-app $ npm start    This would start the server  Compiled successfully!  You can now view first-app in the browser.    Local:            http://localhost:3000/   On Your Network:  http://192.168.0.105:3000/  Note that the development build is not optimized. To create a production build, use npm run build.   Go to the browser, and open http://localhost:3000/, if everything is correct you will see your app in the browser.             It says modify App.tsx, that’s what we will do. But first lets include few dependencies     Bootstrap: for designing UI.   react-router-dom: For routing.   $ npm install --save @types/bootstrap bootstrap $ npm install --save @types/react-router-dom react-router-dom  This will download &amp; add dependencies to your project. Your new package.json should look like this.   {   \"name\": \"first-app\",   \"version\": \"0.1.0\",   \"private\": true,   \"dependencies\": {     \"@types/bootstrap\": \"^4.3.0\",     \"@types/jest\": \"24.0.11\",     \"@types/node\": \"11.11.3\",     \"@types/react\": \"16.8.8\",     \"@types/react-dom\": \"16.8.2\",     \"@types/react-router-dom\": \"^4.3.1\",     \"bootstrap\": \"^4.3.1\",     \"react\": \"^16.8.4\",     \"react-dom\": \"^16.8.4\",     \"react-router-dom\": \"^4.4.0\",     \"react-scripts\": \"2.1.8\",     \"typescript\": \"3.3.3333\"   },   \"scripts\": {     \"start\": \"react-scripts start\",     \"build\": \"react-scripts build\",     \"test\": \"react-scripts test\",     \"eject\": \"react-scripts eject\"   },   \"eslintConfig\": {     \"extends\": \"react-app\"   },   \"browserslist\": [     \"&gt;0.2%\",     \"not dead\",     \"not ie &lt;= 11\",     \"not op_mini all\"   ] }   So in this exercise, we will create two pages Home &amp; About and will set up a routing for them.   Let’s add these two pages. I like to keep all the component in its respective folders. So I will create          /src/components/about/AboutPage.tsx       import React, {FunctionComponent} from \"react\";           const AboutPage: FunctionComponent = () =&gt; {     return (&lt;div&gt;This is the about Page &lt;/div&gt;) };      export default AboutPage;           Here We are creating AboutPage as a type of FunctionComponent, FunctionComponent is special type of component which do not maintain state. The compiled js file is very lightweight, so we must try to use FunctionComponent as much as possible.       We just return the function which we want to render.            /src/components/home/HomePage.tsx      import React, {Component} from \"react\"; import {Link} from \"react-router-dom\";     class HomePage extends Component {         render() {         return (             &lt;div className='container-fluid'&gt;                 &lt;div className='jumbotron'&gt;                     &lt;p&gt;Welcome to your first React App&lt;/p&gt;                     &lt;Link to='about'  className=\"btn btn-primary btn-lg\" &gt;More&lt;/Link&gt;                 &lt;/div&gt;             &lt;/div&gt;         );     } }     export default HomePage;           Whereas here we are using normal Component(this will maintain state). Also we are adding a Link to navigate to about page.              Routing   We have added both pages, now time to integrate them with our app. Earlier we added package for react-router-dom, it provides inbuilt components to care of routing.   Normally, within an application your pages should be redirecting to each other, so its always a good idea to wrap your root component for routing.   So we will modify the index.tsx, and wrap the App Component with BrowserRouter provided in react-router-dom.   import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import * as serviceWorker from './serviceWorker'; import {BrowserRouter} from \"react-router-dom\";  ReactDOM.render(     &lt;BrowserRouter&gt;         &lt;App /&gt;     &lt;/BrowserRouter&gt;,     document.getElementById('root'));  // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker.unregister();   Next we will modify our App.tsx to keep our routing urls:   import React, {Component} from 'react'; import './App.css'; import HomePage from \"./components/home/HomePage\"; import {Route} from \"react-router-dom\"; import AboutPage from \"./components/about/AboutPage\"; import 'bootstrap/dist/css/bootstrap.min.css'; import Header from \"./components/common/Header\";  class App extends Component {     render() {         return (             &lt;div className='container'&gt;                 &lt;Header/&gt;                 &lt;Route exact path='/' component={HomePage}/&gt;                 &lt;Route path='/about' component={AboutPage}/&gt;             &lt;/div&gt;         );     } }  export default App;   Now lets review our application. It working as expected, and we can navigate to both the pages.             Till now we successfully created a react app to serve static pages, now lets add some more features to the home page.   Header Component   Our application is working fine, but it would be good if we can navigate easily, we will add Navigation Links. I like components to be organized so will create Header at location /src/components/common/Header.tsx.   import React, {FunctionComponent} from \"react\"; import {NavLink} from \"react-router-dom\"; import './Header.css'  const Header: FunctionComponent = () =&gt; {      const activeStyle = {color: '#F15B2A'}     return (         &lt;nav className='space'&gt;             &lt;NavLink to='/' activeStyle={activeStyle}  exact &gt;Home&lt;/NavLink&gt; { \" | \"}             &lt;NavLink to='/about' activeStyle={activeStyle} &gt;About&lt;/NavLink&gt;         &lt;/nav&gt;     ) };  export default Header;   We also create a css file at location /src/components/common/Header.css and imported it the component.   .space {     margin-bottom: 20px;     margin-top: 20px; }   We have the Header ready, so lets access our first react simple application with routing.      But what happens when we try to access some wrong url in our application? We want to show a Page Not Found message to user, currently it just shows blank page.         So lets create PageNotFound Component &amp; to achieve default routing we will use switch function provided in routing.   import React, {FunctionComponent} from \"react\";  const NotFoundPage:FunctionComponent = () =&gt; &lt;div&gt;Oops Page Not found.&lt;/div&gt;;  export default NotFoundPage;   And modify the existing App.tsx as:   import React, {Component} from 'react'; import './App.css'; import HomePage from \"./components/home/HomePage\"; import {Route, Switch} from \"react-router-dom\"; import AboutPage from \"./components/about/AboutPage\"; import 'bootstrap/dist/css/bootstrap.min.css'; import Header from \"./components/common/Header\"; import NotFoundPage from \"./NotFoundPage\";  class App extends Component {     render() {         return (             &lt;div className='container'&gt;                 &lt;Header/&gt;                 &lt;Switch&gt;                     &lt;Route exact path='/' component={HomePage}/&gt;                     &lt;Route path='/about' component={AboutPage}/&gt;                     &lt;Route component={NotFoundPage}/&gt;                 &lt;/Switch&gt;             &lt;/div&gt;         );     } }  export default App;          Before we close lets add another page BookPage.tsx, which will become our playground for redux integration.   // src/components/book/BookPage.tsx  import React, {Component, ReactNode} from \"react\";  class BookPage extends Component{      render(): ReactNode {         return &lt;div&gt;Books&lt;/div&gt;;     } }  export default BookPage;  // src/App.tsx  import React, {Component} from 'react'; import './App.css'; import HomePage from \"./components/home/HomePage\"; import {Route, Switch} from \"react-router-dom\"; import AboutPage from \"./components/about/AboutPage\"; import 'bootstrap/dist/css/bootstrap.min.css'; import Header from \"./components/common/Header\"; import NotFoundPage from \"./NotFoundPage\"; import BookPage from \"./components/book/BookPage\";  class App extends Component {     render() {         return (             &lt;div className='container'&gt;                 &lt;Header/&gt;                 &lt;Switch&gt;                     &lt;Route exact path='/' component={HomePage}/&gt;                     &lt;Route path='/about' component={AboutPage}/&gt;                     &lt;Route path='/books' component={BookPage}/&gt;                     &lt;Route component={NotFoundPage}/&gt;                 &lt;/Switch&gt;             &lt;/div&gt;         );     } }  export default App;  // src/components/common/Header.tsx  import React, {FunctionComponent} from \"react\"; import {NavLink} from \"react-router-dom\"; import './Header.css'  const Header: FunctionComponent = () =&gt; {      const activeStyle = {color: '#F15B2A'}     return (         &lt;nav className='space'&gt;             &lt;NavLink to='/' activeStyle={activeStyle}  exact &gt;Home&lt;/NavLink&gt; { \" | \"}             &lt;NavLink to='/books' activeStyle={activeStyle} &gt;Books&lt;/NavLink&gt; { \" | \"}             &lt;NavLink to='/about' activeStyle={activeStyle} &gt;About&lt;/NavLink&gt;         &lt;/nav&gt;     ) };  export default Header;   After all these changes, our app will look like.      Conclusion   We have created a simple react app with typescript added the routing to it. You can find the code here.   ","categories": ["react"],
        "tags": [],
        "url": "https://kuros.in/react/2019/03/react-with-typescript/",
        "teaser": null
      },{
        "title": "Redux Basics",
        "excerpt":"Lets dive into Redux, I will be covering      Do we need redux?   Core Principles for redux.   Redux flow   Do we need Redux?   Why do we need redux in the first place, react does provides mechanism to share data between components. Hmmm…   No tool is perfect for all the job, suppose you want a very simple web app, simple JS &amp; HTML should suffice. But as the complexity grows you decide to pull in react as its component based, easy to manage. But now your app is growing fast, and it is becoming difficult to manage user interactions.   A React app is a component tree, each component is rendered when their state is changed. Below diagram represents how a simple component tree. Let’s assume the blue colored component require to share user information, so if the state of user in changed in one component, it should get reflected on the second component.      There are three ways to achieve it.                 Lift State: push the state to the common ancestor node, and passed down to all the intermediate nodes.          But finding &amp; managing ancestor is will be pain. Also you need keep passing state as prop types to all nodes. This is called Prop Drilling. So not a good option.            React Context: React provides an elegant way to handle Prop Drilling, in this case you can expose global data &amp; functions on React component using context. To access the data you import the context and consume it, you can also invoke functions like createUser() for the context.               Redux: In redux you maintain only one storage, its like having a database which store all your data, you can read any data from any component. To update you raise an event, which invokes reducer to creates a new state based on action. Once a new state is generated, respective components are refreshed.              Core Principles of Redux   Redux has three core principles:      States are immutable (Once state is created it cannot be modified)   Action trigger changes (Action is object which must have type variable). A simple example can be      {      type: SUBMIT_FORM,     message: 'HI'  }       Reducers update the state.   We discussed core concepts of redux, but we don’t know enough to write code, so let’s dive deeper into Redux          Action   Events happening in redux are called Actions. Action are plain object with description of an event. a simple object can be {type: RATE_BLOG, rating: 5}, here type is a required field, rest can be any value, a complex object, value or any serializable data. You should not pass functions or promises as action values as they are not serializable.   Mostly we use convenient functions to create Action data, often called as ActionCreators.  function rateBlog(rating) {     return {type: RATE_BLOG, rating: rating} }   Store   Redux Store honors single responsibility function. You might think it to be constraint when working with large application, but its quite the opposite. Having a single store make it a single source of truth, hence it leads to better manageability.   To create a store:  let store = createStore(reducer);  Redux is very simple, store can dispatch an action, subscribe to a listener, return its current state &amp; finally replace a reducer.  store.dispatch(action); // dispatch an action store.subscribe(listener); //subscribe to listener store.getState(); // return the current state store.replaceReducer(newReducer); //assign a new reducer for hot reloading.   Reducer  To simply put, reducers are simple function which take two argument default_state &amp; action_type. And based on action_type returns a new state.         For example if the action is increment counter, we will return the new state.  function myReducer(state, action) {   switch (action.type) {       case INCREMENT:         return {...state, counter: state.counter + 1};       default:         return state;   } }  At line 4: we are using copy via spread functionality of javascript, …state followed my arguments mean we want to create a copy of existing value with update field value, in this case we want to set counter value with new one.   Reducers must be pure functions, that means if calling with same set of argument it returns the same set of values.   Now that we have basic understanding of redux, we will move to next to adding it our react app.  ","categories": ["react"],
        "tags": [],
        "url": "https://kuros.in/react/2019/03/react-basics/",
        "teaser": null
      },{
        "title": "React Redux with typescript",
        "excerpt":"In my earlier post, I had explained the basic principle of redux. Also we have created our first react app.   I will be extending the same example to integrate redux in it, you can download the start code here.   Earlier we have created Books Page, which will contain the details of all the Book in the library. For now this component has a simple form to add books.   // src/components/book/BookPage.tsx  import React, {ChangeEvent, Component, FormEvent, ReactNode} from \"react\";   class BookPage extends Component&lt;BookProps, BookState&gt; {      constructor(props : BookProps) {         super(props);         this.state = {book: {title: '', author: ''}};     }      render(): ReactNode {         return (             &lt;div&gt;                 &lt;form onSubmit={this.handleSubmit}&gt;                     &lt;h2&gt;Books&lt;/h2&gt;                     &lt;h3&gt;Add Books&lt;/h3&gt;                     &lt;input type='text'                            onChange={this.handleChange}                            value={this.state.book.title}                     /&gt;                     &lt;input type='submit' value='Save'/&gt;                 &lt;/form&gt;             &lt;/div&gt;         );     }      private handleChange (event: ChangeEvent&lt;HTMLInputElement&gt;) {         const book:Book = { ...this.state.book, title: event.target.value};         this.setState({ book });     };      private handleSubmit (event: FormEvent) {         event.preventDefault();         alert(this.state.book.title);     } }  interface BookProps { }  interface BookState {     book: Book; }  interface Book {     title: string,     author: string }  export default BookPage;   Let’s look into detail.      Line 6: We add what is the type prop &amp; state it would manage, here BookProps (declared at line: 40) &amp; BookState (declared at line:43) respectively.   Line 8: constructor takes BookProps as constructor args.   Line 10: initialize state with book value. The type is declared at line: 47   Line 16: on submit of form we are calling handleSubmit method, passing the event reference (line: 34)   Line 20: added function mapping on change event, references line: 29   Line 30-31: We used spread operator to copy state of the book, with new title, then setting the state.   Line 35: the default behaviour of form is to reload the page, we don’t want that, so we will disable the default behavior.         When we run the application, and type in the text box, we get an error.  TypeError: Cannot read property 'state' of undefined handleChange src/components/book/BookPage.tsx:28   25 | }   26 |    27 | private handleChange (event: ChangeEvent&lt;HTMLInputElement&gt;) { &gt; 28 |     const book:Book = { ...this.state.book, title: event.target.value};      | ^  29 |     this.setState({ book });   30 | };   31 |  View compiled ▶ 20 stack frames were collapsed.   In order to fix this issue we will have to bind this to the functions in constructor.       constructor(props : BookProps) {         super(props);         this.state = {book: {title: '', author: ''}};                  this.handleChange = this.handleChange.bind(this);         this.handleSubmit = this.handleSubmit.bind(this);     }   Now we can see our functionality works, after we write in text box press save we see the alert with same text.   There is also a simple way of writing the classes which is less verbose;   class BookPage extends Component&lt;BookProps, BookState&gt; {          state = {book: {title: '', author: ''}};      render(): ReactNode {         return (             &lt;div&gt;                 &lt;form onSubmit={this.handleSubmit}&gt;                     &lt;h2&gt;Books&lt;/h2&gt;                     &lt;h3&gt;Add Books&lt;/h3&gt;                     &lt;input type='text'                            onChange={this.handleChange}                            value={this.state.book.title}                     /&gt;                     &lt;input type='submit' value='Save'/&gt;                 &lt;/form&gt;             &lt;/div&gt;         );     }      private handleChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {         const book:Book = { ...this.state.book, title: event.target.value};         this.setState({ book });     };      private handleSubmit = (event: FormEvent) =&gt; {         event.preventDefault();         alert(this.state.book.title);     } }   You don’t need to call super or declare a constructor, no binding required, as we are using arrow function.         Great !!! Time for Redux.   Installing Redux   First thing first, lets add redux packages.   $ npm install --save @types/react-redux react-redux $ npm install --save-dev @types/redux-devtools redux-devtools $ npm install --save @types/redux-immutable-state-invariant redux-immutable-state-invariant   redux-immutable-state-invariant is a middleware, which ensures that you don’t mutate state.   Redux Action   We have a form that is setup &amp; ready to send data, we will create action creator for Books.   // src/redux/book/bookActionType.ts  import {Book} from \"../../components/book/BookPage\";  export const CREATE_BOOK = 'CREATE_BOOK';  interface CreateBookAction {     type: typeof CREATE_BOOK     payload: Book }  export type BookActionType = CreateBookAction;      At line 7: We created interface which will have two field, type &amp; payload.   At line 12: We are exporting CreateBookAction as BookActionType, because later we will be assigning &amp; checking More types.   // src/redux/book/bookAction.ts  import {Book} from \"../../components/book/BookPage\"; import {BookActionType, CREATE_BOOK} from \"./bookActionType\";  export function createBook(book: Book): BookActionType {     return {type: CREATE_BOOK, payload: book} }         Our first action is ready, which returns a BookActionType just another reminder, it must contain type field.   Redux Reducer   Reducer takes two arguments, state &amp; action. In our case state will be book array, &amp; action will be of type BookActionType and it will return a new state which will be a new book array.   // src/redux/book/bookReducer.ts  import {Book} from \"../../components/book/BookPage\"; import {BookActionType, CREATE_BOOK} from \"./bookActionType\";  export default function BookReducer(state: Book[] = [], action: BookActionType): Book[] {     switch (action.type) {         case CREATE_BOOK:             return [...state, {...action.payload}];         default:             return state;     } }   Since our application is going to have a lot number of reducers, we need to combine them, using redux combineReducer function   // src/redux/rootReducer.ts  import {combineReducers} from \"redux\"; import BookReducer from \"./book/bookReducer\";  const rootReducer = combineReducers({     books: BookReducer });  export default rootReducer;   Redux Store  The third main component in Redux is store, so let’s not wait and create a store.   // src/redux/store.ts // one time configuration  import {applyMiddleware, compose, createStore} from \"redux\"; import rootReducer from \"./rootReducer\"; import immutableStateInvariantMiddleware  from \"redux-immutable-state-invariant\";   export default function configureStore(initialState?: any) {      // @ts-ignore     const composeEnhancers =         (&lt;any&gt;window).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; // add support for Redux dev tools      return createStore(rootReducer,         initialState,         composeEnhancers(applyMiddleware(immutableStateInvariantMiddleware()))) }   createStore takes in three argument: reducer, initial state &amp; middleware, we want to make sure our state is immutable, to make this happen we apply a middleware immutableStateInvariantMiddleware to take care of this job.         Now its time to plugin store to our react app. We will modify our index.tsx   // src/index.tsx // one time configuration  import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import * as serviceWorker from './serviceWorker'; import {BrowserRouter} from \"react-router-dom\"; import configureStore from \"./redux/store\"; import {Provider as ReduxProvider} from \"react-redux\";  const store = configureStore();  ReactDOM.render(     &lt;ReduxProvider store={store}&gt;         &lt;BrowserRouter&gt;             &lt;App /&gt;         &lt;/BrowserRouter&gt;     &lt;/ReduxProvider&gt;,     document.getElementById('root'));  // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker.unregister();  We are wrapping all our application within ReduxProvider, so that store is accessible to all our application.   Now that out configuration is in place let’s wire in Redux in our component.   Redux Connect   Its time to put all the pieces together, let’s take a look at the modified BookPage:  //  src/components/book/BookPage.tsx  import React, {ChangeEvent, Component, FormEvent, ReactNode} from \"react\"; import {connect} from \"react-redux\"; import {createBook} from \"../../redux/book/bookAction\";  class BookPage extends Component&lt;BookProps, BookState&gt; {      state = {book: {title: '', author: ''}};      render(): ReactNode {         return (             &lt;div&gt;                 &lt;form onSubmit={this.handleSubmit}&gt;                     &lt;h2&gt;Books&lt;/h2&gt;                     &lt;h3&gt;Add Books&lt;/h3&gt;                     &lt;input type='text'                            onChange={this.handleChange}                            value={this.state.book.title}                     /&gt;                     &lt;input type='submit' value='Save'/&gt;                       {                         this.props                         .books                         .map(book =&gt; (                         &lt;div key={book.title}&gt;{book.title}&lt;/div&gt;                         ))                     }                 &lt;/form&gt;             &lt;/div&gt;         );     }      private handleChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {         const book:Book = { ...this.state.book, title: event.target.value};         this.setState({ book });     };      private handleSubmit = (event: FormEvent) =&gt; {         event.preventDefault();         this.props.createBook(this.state.book);     } }  interface BookProps {     createBook(book: Book): void;     books: Book[]; }  export interface BookState {     book: Book; }  export interface Book {     title: string,     author: string }  export interface BookStoreState {     books: Book[] }  function mapStateToProps(state: BookStoreState) {     return {         books: state.books     } }  const mapDispatchToProps = {     createBook: createBook };  export default connect(mapStateToProps, mapDispatchToProps)(BookPage);   This time lets review from down to up:      Line 75: We are not exporting BookPage now, instead we are calling connect function (of redux) with mapStateToProps &amp; mapDispatchToProps, the output is a function to which we are passing our BookPage.   Line 71: We have created mapping object, which will get bind to react props. We can also use a function instead, but in that case, we will have to dispatch our action explicitly.   Line 65: Maps redux store state to props, in the root reducer, we have assigned output array to books variable, so to get new state, we fetch state.books   Line 47: BookProps has changed, now it contains book field &amp; createBook function (mapped in function at line: 71 &amp; line:75).   Line 43: In the handleSubmit function, we are dispatching event by calling props.createBook method.   Line 25: Finally, we have iterated over mapped store books and printed the titles.   If you have followed correctly, you can see your page in action.      Conclusion   In this article we have integrated redux to react, in typescript. As usual the complete code is on github.   ","categories": ["react"],
        "tags": [],
        "url": "https://kuros.in/react/2019/03/react-redux/",
        "teaser": null
      },{
        "title": "Spring Security with Basic Authentication",
        "excerpt":"In the world of internet, information is flowing across multiple networks. We need to secure our application against the threats posed by hackers or unauthorized users. Its like protecting your castle, you build outer walls, moat, inner walls, watchers, towers etc., basically you need different layers of protection to counter threats.   Similarly, In modern security application, we have different layers of security:      Firewall   Login   Security Questions   Two Factor Authentication   Authorization.   Hashing   and many more   In this series, we will try to learn them, starting with basic authentication.   Perquisite     Spring Framework   Spring MVC (basics)   Java 8   Lombok Setup(if you want to run the code)   Maven          Servlets and filters   Before we proceed, lets spend some time on revising the web flow.   User makes a call to server using http/https protocol, server delegates the request corresponding servlet.      Filter  In order to intercept requests, we are provided with filters. Spring security heavily uses these filters for authentication and authorization.      The filter interface provides three methods  package javax.servlet;  import java.io.IOException;  public interface Filter {     default void init(FilterConfig filterConfig) throws ServletException {     }      void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException;      default void destroy() {     } }   The init/destroy method is called when the filter is loaded/removed from the context. Whereas doFilter method is envoked everytime the request comes. it takes the request, response and filterChain object         In order to configure, we need to add filter chain in web.xml    &lt;filter&gt;     &lt;filter-name&gt;myFilter&lt;/filter-name&gt;     &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;   &lt;/filter&gt;    &lt;filter-mapping&gt;     &lt;filter-name&gt;myFilter&lt;/filter-name&gt;     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;   &lt;/filter-mapping&gt;   Filter Chain   As per the docs, A FilterChain is an object provided by the servlet container to the developer giving a view into the invocation chain of a filtered request for a resource. Filters use the FilterChain to invoke the next filter in the chain, or if the calling filter is the last filter in the chain, to invoke the resource at the end of the chain.   To simply put, We group filters under filter chain, and map chains to urls.      Based on the endpoint spring figures out which filter chain needs to be applied. Once identified, it applies all the filter within that chain.   Key Filters Provided by Spring Security   There are many filters provided by Spring Security framework, we will take a look at few of the most important filters.      SecurityContextPersistenceFilter: Responsible for managing security context, security context holds the details of authenticated principle, like username, roles etc. The Security context is stored at SecurityContextHolder, which manages context for a session. When the first request is made, and empty context is created and assigned to the request.   AuthenticationFilters: Responsible for authenticating and generating principle. This generated principle is then set in Security Context.   FilterSecurityInterceptor: Interceptor provides authorization.   ExceptionTranslationFilter: Redirect to the error or login page.          Authentication Workflow  When a request comes, its delegated to Authentication filters, which generates AuthenticationTokens, these tokens are then passed to AuthenticationManager, it would validate the token and generate principle object(principle mainly means minimum basic info after authentication).      Once the Authentication is done, credentials is removed and Authorities are set. This makes sure the credentials are not leaked down the session.   Putting it all together   Basically to enable spring security features, you just need to setup security filter chain and configure the DispatcherServlet in your web.xml. That’s it.   Provide the filters and authentication provider and you are done.      Create web application   We will create a simple library application which will become our playground for setting up the spring-security.         We will start by creating a new spring boot application.  &lt;!-- pom.xml --&gt;  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;     &lt;groupId&gt;in.kuros.blog.code&lt;/groupId&gt;     &lt;artifactId&gt;spring-security-basics&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;name&gt;spring-security-basics&lt;/name&gt;     &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;      &lt;properties&gt;         &lt;java.version&gt;1.8&lt;/java.version&gt;     &lt;/properties&gt;      &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;com.h2database&lt;/groupId&gt;             &lt;artifactId&gt;h2&lt;/artifactId&gt;             &lt;scope&gt;runtime&lt;/scope&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;             &lt;artifactId&gt;lombok&lt;/artifactId&gt;             &lt;optional&gt;true&lt;/optional&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;  &lt;/project&gt;   Configure H2 database  Here we are using H2 database to list book records, so lets configure H2. We will add configs to application.properties   # src/main/resources/application.properties  spring.datasource.url=jdbc:h2:mem:testdb; spring.datasource.driverClassName=org.h2.Driver spring.datasource.username=sa spring.datasource.password= spring.h2.console.enabled=true spring.jpa.hibernate.ddl-auto=create spring.datasource.data=classpath:db/data.sql  At line 8, we are telling our to create fresh schema every time our app starts(Do not use this in prod) At line 9, we configured our app to read data.sql to populate book table. This would initialize Book table with few values.   # src/main/resources/db/data.sql  insert into book(name) values ('A Little Forever'),                               ('To Kill a Mockingbird '),                               ('A Thousand Splendid Suns'),                               ('The Kite Runner'),                               ('Harry Potter and the Philosopher''s Stone'),                               ('Harry Potter and the Chamber of Secrets');          Create Entity &amp; Respective Repository   Next, we will create Entity to map Book object.   // src/main/java/in/kuros/blog/code/spring/security/basics/entity/Book.java  package in.kuros.blog.code.spring.security.basics.enitity;  import lombok.Getter; import lombok.Setter;  import javax.persistence.Basic; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table;  @Entity @Table @Getter @Setter public class Book {      @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Integer id;      @Basic     @Column(name = \"name\")     private String name; }   At line 16 &amp; 17, we are using lombok to generate boilerplate code for getters/setters. If you don’t want to use lombok, simply provide getters/setters, the old fashion way.         Next we create JPA Repository to access Book data.   // src/main/java/in/kuros/blog/code/spring/security/basics/repository/BookRepository.java  package in.kuros.blog.code.spring.security.basics.repository;  import in.kuros.blog.code.spring.security.basics.entity.Book; import org.springframework.data.jpa.repository.JpaRepository;  public interface BookRepository extends JpaRepository&lt;Book, Integer&gt; { }   Controller   Finally we need to create a controller and expose rest api to access book details.   // src/main/java/in/kuros/blog/code/spring/security/basics/controller/BookController.java  package in.kuros.blog.code.spring.security.basics.controller;  import in.kuros.blog.code.spring.security.basics.entity.Book; import in.kuros.blog.code.spring.security.basics.repository.BookRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.util.List;  @RestController public class BookController {      private final BookRepository bookRepository;      @Autowired     public BookController(final BookRepository bookRepository) {         this.bookRepository = bookRepository;     }      @GetMapping(path = \"books\")     public List&lt;Book&gt; getBooks() {         return bookRepository.findAll();     } }   All our initial components are ready, lets access the data at http://localhost:8080/books  [   {     \"id\": 1,     \"name\": \"A Little Forever\"   },   {     \"id\": 2,     \"name\": \"To Kill a Mockingbird \"   },   {     \"id\": 3,     \"name\": \"A Thousand Splendid Suns\"   },   {     \"id\": 4,     \"name\": \"The Kite Runner\"   },   {     \"id\": 5,     \"name\": \"Harry Potter and the Philosopher's Stone\"   },   {     \"id\": 6,     \"name\": \"Harry Potter and the Chamber of Secrets\"   } ]          Time to add Spring Security   Ok, so now we have all our base application setup. Now we will add maven dependency for spring security:-   &lt;!-- pom.xml --&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;     &lt;/dependency&gt;   Restart the application and again try to access http://localhost:8080/books. We see a login page, hmmmm…, but what’s the username &amp; password? We haven’t added any authentication except maven dependency.   To answer this question, Spring creates a lot of boilerplate code, Annotations &amp; configuration to plugin security.   In order to login, Username: user, Password: &lt;Will be found in logs: Using generated security password: XXXXXXXX&gt;   If we debug the DelegatingFilterProxy, we will get list of some of the filters we talked about earlier.      Basic Authentication  Time to customize application using basic authentication. We will first create a class extending WebSecurityConfigurerAdapter.   // src/main/java/in/kuros/blog/code/spring/security/basics/security/SecurityConfiguration.java  package in.kuros.blog.code.spring.security.basics.security;  import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.password.NoOpPasswordEncoder;  @Configuration public class SecurityConfiguration extends WebSecurityConfigurerAdapter {      @Override     protected void configure(final HttpSecurity http) throws Exception {         http.authorizeRequests()                     .anyRequest()                     .authenticated()                 .and()                     .httpBasic()                 .and()                     .logout();     }      @Override     protected void configure(final AuthenticationManagerBuilder auth) throws Exception {         auth.inMemoryAuthentication()                 .withUser(\"myuser\")                 .password(\"mypassword\")                 .roles(\"USER\")                 .and()                 .passwordEncoder(NoOpPasswordEncoder.getInstance());     } }           Lets look at them with detail. At line 15, we override the configure method, and we say we want to authorize any requests with only basic and logout filter.   Also at line 27, we are setting up in memory authentication, with user/password details. Don’t forget to add password encoder(at line 32) else you will get an error something like this   java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id \"null\" \tat org.springframework.security.crypto.password.DelegatingPasswordEncoder$UnmappedIdPasswordEncoder.matches(DelegatingPasswordEncoder.java:244) ~[spring-security-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.crypto.password.DelegatingPasswordEncoder.matches(DelegatingPasswordEncoder.java:198) ~[spring-security-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$LazyPasswordEncoder.matches(WebSecurityConfigurerAdapter.java:594) ~[spring-security-config-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.authentication.dao.DaoAuthenticationProvider.additionalAuthenticationChecks(DaoAuthenticationProvider.java:90) ~[spring-security-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider.authenticate(AbstractUserDetailsAuthenticationProvider.java:166) ~[spring-security-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:175) ~[spring-security-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:200) ~[spring-security-core-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilterInternal(BasicAuthenticationFilter.java:180) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.csrf.CsrfFilter.doFilterInternal(CsrfFilter.java:100) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:74) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) ~[spring-security-web-5.1.5.RELEASE.jar:5.1.5.RELEASE] \tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.6.RELEASE.jar:5.1.6.RELEASE] \tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131] \tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131] \tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.17.jar:9.0.17] \tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]    Now when you access the url again, this time you will be asked a basic form popup.      Now we can successfully login with basic authentication, using our provided username and password.   Find the complete code here  ","categories": ["spring","spring-security"],
        "tags": [],
        "url": "https://kuros.in/spring/spring-security/2019/04/spring-security/",
        "teaser": null
      },{
        "title": "Spring Security with Authentication Provider",
        "excerpt":"We have looked into basics of spring security in my previous post. Lets look into how we can authenticate a user from custom list;   So let’s start, first we create a spring boot application, for database we will use H2.   Enable Spring Security   In order to enable spring security in any spring application, just add the following dependency in your pom file.   &lt;!--pom.xml--&gt;      &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;     &lt;/dependency&gt;    That’s it you have enabled spring security.         We want to expose “/books” which is a public api i.e. anyone can access it. We have another set of harry potter books (“/secure/books”) which we want to be secured.   // src/main/java/in/kuros/controller/CartController.java  package in.kuros.controller;  import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.util.ArrayList; import java.util.List;  @RestController public class BookController {      @GetMapping(\"/books\")     public List&lt;String&gt; getBooks() {         final List&lt;String&gt; books = new ArrayList&lt;&gt;();         books.add(\"A Little Forever\");         books.add(\"To Kill a Mockingbird\");         books.add(\"A Thousand Splendid Suns\");          return books;     }          @GetMapping(\"/secured/books\")     public List&lt;String&gt; securedBooks() {         final List&lt;String&gt; books = new ArrayList&lt;&gt;();         books.add(\"Harry Potter and the Philosopher's Stone\");         books.add(\"Harry Potter and the Chamber of Secrets\");          return books;              } }   Now run the application, you see by default, spring has auto configured the security      Username is “user” &amp; password to login, will be found in the logs something like this.    Using generated security password: fb610637-e0a6-423b-bb6b-1badf661d885   Try logging in.   Spring security configuration  So far so good, we have security configured, but we still have a problem. Both our apis are behind authentication. But we wanted only one api to be secured.         To fix this, we need to crete a config file which extends WebSecurityConfigurerAdapter. We need to override configure method as below.   // src/main/java/in/kuros/config/SecurityConfig.java  package in.kuros.config;  import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;  @Configuration @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter {      @Override     protected void configure(final HttpSecurity http) throws Exception {         http                 .authorizeRequests()                 .antMatchers(\"/books\").permitAll()                 .antMatchers(\"/secured/*\").authenticated();         http                 .formLogin();     } }   Great now we have fulfilled our requirement, /books is public and /secured/books are restricted.   Lets look at what happened, we configured httpSecurity to authorize requests and permitted everyone to access /books, where for any url starting with /secured/ needs to be authenticated. We have also enforced formLogin() here.   H2 database setup in spring boot  Before we proceed further, lets enable H2 database to where we will store our user information.   To integrate H2 database, we need to the following dependency in our pom file..   &lt;!-- pom.xml --&gt;      &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;com.h2database&lt;/groupId&gt;         &lt;artifactId&gt;h2&lt;/artifactId&gt;         &lt;scope&gt;runtime&lt;/scope&gt;     &lt;/dependency&gt;  We have added dependency to enable JPA with H2 database. Next we will enable h2-console, we will add the property to our application.properties.   # src/main/resources/application.properties  spring.h2.console.enabled=true spring.jpa.hibernate.ddl-auto=create spring.datasource.data=classpath:db/data.sql spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true   Let’s start the server, connect to http://localhost:8080/h2-console             user the following properties to login  driver class=org.h2.Driver jdbc url=jdbc:h2:mem:testdb username=sa password=   But the moment you login, you will get an error:   Whitelabel Error Page This application has no explicit mapping for /error, so you are seeing this as a fallback.  Sun May 12 13:31:45 IST 2019 There was an unexpected error (type=Forbidden, status=403). Forbidden   To fix this, we will add the following configuration in our SecurityConfig           http                 .csrf()                 .disable();    After this we are able to login but the page not rendered properly.      so we need to add below configuration to allow any frame to run from the same origin.           http                 .headers()                 .frameOptions().sameOrigin();   so we are able to login now.         Lets create the entity &amp; repository:   // src/main/java/in/kuros/entity/User.java  @Entity @Table(name = \"users\") public class UserEntity {      @Id     @Column(name = \"id\")     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Integer id;      @Basic     @Column(name = \"user_name\")     private String userName;      @Basic     @Column(name = \"password\")     private String password;      @OneToMany(mappedBy = \"user\")     private List&lt;UserRoles&gt; userRoles;      // getters &amp; setters         }   // src/main/java/in/kuros/entity/UserRoles.java  @Entity @Table(name = \"user_roles\") public class UserRoles {      @Id     @Column(name = \"id\")     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Integer id;      @Column(name = \"user_id\")     private Integer userId;      @Column(name = \"role\")     private String role;      @ManyToOne     @JoinColumn(name = \"user_id\", referencedColumnName = \"id\", insertable = false, updatable = false)     private UserEntity user;          // getters and setters }    We will also insert values in the tables users &amp; user_roles, we will create db/data.sql   # src/main/resources/db/data.sql  INSERT INTO users (user_name, password) VALUES ('kuros', 'passwd');  INSERT INTO user_roles (user_id, role) VALUES (1, 'ADMIN'),                                               (1, 'USER');    We have all our data setup, we will verify ( http://localhost:8080/h2-console ).      User Authentication   Well, we have our api’s secured, but we still have a problem, we still rely on password generated by spring. We want to access our api’s using our users.   There are multiple ways we can handle it, but in this post we will focus on using authentication provider.         We will create a custom authentication provider. We need to implement authenticate method, you will get authentication object, it will contain username and credentials which we will validate.   After we validate the user we need to create new Token, but make sure you do not forward password beyond, you don’t want password to leak to other filters.   package in.kuros.custom;  import in.kuros.entity.UserEntity; import in.kuros.entity.UserRoles; import in.kuros.repository.UserRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.AuthenticationProvider; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.AuthenticationException; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Component;  import java.util.Collection; import java.util.List; import java.util.stream.Collectors;  @Component public class CustomAuthenticationProvider implements AuthenticationProvider {      @Autowired     private UserRepository userRepository;      @Override     public Authentication authenticate(final Authentication authentication) throws AuthenticationException {         final String username = authentication.getName();         final String password = authentication.getCredentials().toString();          final List&lt;UserRoles&gt; userRoles = getUserIfAuthenticated(username, password);          return new UsernamePasswordAuthenticationToken(username, null, getGrantedAuthorities(userRoles));     }      private Collection&lt;? extends GrantedAuthority&gt; getGrantedAuthorities(final List&lt;UserRoles&gt; userRoles) {         return userRoles                 .stream()                 .map(role -&gt; (GrantedAuthority) role::getRole)                 .collect(Collectors.toList());     }      private List&lt;UserRoles&gt; getUserIfAuthenticated(final String username, final String password) {         final UserEntity entity = userRepository.findByUserName(username);          if (entity == null) {             throw new UsernameNotFoundException(\"Authentication failed\");         }          if (!entity.getPassword().equals(password)) {             throw new UsernameNotFoundException(\"Authentication failed\");         }          return entity.getUserRoles();     }      @Override     public boolean supports(final Class&lt;?&gt; aClass) {         return aClass.equals(UsernamePasswordAuthenticationToken.class);     } }          Finally we will override the configure method and provide our custom authentication provider.   So our SecurityConfig is finally complete:   // src/main/java/in/kuros/config/SecurityConfig.java  package in.kuros.config;  import in.kuros.custom.CustomAuthenticationProvider; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;  @Configuration @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter {      @Autowired private CustomAuthenticationProvider customAuthenticationProvider;      @Override     protected void configure(final HttpSecurity http) throws Exception {         http                 .headers()                 .frameOptions().sameOrigin();          http                 .csrf()                 .disable();          http                 .authorizeRequests()                 .antMatchers(\"/books\").permitAll()                 .antMatchers(\"/secured/**\").authenticated();         http                 .formLogin();     }      @Override     protected void configure(final AuthenticationManagerBuilder auth) throws Exception {         auth.authenticationProvider(customAuthenticationProvider);     } }   Now we have a fully functional app with security enabled.   Full code can be found here: Spring Security with Authentication Provider   ","categories": ["spring","spring-security"],
        "tags": [],
        "url": "https://kuros.in/spring/spring-security/2019/04/spring-security-authentication-provider/",
        "teaser": null
      },{
        "title": "Java 8 - Creating a Custom Collector for Streams",
        "excerpt":"Java Streams provide a wide range of collectors which is generally sufficient for most of the day to day use. But sometimes you need to perform some special operations, which is not provided out of the box.   We can create our own custom collectors to suit our requirement.   We have a requirement, we want to collect only distinct items from a list.   Create Custom Collector   If we look the at the Collector interface, it provided 5 methods which we need to implement.   public interface Collector&lt;T, A, R&gt; {      Supplier&lt;A&gt; supplier();      BiConsumer&lt;A, T&gt; accumulator();      BinaryOperator&lt;A&gt; combiner();      Function&lt;A, R&gt; finisher();      Set&lt;Characteristics&gt; characteristics(); }   Here the collector interface comprises of 3 generic data types, T, A, R.     T: Type of the data stream, for e.g. if we have List over which we are streaming, then Integer will be the type.   A: Accumulation type, this is the hidden store where we want to store the intermediate results.   R: Return type, this is return type.   Supplier  We need to provide a supplier that creates a result container. This is where the accumulated value will be stored.         In our case we need a Set to hold unique items.   () -&gt; new HashSet&lt;&gt;();   Accumulator  Now we need to create a function which defines how to add element to the result container. In this case we add elements to the set.   (result, item) -&gt; result.add(item)   Combiner  In a sequential reduction the supplier and accumulator above would be sufficient. But to be able to support a parallel implementation we need to provide a combiner.   The combiner is a function that defines how two result containers could be combined.   Why?         In parallel processing the stream is broken into multiple processing units, each unit processed and is accumulated independently, so we need to merge all this units to get the final result using the combiner.   (result1, result2) -&gt; {     result1.addAll(result2);     return result1; }  In our case we will have two sets, so we will merge them and return a combined result.   Finisher  There are times when your result container and your final output is of different types, and you want to adapt the result container.   Like in our example, we are storing the items in a set but we want output to be a list, so we will leverage the finisher to adapt into a list.   c -&gt; new ArrayList&lt;Integer&gt;(c)   Characteristics  Finally we need to tell the collector framework, what is the properties of our collector, this can be used to optimize reduction implementation.   There are 3 types of Characteristics available:     CONCURRENT: Indicates that this collector is concurrent, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads.   IDENTITY_FINISH: Indicates that the finisher function is the identity function and can be elided   UNORDERED: Indicates that the collection operation does not commit to preserving the encounter order of input elements.         So in our case it will have both CONCURRENT &amp; UNORDERED characteristics.   Complete Code   package in.kuros.blog.code.java.streams;  import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collector;  public class CustomCollector {          public static &lt;T&gt; Collector&lt;T, Set&lt;T&gt;, List&lt;T&gt;&gt; unique() {         return Collector.of(                 () -&gt; new HashSet&lt;T&gt;(),                 (result, item) -&gt; result.add(item),                 (result1, result2) -&gt; {                     result1.addAll(result2);                     return result1;                 },                 c -&gt; new ArrayList&lt;T&gt;(c),                 Collector.Characteristics.CONCURRENT,                 Collector.Characteristics.UNORDERED);     } }   We can also replace lamda with method reference. so the new code will become:  package in.kuros.blog.code.java.streams;  import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collector;  public class CustomCollector {      public static &lt;T&gt; Collector&lt;T, Set&lt;T&gt;, List&lt;T&gt;&gt; unique() {         return Collector.of(                 HashSet::new,                 Set::add,                 (result1, result2) -&gt; {                     result1.addAll(result2);                     return result1;                 },                 ArrayList::new,                 Collector.Characteristics.CONCURRENT,                 Collector.Characteristics.UNORDERED);     } }   Finally lets test it:   public static void main(String[] args) {     final List&lt;Integer&gt; result = IntStream.of(1, 2, 3, 4, 3, 4, 5)             .boxed()             .collect(CustomCollector.unique());      System.out.println(result); }  [1, 2, 3, 4, 5]   You can find the complete code here   ","categories": ["java","Streams"],
        "tags": [],
        "url": "https://kuros.in/java/streams/2019/05/custom-collector/",
        "teaser": null
      },{
        "title": "Event Driven Microservices with Spring Cloud Stream Using Rabbitmq",
        "excerpt":"In today’s world microservices has taken the software industry by storm, the reason is obvious, it provides loose coupling, microservices are more reliable and scalable compared to monolith applications. You can introduce new components in the workflow without breaking another, and you can still interact with your legacy applications.   But life is not fair, so microservices comes with their own set of challenges. One of the most important of them is how would these microservices should interact with each other. Should they be using rest endpoint’s (but services fail if requested point is not available), or using messaging but configuring a broker is a pain. What if I designed my application to use rabbitmq but now I want to migrate to AWS kinesis, there is a lot of pain involved in migrating tech stack.         Spring Cloud Stream  Spring has come up with an abstraction over messaging infrastructure, to make sure, we focus more on business goals rather than technology management. And the solution is Spring Cloud Stream.   Spring Cloud Stream(SCS) is build over spring boot and is highly opinionated about the runtime configuration.   Spring Integration  Spring Cloud Stream uses spring-integration to provide connectivity to message brokers. It uses the concept of MessageChannel to decouples message producers from message consumers.   It also provides the Channel Adapters, which takes in outside message and adapts them to spring message.   There are Service Activators, which are responsible for pulling messages from message channel and call the attached method of service bean.         Basic Concepts   When we are taking about Cloud Streams, there are some basic concepts that we need to remember:     Apps are going to communicate with each other via channels.   All the middleware will be abstracted by Binders, it the job of the binder to how to connect with the physical endpoints like queues, topics etc. Spring Cloud Stream auto detects the binders based on the classpath, and configures them. You can create multiple brokers of the same type, even you can configure multiple binders e.g. Kafka or Rabbitmq to send the same message on different channels.   Cloud Streams provide @StreamListener to pull objects from message channel. You can create multiple conditional listeners.   Spring Cloud Communication patterns  Spring Cloud Stream uses 3 different patterns to communicate over channels.      Publisher/Subscriber: Message is broadcast, all the listeners will be notified.     Consumer Groups: This concept was introduced by Kafka for the first time. Here the message will be broadcast, but now the consumer are divided in groups, each group will receive the message, but only one of the consumer will process it. You don’t need to have Kafka, SCS provides wrapper logic to manage consumer groups internally.     Partitioning: This is a very strong feature provided by SCS, you can send the message and consumer will be partitioned based on the condition. so each partition will be handling the respective data independently.      Setting up RabbitMQ  We are going to use RabbitMQ as our binging channel, we are going to run rabbitMQ inside docker container.   User the following command to run docker instance.  $ docker run -d --hostname my-rabbit --name some-rabbit -p 15672:15672 -p 5672:5672 rabbitmq:3-management  Unable to find image 'rabbitmq:3-management' locally 3-management: Pulling from library/rabbitmq 5b7339215d1d: Pull complete  14ca88e9f672: Pull complete  a31c3b1caad4: Pull complete  b054a26005b7: Pull complete  eef17c6cb6cf: Pull complete  2f1b018e55d1: Downloading [========================&gt;                          ]  16.64MB/34.14MB 6cb106540743: Download complete  88b93ace2192: Download complete  609cd90dbc7b: Download complete  c9ee32f1144b: Download complete  fefc85bff58e: Download complete  33624b12c0ed: Downloading [===================&gt;                               ]  4.021MB/10.14MB Digest: sha256:a8c1e0f2cea371b4860df47a53294876d6874fe68fa12c416e39cef307e75bcd Status: Downloaded newer image for rabbitmq:3-management fa09ea9000b27817fd22bcb623d2e844c892e22d1b9eedd22402abe19344b9b9          Once the download is complete, it would fire up the container. To verify your container is up:  $ docker ps  CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                                                                    NAMES fa09ea9000b2        rabbitmq:3-management   \"docker-entrypoint.s…\"   2 minutes ago       Up 2 minutes        4369/tcp, 5671-5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:8080-&gt;15672/tcp   some-rabbit   To access the rabbitMQ console login to http://localhost:15672/. which is available on the standard management port of 15672, with the default username and password of guest / guest    After login the console is available:    Problem statement   Before we proceed let’s create a problem statement we are trying to solve with messaging. Assume we have an Online Order service, when someone places the order, we log the orders for auditing, send the order for packaging. We have an independent logging system and now we need to connect our main application logging system.         Application  Now we will create a spring boot application and add the following dependencies:           &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-stream&lt;/artifactId&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;         &lt;/dependency&gt;   we will also need to add bom import      &lt;dependencyManagement&gt;         &lt;dependencies&gt;             &lt;dependency&gt;                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                 &lt;version&gt;Greenwich.RELEASE&lt;/version&gt;                 &lt;type&gt;pom&lt;/type&gt;                 &lt;scope&gt;import&lt;/scope&gt;             &lt;/dependency&gt;         &lt;/dependencies&gt;     &lt;/dependencyManagement&gt;  Since we have given binder for rabbitmq, spring cloud will autoconfigure the binding.   Let’s initialize rabbitmq connection details, add the following lines in your application.properties file.   spring.rabbitmq.host=127.0.0.1 spring.rabbitmq.port=5672 spring.rabbitmq.username=guest spring.rabbitmq.password=guest   Next step is to define channels through which we want to communicate, Spring has provided 3 types of channel out of the box(we will be using mostly custom channels in prod, but for this article we will stick to provided channel).                 Sink: Consumer binding        public interface Sink {          String INPUT = \"input\";         @Input(Sink.INPUT)    SubscribableChannel input();  }           Source: Producer binding     public interface Source {       String OUTPUT = \"output\";       @Output(Source.OUTPUT)   MessageChannel output(); }           Processor: combination of Sink &amp; Source, consumes message &amp; also produces it.     public interface Processor extends Source, Sink {}           In our sample application we produce one event every 5 seconds with a spring Scheduler.   Enable Scheduling:  @SpringBootApplication @EnableScheduling public class SpringCloudStreamRabbitmqPubApplication {      public static void main(String[] args) {         SpringApplication.run(SpringCloudStreamRabbitmqPubApplication.class, args);     }  }   we will create a payload class, in this case:  public class Order {      private String orderNumber;      // getter  and setters ... }  Publisher   Now we create an order service to produce orders every 5 sec.   @Component @EnableBinding(Source.class) public class OrderPublisher {      @Autowired Source source;      @Scheduled(fixedDelay = 5000)     public void publishOrder() {         final Message&lt;Order&gt; message = MessageBuilder.withPayload(new Order(\"Order Number: \" + System.currentTimeMillis())).build();         source.output().send(message);     }      public static class Order {         private LocalDateTime localDateTime;          public Order(final LocalDateTime localDateTime) {             this.localDateTime = localDateTime;         }          public LocalDateTime getLocalDateTime() {             return localDateTime;         }     } }   At line 2, we used @EnableBinding and provided Source channel, then we autowired Source to publish message to channel. We have used @Scheduled to execute method every 5 sec.   Now when we run the application we can verify if our message is getting published in rabbitmq, let’s check its management console.         We can notice a new topic has been created in Exchanges with the name output to match the interface.      And we can see a message being published to the newly create output topic.    Consumer   Now lets create a logging listener which will receive the message.   import org.springframework.cloud.stream.annotation.EnableBinding; import org.springframework.cloud.stream.annotation.StreamListener; import org.springframework.cloud.stream.messaging.Sink; import org.springframework.messaging.Message; import org.springframework.stereotype.Component;  @Component @EnableBinding(Sink.class) public class LoggingListener {      @StreamListener(Sink.INPUT)     public void log(Message&lt;Order&gt; orderMessage) {         System.out.println(orderMessage.getPayload());     } }   Now if we run our application again, we can see a new exchange has been added in rabbitmq    And also a queue is generated something like this    But we are still not receiving any message?. Ok lets see what we are missing, we have created a channel for output named as output, a channel for receiving the message named as input, but we have not attached these channels, so lets do this.         In you application.properties add the following properties.   spring.cloud.stream.bindings.input.destination=order spring.cloud.stream.bindings.output.destination=order   We are saying both input.destination &amp; output.destination maps to a new channel named as order   When we run the application, messages start getting printed in console.  Order Number: 1561241483425 Order Number: 1561241493487 Order Number: 1561241503487 Order Number: 1561241513490 Order Number: 1561241523494 Order Number: 1561241533496   Let’s take a look at rabbitmq, if we look into order details, we see now it has a binding to order.xxxx.xxxx queue rather than input queue.      Congratulations, we have created our first spring cloud stream application.   Download the complete code.   ","categories": ["spring","spring-cloud"],
        "tags": [],
        "url": "https://kuros.in/spring/spring-cloud/2019/06/spring-cloud-stream-with-rabbitmq/",
        "teaser": null
      },{
        "title": "Handling gRPC Authorization using Context in Java",
        "excerpt":"In the Grpc world, we have secured our application by encrypting the channel and authenticating the requests using interceptors. So we have secured our application but we still do have control over which service can be accessed by whom.   To handle authorization, we will leverage Context provided by grpc to pass UserInfo into services.   Time to setup our project.  Pom  We will create a maven project add the following dependencies:       &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.grpc&lt;/groupId&gt;             &lt;artifactId&gt;grpc-all&lt;/artifactId&gt;             &lt;version&gt;1.18.0&lt;/version&gt;         &lt;/dependency&gt;          &lt;!-- https://mvnrepository.com/artifact/io.netty/netty-tcnative-boringssl-static --&gt;         &lt;dependency&gt;             &lt;groupId&gt;io.netty&lt;/groupId&gt;             &lt;artifactId&gt;netty-tcnative-boringssl-static&lt;/artifactId&gt;             &lt;version&gt;2.0.20.Final&lt;/version&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;   We also need to add plugin to build protobuf files during compile time.       &lt;build&gt;         &lt;extensions&gt;             &lt;extension&gt;                 &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;                 &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;1.6.1&lt;/version&gt;             &lt;/extension&gt;         &lt;/extensions&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;                 &lt;version&gt;0.6.1&lt;/version&gt;                 &lt;configuration&gt;                     &lt;protocArtifact&gt;                         com.google.protobuf:protoc:3.5.1:exe:${os.detected.classifier}                     &lt;/protocArtifact&gt;                     &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;                     &lt;pluginArtifact&gt;                         io.grpc:protoc-gen-grpc-java:1.18.0:exe:${os.detected.classifier}                     &lt;/pluginArtifact&gt;                 &lt;/configuration&gt;                 &lt;executions&gt;                     &lt;execution&gt;                         &lt;goals&gt;                             &lt;goal&gt;compile&lt;/goal&gt;                             &lt;goal&gt;compile-custom&lt;/goal&gt;                         &lt;/goals&gt;                     &lt;/execution&gt;                 &lt;/executions&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt;   Grpc client   We will add an interceptor to add provide auth token in request:    package in.kuros.blog.grpc.client;  import io.grpc.CallOptions; import io.grpc.Channel; import io.grpc.ClientCall; import io.grpc.ClientInterceptor; import io.grpc.ForwardingClientCall; import io.grpc.Metadata; import io.grpc.Metadata.Key; import io.grpc.MethodDescriptor;  public class AuthTokenProvideInterceptor implements ClientInterceptor {      private final String authToken;      public AuthTokenProvideInterceptor(final String authToken) {         this.authToken = authToken;     }       public &lt;ReqT, RespT&gt; ClientCall&lt;ReqT, RespT&gt; interceptCall(final MethodDescriptor&lt;ReqT, RespT&gt; methodDescriptor, final CallOptions callOptions, final Channel channel) {         return new ForwardingClientCall.SimpleForwardingClientCall&lt;ReqT, RespT&gt;(channel.newCall(methodDescriptor, callOptions)) {             @Override             public void start(final Listener&lt;RespT&gt; responseListener, final Metadata headers) {                  headers.put(Key.of(\"auth_token\", Metadata.ASCII_STRING_MARSHALLER), authToken);                 super.start(responseListener, headers);             }         };     } }          Now we will create two different clients, one with admin role and other with user role.    // Client with admin role &amp; user role  package in.kuros.blog.grpc.client;  import in.kuros.blog.grpc.AddResponse; import in.kuros.blog.grpc.CalculatorGrpc; import in.kuros.blog.grpc.CalculatorGrpc.CalculatorBlockingStub; import in.kuros.blog.grpc.OperandRequest; import io.grpc.ManagedChannel; import io.grpc.ManagedChannelBuilder;  public class GrpcClient {      public static void main(String[] args) {          System.out.println(\"****** Admin Role ******\");         execute(\"admin_token\");          System.out.println(\"****** User Role ******\");         execute(\"user_token\");      }      private static void execute(final String authToken) {          ManagedChannel channel = ManagedChannelBuilder.forAddress(\"localhost\", 8080)                 .usePlaintext()                 .intercept(new AuthTokenProvideInterceptor(authToken))                 .build();          final CalculatorBlockingStub blockingStub = CalculatorGrpc.newBlockingStub(channel);          final AddResponse blockResponse = blockingStub.add(OperandRequest.newBuilder().setX(10).setY(20).build());          System.out.println(\"blocking call result: \" + blockResponse.getResult());          channel.shutdown();     } }    Here we have created two message channels with different authentication roles, one with admin role &amp; other with user, a typical, application requirement.   User Service (Server Side)   Now that we have our client ready, lets focus on creating a server.   We will create a service to validate token and return a UserInfo model will username &amp; roles:   package in.kuros.blog.grpc.server.users;  import in.kuros.blog.grpc.server.users.model.UserInfo;  public interface UserService {      UserInfo validate(String authToken); }   package in.kuros.blog.grpc.server.users;  import in.kuros.blog.grpc.server.users.model.UserInfo; import io.grpc.Status; import io.grpc.StatusRuntimeException;  import java.util.ArrayList; import java.util.List;  public class UserServiceImpl implements UserService {     @Override     public UserInfo validate(final String authToken) {          if (authToken == null) {             throw new StatusRuntimeException(Status.UNAUTHENTICATED);         }          return loadUserByAuthToken(authToken);     }      private UserInfo loadUserByAuthToken(final String authToken) {         // Fetch from DB, here I am validating in line          if (authToken.equals(\"admin_token\")) {             List&lt;String&gt; roles = new ArrayList&lt;&gt;();             roles.add(\"ADMIN\");             roles.add(\"USER\");              return new UserInfo(\"Rohit\", roles);         }          List&lt;String&gt; roles = new ArrayList&lt;&gt;();         roles.add(\"USER\");          return new UserInfo(\"John\", roles);     } }   Here we have two users Rohit with ADMIN access &amp; John with only USER access.   Authentication Interceptor (Server Side)   As explained in my previous article, we will first add interceptor on server side to validate auth token. But in this case once the user is validated we will setup the user info into Context  package in.kuros.blog.grpc.server;  import in.kuros.blog.grpc.server.users.UserService; import in.kuros.blog.grpc.server.users.UserServiceImpl; import in.kuros.blog.grpc.server.users.model.UserInfo; import io.grpc.Context; import io.grpc.Contexts; import io.grpc.Metadata; import io.grpc.Metadata.Key; import io.grpc.ServerCall; import io.grpc.ServerCall.Listener; import io.grpc.ServerCallHandler; import io.grpc.ServerInterceptor;  public class AuthorizationInterceptor implements ServerInterceptor {      public static final Context.Key&lt;Object&gt; USER_DETAILS = Context.key(\"user_details\");      private UserService userService;      public AuthorizationInterceptor() {         this.userService = new UserServiceImpl();     }      public &lt;ReqT, RespT&gt; Listener&lt;ReqT&gt; interceptCall(final ServerCall&lt;ReqT, RespT&gt; serverCall, final Metadata metadata, final ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler) {          final String auth_token = metadata.get(Key.of(\"auth_token\", Metadata.ASCII_STRING_MARSHALLER));          final UserInfo userInfo = userService.validate(auth_token);          Context context = Context.current()                 .withValue(USER_DETAILS, userInfo);          return Contexts.interceptCall(context, serverCall, metadata, serverCallHandler);      } }   At line 17, we created a ContextKey, at line 31, we are getting context, this context is created per request, and we will set our user info within this context.          The Service  Next we have our Calculator service, at line 17 we are getting UserInfo using the key.   Note: The key/value stored in the Context are mapped by reference key, so if you create another key object with same value, it would be treated as two different keys.   package in.kuros.blog.grpc.server;  import in.kuros.blog.grpc.AddResponse; import in.kuros.blog.grpc.CalculatorGrpc.CalculatorImplBase; import in.kuros.blog.grpc.OperandRequest; import in.kuros.blog.grpc.server.users.model.UserInfo; import io.grpc.Status; import io.grpc.StatusRuntimeException; import io.grpc.stub.StreamObserver;  public class CalculatorImpl extends CalculatorImplBase {      @Override     public void add(final OperandRequest request, final StreamObserver&lt;AddResponse&gt; responseObserver) {         final long sum = request.getX() + request.getY();          final UserInfo userInfo = (UserInfo) AuthorizationInterceptor.USER_DETAILS.get();          System.out.println(Thread.currentThread().getName() + \" --- \" + userInfo);          if (userInfo.getRoles().contains(\"ADMIN\")) {             final AddResponse addResponse = AddResponse                     .newBuilder()                     .setResult(sum)                     .build();              responseObserver.onNext(addResponse);             responseObserver.onCompleted();         } else {             responseObserver.onError(new StatusRuntimeException(Status.PERMISSION_DENIED));         }      } }   Here we are saying that add operation will only be authorised to ADMIN users, else a permission denied exception is thrown.   gRPC Server  Finally, you assemple the server:   package in.kuros.blog.grpc.server;  import io.grpc.Server; import io.grpc.ServerBuilder;  public class GrpcServer {      public static void main(String[] args) throws Exception {         final Server server = ServerBuilder.forPort(8080)                 .addService(new CalculatorImpl())                 .intercept(new AuthorizationInterceptor())                 .build();          server.start();         server.awaitTermination();     } }   Now lets run our server/client applications, and see how it works.   # Server logs  grpc-default-executor-0 --- UserInfo{userName='Rohit', roles=[ADMIN, USER]} grpc-default-executor-0 --- UserInfo{userName='John', roles=[USER]}   # Client logs  ****** Admin Role ****** blocking call result: 30 ****** User Role ****** Exception in thread \"main\" io.grpc.StatusRuntimeException: PERMISSION_DENIED \tat io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:233) \tat io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:214) \tat io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:139) \tat in.kuros.blog.grpc.CalculatorGrpc$CalculatorBlockingStub.add(CalculatorGrpc.java:157) \tat in.kuros.blog.grpc.client.GrpcClient.execute(GrpcClient.java:31) \tat in.kuros.blog.grpc.client.GrpcClient.main(GrpcClient.java:18)   As we can see request made my admin channel can successfully access the api but got PERMISSION_DENIED when we tried to access with normal user.   Hurray!!! we have added one more layer to our security. Find the code here.  ","categories": ["gRPC"],
        "tags": [],
        "url": "https://kuros.in/grpc/2019/08/handling-grpc-authorization-using-context/",
        "teaser": null
      },{
        "title": "Making parallel service calls in microservice architecture.",
        "excerpt":"Not so long ago, when I started my development journey, we use to work with single monolith project. The work culture was pretty different compared to current times, we used to get change requests (CR’s) from our client. Then there use to be huge round discussion, finally we use to create delivery schedule, design documents, test schedules and many more even before starting any work. And then we(developers) use to give estimates, which was generally reduced to half(because the client demand the feature early). Our day to day job.      But even for a very small change there used to huge dev, qa, deployment cycle and a simple feature like adding a text box use to take up months. Why!!! because we had go through an end to end validation of complete system, even if the changes were not related to each other distantly.   So what we did, we decided to break up the system into smaller services, each service had clear demarcation and role.   Challenges with microservices  There were numerous things we tried, we failed, we re-designed, and after few failed attempts we could see the silver lining. We had created over 20 deployable against a single monolith. We spend some decent time is creating full test suite ie. unit/integration/acceptance and even diagnostic test. All the product was 100% automated. Finally we moved from releasing 2 builds/month to over 600 builds/month. It was great achievement by our team. Still we are stuck.      There was only one piece of the puzzle which was giving us nightmares - The DATABASE.   We still have all the services connecting to same schema. The reason was simple, its a legacy application broken into multiple services, and each system was having queries which was reading data from tables which it did not own’s. So!!! we tried to split the schema.      Every thing looked nice, it was time to celebrate, we were feeling proud of our achieved, and soon the joy turned into a deep sorrow, we all got a call from one who must not be named …         The performance has dropped, simple request were taking too long, our system has slowed down. So we went back to the design board, again documented the process flow, and as we drilled down we located the monster lurking behind - too many service to service calls.      Assuming each service took only 300ms to complete, but the overall response time was exceeding 1200ms.   Async calls to rescue.  Obviously we wanted to make async calls, collate the data at the end send the response back. We tried implementing different solutions using executor service, it worked but the usage was complicated, we wanted something simpler.      Soon we found out, CompletableFuture was introduced in Java 8. We tried using it.    package in.kuros.blog.code.java.parallel;  import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException;  public class CompletableFutureExample {      public static void main(final String[] args) throws ExecutionException, InterruptedException {                  final CompletableFuture&lt;Integer&gt; service1 = CompletableFuture.supplyAsync(() -&gt; slowService(1));         final CompletableFuture&lt;Integer&gt; service2 = CompletableFuture.supplyAsync(() -&gt; slowService(2));         final CompletableFuture&lt;Integer&gt; service3 = CompletableFuture.supplyAsync(() -&gt; slowService(3));          CompletableFuture.allOf(service1, service2, service3).get();          final int value1 = service1.get();         final int value2 = service1.get();         final int value3 = service1.get();          System.out.println(value1 + value2 + value3);     }      private static Integer slowService(final int i) {         try {             Thread.sleep(1000);         } catch (InterruptedException e) {             e.printStackTrace();         }          return i;     } }   It served the purpose.   Wrapper over CompletableFuture  I still wanted it to be simpler to use. So I created a wrapper over it. Here is my solution, I created a class ParallelExecution.   package in.kuros.blog.code.java.parallel;  import java.util.concurrent.CompletableFuture; import java.util.function.BiFunction; import java.util.function.Supplier; import java.util.stream.Collectors; import java.util.stream.Stream;  public final class ParallelExecution {      private Stream&lt;CompletableFuture&gt; futureStream;      private ParallelExecution(final CompletableFuture&lt;?&gt; completableFuture) {         this(Stream.of(completableFuture));     }      private ParallelExecution(final Stream&lt;CompletableFuture&gt; futureStream) {         this.futureStream = futureStream;     }      public static &lt;V&gt; ParallelExecution of(final Supplier&lt;V&gt; supplier) {         return new ParallelExecution(CompletableFuture.supplyAsync(supplier));     }      public static &lt;V&gt; ParallelExecution of(final Supplier&lt;V&gt; supplier, final BiFunction&lt;V, Throwable, V&gt; errorHandler) {         return new ParallelExecution(CompletableFuture.supplyAsync(supplier).handle(errorHandler));     }      public &lt;T&gt; ParallelExecution and(final Supplier&lt;T&gt; supplier) {         final Stream&lt;CompletableFuture&gt; stream = Stream.of(CompletableFuture.supplyAsync(supplier));         return new ParallelExecution(Stream.concat(futureStream, stream));     }      public &lt;T&gt; ParallelExecution and(final Supplier&lt;T&gt; supplier, final BiFunction&lt;T, Throwable, T&gt; errorHandler) {         final Stream&lt;CompletableFuture&gt; stream = Stream.of(CompletableFuture.supplyAsync(supplier).handle(errorHandler));         return new ParallelExecution(Stream.concat(futureStream, stream));     }      public ExecutionResult close() {         return  new ExecutionResult(futureStream                 .map(CompletableFuture::join)                 .collect(Collectors.toList()));     } }          And collected the results in a new class:  package in.kuros.blog.code.java.parallel;  import java.util.List;  public class ExecutionResult {      private List&lt;?&gt; result;      ExecutionResult(final List&lt;?&gt; result) {         this.result = result;     }      @SuppressWarnings(\"unchecked\")     public &lt;T&gt; T get(final int index) {         return (T) result.get(index);     } }  Finally, we can execute service in parallel.  package in.kuros.blog.code.java.parallel;  public class ParallelExecutionExample {      public static void main(String[] args) {         final ExecutionResult executionResult = ParallelExecution.of(() -&gt; slowService(1))                 .and(() -&gt; slowService(2))                 .and(() -&gt; slowService(3))                 .close();          int val = executionResult.get(0);         int val2 = executionResult.get(1);         int val3 = executionResult.get(2);          System.out.println(val + val2 + val3);     }      private static Integer slowService(final int i) {         try {             Thread.sleep(1000);         } catch (InterruptedException e) {             e.printStackTrace();         }          return i;     } }   The beauty of the solution is that in case of any service failure we get proper exception in the handling class.   package in.kuros.blog.code.java.parallel;  public class ParallelExecutionExceptionExample {      public static void main(String[] args) {         final ExecutionResult executionResult = ParallelExecution.of(() -&gt; slowService(1))                 .and(() -&gt; {                     throw new RuntimeException(\"Bam!!\");                 })                 .and(() -&gt; slowService(3))                 .close();          executionResult.get(0);     }      private static Integer slowService(final int i) {         try {             Thread.sleep(1000);         } catch (InterruptedException e) {             e.printStackTrace();         }          return i;     } }  Exception in thread \"main\" java.util.concurrent.CompletionException: java.lang.RuntimeException: Bam!! \tat java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273) \tat java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280) \tat java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1592) \tat java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1582) \tat java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) \tat java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056) \tat java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692) \tat java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157) Caused by: java.lang.RuntimeException: Bam!! \tat in.kuros.blog.code.java.parallel.ParallelExecutionExceptionExample.lambda$main$1(ParallelExecutionExceptionExample.java:8) \tat java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1590) \t... 5 more  Process finished with exit code 1   Now, we have cleaner way to make service to service calls and then use the results at the end.   Find the code here.   ","categories": ["java","microservices"],
        "tags": [],
        "url": "https://kuros.in/java/microservices/2019/08/parallel-service-execution-in-microservices-architecture-using-completable-future/",
        "teaser": null
      },{
        "title": "jFirebase - Entity Framework for Firebase/Firestore",
        "excerpt":"I decided to tryout firebase for my personal projects &amp; learning, having come from traditional SQL background, I am well versed with JPA/Hibernate when dealing with databases. But when I started firebase, I found it completely different but also having some similarities. After spending some time understanding its feature I started looking a framework similar to JPA for firebase. I found none, so I decided to write one for myself.   Github Source - jFirebase   Initialise   Add Maven dependency:          &lt;dependency&gt;             &lt;groupId&gt;in.kuros&lt;/groupId&gt;             &lt;artifactId&gt;jFirebase&lt;/artifactId&gt;             &lt;version&gt;0.1&lt;/version&gt; &lt;!-- Use the latest version--&gt;         &lt;/dependency&gt;   Use the PersistenceServiceFactory to generate instance of PersistenceService, we need pass firestore instance and provide a list of packages where your entities reside.   // initialise with firestore &amp; base package final PersistenceService persistenceService = PersistenceServiceFactory.create(firestore, \"in.kuros.jfirebase.demo.entity\");   Now that we have initialized our persistence service we will start creating our entities to work with.   Entity  We will use a simple pojo class and convert it into an jFirebase Entity by providing @Entity, you will also need to provide @Id field.   Currently only String &amp; Enum are supported as Id field.    package in.kuros.jfirebase.demo.entity;  import in.kuros.jfirebase.entity.CreateTime; import in.kuros.jfirebase.entity.Entity; import in.kuros.jfirebase.entity.Id; import in.kuros.jfirebase.entity.UpdateTime; import lombok.Data;  import java.util.Date;  @Data @Entity(\"person\") public class Person {      @Id     private String personId;     private String name;      @CreateTime     private Date created;     @UpdateTime     private Date lastModified; }   We can also mark Date field for @CreateTime &amp; @UpdateTime to record creation time &amp; update time implicitly.   Metadata  We will also need to create metadata class to record field description for the corresponding class.   package in.kuros.jfirebase.demo.entity;  import in.kuros.jfirebase.metadata.Attribute; import in.kuros.jfirebase.metadata.Metadata;  import java.util.Date;  @Metadata(Person.class) public class Person_ {      public static volatile Attribute&lt;Person, String&gt; personId;     public static volatile Attribute&lt;Person, String&gt; name;     public static volatile Attribute&lt;Person, Date&gt; created;     public static volatile Attribute&lt;Person, Date&gt; lastModified; }   Annotate the class with @Metadata and create Attribute field for all the corresponding fields on main class.   Our setup is almost done, lets create our first object using persistenceService.   Creating object   To create a new entry in database use create method. It will auto generate Id &amp; createTime will be updated.       public void createPersonExample() {         final Person p = new Person();         p.setName(\"Rohit\");          persistenceService.create(p);          System.out.println(p.getPersonId());     }            Creating object with id   You can create entities with custom ids.       public void createPersonWithCustomIdExample() {         final Person p = new Person();         p.setPersonId(\"1\");         p.setName(\"Rohit\");          persistenceService.create(p);          System.out.println(p.getPersonId());     }      Note: Create method will throw exception if entity with id already exists.   Update/Silent create   Use set method to create/update entity silently, ie. if entity exists, it will be updated else a new entry will be created.       public void updatePersonExample() {         final Person p = new Person();         p.setPersonId(\"1\"); // optional if you want to create a new entry         p.setName(\"Rohit\");          persistenceService.set(p);          System.out.println(p.getPersonId());     }   The set(entity) would update the complete entity.   Updating field   Let’s say I want to update age of person. We need to provide entity with id and age field populated (in this case personId is a requiredField).      public void updateField() {         final Person p = new Person();         p.setPersonId(\"1\"); // optional if you want to create a new entry         p.setAge(20);          persistenceService.set(p, Person_.age);     }   If id field is provided, given field will be updated else a new entry is created.      Updating multiple fields   We can update multiple fields, Use AttributeValue       public void updateMultipleFields() {         persistenceService.set(AttributeValue.with(Person_.personId, \"1\")                 .with(Person_.name, \"I changed my name\")                 .with(Person_.age, 25)                 .build());     }            Working with Sub Collection   Let’s say you want to map sub collection, you need to create a pojo with parent id reference.   package in.kuros.jfirebase.demo.entity;  import in.kuros.jfirebase.entity.Entity; import in.kuros.jfirebase.entity.Id; import in.kuros.jfirebase.entity.IdReference; import in.kuros.jfirebase.entity.Parent; import in.kuros.jfirebase.entity.UpdateTime;  import java.util.Date; import java.util.Map;  @Entity(\"employee\") public class Employee {      @Id     private String employeeId;      @Parent     @IdReference(Person.class)     private String personId;      private Date joiningDate;     private Integer salary;     private Map&lt;String, String&gt; phoneNumbers;      @UpdateTime     private Date modifiedDate; }   Here we are using @Parent with @IdReference to map parent information.   Also note, to save phone numbers we are using a map. Its corresponding Metadata class will be:   package in.kuros.jfirebase.demo.entity;  import in.kuros.jfirebase.entity.Entity; import in.kuros.jfirebase.metadata.Attribute; import in.kuros.jfirebase.metadata.MapAttribute; import in.kuros.jfirebase.metadata.Metadata;  import java.util.Date;  @Metadata(Employee.class) public class Employee_ {      public static volatile Attribute&lt;Employee, String&gt; employeeId;     public static volatile Attribute&lt;Employee, String&gt; personId;     public static volatile Attribute&lt;Employee, Date&gt; joiningDate;     public static volatile Attribute&lt;Employee, Integer&gt; salary;     public static volatile MapAttribute&lt;Employee, String, String&gt; phoneNumbers;     public static volatile Attribute&lt;Employee, Date&gt; modifiedDate;  }   Now to create a Employee entry within Person collection, simply create Employee object with person reference. Note that for phoneNumbers we are using MapAttribute.       public void createSubCollection() {         final Employee employee = new Employee();         employee.setEmployeeId(\"123\"); // Optional if you want custom id         employee.setPersonId(\"1\");         employee.setJoiningDate(new Date());         employee.setSalary(5000);          final Map&lt;String, String&gt; phoneNumbers = new HashMap&lt;&gt;();         phoneNumbers.put(\"office\", \"123-345-567\");         phoneNumbers.put(\"home\", \"456-789-456\");         employee.setPhoneNumbers(phoneNumbers);          persistenceService.create(employee);     }             Update Map values   Let’s say we want to update specific value in a map (home phone number).       public void updateMapUsingKeyValue() {         persistenceService.set(AttributeValue                 .with(Employee_.employeeId, \"123\") // Required field                 .with(Employee_.personId, \"1\") // Required field                 .with(Employee_.phoneNumbers, \"home\", \"111-111-111\")                 .build());     }      or we can completely replace the map - update all the phone numbers       public void updateCompleteMapValues() {         final Map&lt;String, String&gt; phoneNumbers = new HashMap&lt;&gt;();         phoneNumbers.put(\"office\", \"123-345-XXX\");         phoneNumbers.put(\"home\", \"456-789-XXX\");          persistenceService.set(AttributeValue                 .with(Employee_.employeeId, \"123\") // Required field                 .with(Employee_.personId, \"1\") // Required field                 .with(Employee_.phoneNumbers, phoneNumbers)                 .build());     }      Removing Fields  In order to delete just a field from the entry, Use:      public void removeFields() {         persistenceService.remove(RemoveAttribute.withKeys(Employee_.personId, \"1\")                 .withKey(Employee_.employeeId, \"123\")                 .remove(Employee_.salary)                 .removeMapKey(Employee_.phoneNumbers, \"home\"));     }  Here we have deleted salary field and an entry of ‘home’ from phone numbers.      Delete Record   To delete a complete record:       public void deleteCompleteRecord() {         final Employee employee = new Employee();         employee.setEmployeeId(\"123\");         employee.setPersonId(\"1\");         persistenceService.delete(employee);     }  You need to populate required id fields.      Query   To query you need to provide classes in order.   Let’s say you want to find all the employee with salary greater than 1000.      public void query() {         final List&lt;Employee&gt; employees = persistenceService                 .find(QueryBuilder                         .collection(Person.class)                         .withId(\"1\")                         .subCollection(Employee.class)                         .whereGreaterThan(Employee_.salary, 1000));         employees                 .forEach(System.out::println);     }         Employee(employeeId=123, personId=1, joiningDate=Sun Oct 27 02:39:43 IST 2019, salary=5000, phoneNumbers={office=123-345-567, home=456-789-456}, modifiedDate=Sun Oct 27 02:39:43 IST 2019)   Find by Id   To find a record by Id:      public void queryFindById() {         final Employee employee = persistenceService                 .findById(QueryBuilder                         .collection(Person.class)                         .withId(\"1\")                         .subCollection(Employee.class)                         .withId(\"123\"));     }   Provide the full path to fetch item by id.   Select few fields   Let’s say you want to fetch only salaries of all the employees:      public void querySelectedFields() {         final List&lt;Employee&gt; employees = persistenceService                 .find(QueryBuilder                         .collection(Person.class)                         .withId(\"1\")                         .subCollection(Employee.class)                         .select(Employee_.employeeId, Employee_.salary));          employees.forEach(System.out::println);      }   Employee(employeeId=123, personId=null, joiningDate=null, salary=5000, phoneNumbers=null, modifiedDate=null)   Running queries in Transaction   You can run the transaction and execute multiple queries in it.       public void runTransactionExample() {         final List&lt;Employee&gt; updatedEmployees = persistenceService.runTransaction(             transaction -&gt; {                 final List&lt;Employee&gt; employees = transaction.get(QueryBuilder                         .collection(Person.class)                         .withId(\"1\")                         .subCollection(Employee.class));                      employees.stream()                         .peek(emp -&gt; emp.setSalary(6000))                         .forEach(transaction::set);                 return employees;         });          updatedEmployees                 .forEach(System.out::println);     }   Employee(employeeId=123, personId=1, joiningDate=Sun Oct 27 02:44:21 IST 2019, salary=6000, phoneNumbers={office=123-345-567, home=456-789-456}, modifiedDate=Sun Oct 27 02:54:21 IST 2019)   Batching   You can batch multiple statements and commit them at once.       public void runBatchExample() {             persistenceService.writeInBatch(writeBatch -&gt; {                 writeBatch.set(AttributeValue                         .with(Person_.personId, \"2\") // Required field                         .with(Person_.name, \"Jon\") // Required field                         .with(Person_.age, 25)                         .build());                      writeBatch.set(AttributeValue                         .with(Employee_.employeeId, \"123\") // Required field                         .with(Employee_.personId, \"2\") // Required field                         .with(Employee_.phoneNumbers, \"home\", \"222-222-222\")                         .build());             });         }   You can find the code example here   ","categories": ["jFirebase"],
        "tags": [],
        "url": "https://kuros.in/jfirebase/2019/10/jFirebase-a-firebase-wrapper-for-java-developers/",
        "teaser": null
      },{
        "title": "Getting started with kafka messaging",
        "excerpt":"In recent times the Kafka has become a buzzword in the industry, it all started with Linkedin trying to manage the large amount of the data across different applications and data store.   Although earlier systems did provide methods of replication(mostly at database level), high throughput and reliability. One of the major challenge was to connect these technologies into a seamless integration to build an enterprise level application. Also how to handle failures, what if there was a bug in the consumer, you processed the message, now the data is corrupt. Can we correct the data, once you have fixed the consumer.   Kafka has been designed as a high throughput messaging system, with capabilities of high scalability. It is highly reliable and durable. The api’s have been developed keeping loose coupling between the producer and consumer in mind. It provides a flexible semantics to consume and publish messages.   Kafka Architecture   Kafka bases itself on the publisher/subscriber model. In kafka world, publisher is called as Producer and subscriber is referred as Consumer. To simply put producer publishes message to central location called as Topic, the consumer receives the message and process them.      The Broker manages all the topics, and the broker can reside on a single/multiple host. Multiple brokers’ comes together to form a cluster, which is managed by Apache Zookeeper.      There are lots of concepts, but for now let proceed with getting the hands dirty.   Installing Kafka   The first step is to download the Kafka on your machine, I am using a mac(steps will be similar for other OS as well).   Extract the zip to your local machine   $ tar -xvf kafka_2.12-2.5.0.tgz $ cd kafka_2.12-2.5.0   Configure Zookeeper  Before we start, we need to configure the zookeeper. We need to modify zookeeper.properties.   $ vi config/zookeeper.properties  By default, the zookeeper stores the data at /tmp/zookeeper, I will modify it to use a custom directory zookeeper-data. To do that, we need to change the dataDir in the zookeeper.properties file.   $ mkdir zookeeper-data  My modified zookeeper.properties file look like this:   # Licensed to the Apache Software Foundation (ASF) under one or more # contributor license agreements.  See the NOTICE file distributed with # this work for additional information regarding copyright ownership. # The ASF licenses this file to You under the Apache License, Version 2.0 # (the \"License\"); you may not use this file except in compliance with # the License.  You may obtain a copy of the License at # #    http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # the directory where the snapshot is stored. dataDir=/zookeeper-data # the port at which the clients will connect clientPort=2181 # disable the per-ip limit on the number of connections since this is a non-production config maxClientCnxns=0 # Disable the adminserver by default to avoid port conflicts. # Set the port to something non-conflicting if choosing to enable this admin.enableServer=false # admin.serverPort=8080   Starting zookeeper  To run the zookeeper we need to goto bin folder and run the following command.  $ cd bin $ ./zookeeper-server-start.sh ../config/zookeeper.properties    This should start the zookeeper, now let’s move to kafka.   Configure Kafka  Similarly, we are going to modify kafka configuration. To do that we need to modify log.dirs in config/server.properties to point to custom directory. By default, it points to /tmp/kafka-logs.   Now lets start the server:   $ cd bin $ ./kafka-server-start.sh ../config/server.properties   Kafka should be up and running.   Create Kafka Topic   As per the documentation: A topic is a category or feed name to which records are published. Topics in Kafka are always multi-subscriber; that is, a topic can have zero, one, or many consumers that subscribe to the data written to it For now we are using commandline utility provided by kafka to create a topic. We will create a topic with single replication factor since we are running a single broker instance.   $ ./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test Created topic test. $   The above command creates a topic named test. we will use this topic to publish our messages.   Publish Messages  We will again use the commandline utility to publish the message to Kafka topic../   $ ./kafka-console-producer.sh --broker-list localhost:9092 --topic test &gt;message 1  &gt;message 2 &gt;message 3   Receiving Messages  We will use the kafka console consumer to connect to Kafka at port 9092 and receive message from test topic.   $ ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning message 1 message 2 message 3    We have successfully started single broker of Kafka with the zookeeper, published and consumed the messages.   ","categories": ["messaging"],
        "tags": [],
        "url": "https://kuros.in/messaging/2020/05/getting-started-with-kafka-install-and-messaging/",
        "teaser": null
      },{
        "title": "Kafka Messaging with Spring Boot",
        "excerpt":"In my previous article we looked at setting up Kafka on our local machine. Now we will write a spring boot application and integrate Kafka messaging.   Let’s start with a simple spring boot application. Below is the pom file for this application.   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;         &lt;version&gt;2.2.4.RELEASE&lt;/version&gt;         &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;     &lt;/parent&gt;     &lt;groupId&gt;in.kuros.blog-code&lt;/groupId&gt;     &lt;artifactId&gt;messaging-kafka&lt;/artifactId&gt;     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;     &lt;name&gt;messaging-kafka&lt;/name&gt;     &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;      &lt;properties&gt;         &lt;java.version&gt;11&lt;/java.version&gt;     &lt;/properties&gt;      &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;             &lt;scope&gt;test&lt;/scope&gt;             &lt;exclusions&gt;                 &lt;exclusion&gt;                     &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                     &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                 &lt;/exclusion&gt;             &lt;/exclusions&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt;      &lt;build&gt;         &lt;plugins&gt;             &lt;plugin&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;             &lt;/plugin&gt;         &lt;/plugins&gt;     &lt;/build&gt; &lt;/project&gt;   To enable Kafka we will just add dependency for it. It would download the compatible version for kafka, out of the box.           &lt;dependency&gt;             &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;             &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;         &lt;/dependency&gt;   Configuration   We are going to initialize our application with kafka spring configuration for both producer &amp; consumer.   spring:   kafka:     consumer:       bootstrap-servers: localhost:9092       auto-offset-reset: earliest       key-deserializer: org.apache.kafka.common.serialization.StringDeserializer       value-deserializer: org.apache.kafka.common.serialization.StringDeserializer       group-id: myApp     producer:       bootstrap-servers: localhost:9092       key-serializer: org.apache.kafka.common.serialization.StringSerializer       value-serializer: org.apache.kafka.common.serialization.StringSerializer  So we are initializing consumer properties with:     spring.kafka.consumer.bootstrap-servers: To let our application know how to connect to kafka server.   spring.kafka.consumer.auto-offset-reset: This ensures the new consumer group gets the messages we sent, because the container might start after the sends have completed (not applicable explicitly in our case, since both producer and consumer reside in the same application).   spring.kafka.consumer.key-deserializer: Kafka provides a number of ways to deserialize, and we are using the StringDeserializer.   spring.kafka.consumer.value-deserializer: Similarly, for value also we will use StringDeserializer.   In the same way, we have provided bootstrap-servers, key-serializer &amp; value-serializer for producer.   Producer  Spring boot provides a wrapper over KafkaProducer and simplifies the usage. All we need to do is to inject KafkaTemplate and we are ready to publish message. Below is a very simple producer.   package in.kuros.blogcode.messaging.kafka.producer;  import lombok.RequiredArgsConstructor; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.stereotype.Component;  @Component @RequiredArgsConstructor public class MessageProducer {          private final KafkaTemplate&lt;String, String&gt; producer;      public void publishMessage(String message) {         producer.send(\"user-name\", message);     } }    Consumer  We are going to create a consumer which will accept the message and will print it in the console.   package in.kuros.blogcode.messaging.kafka.consumer;  import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Component;  @Component public class MessageConsumer {      @KafkaListener(topics = \"user-name\")     public void consume(final String message) {         System.out.println(\"Received: \" + message);     } }    We have annotated our method with KafkaListener. It does all the heavy lifting of connecting to topic, parsing the message and giving it to you. That’s it.   To test our application, we will create a controller to send the message.   Controller   package in.kuros.blogcode.messaging.kafka.controller;  import in.kuros.blogcode.messaging.kafka.producer.MessageProducer; import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController;  @RestController @RequestMapping(value = \"/kafka\") @RequiredArgsConstructor public class KafkaController {      private final MessageProducer messageProducer;      @PostMapping(value = \"/publish\")     public void sendMessageToKafkaTopic(@RequestParam(\"message\") String message) {         this.messageProducer.publishMessage(message);     } }   We have created a controller which takes in message and publishes it to Kafka topic user-name.   Time to start our application, just execute the below command run spring boot application from the terminal.  $ mvn spring-boot:run   Once the application starts, we will make a curl request to our endpoint to publish the message.   $  curl -X POST -F 'message=test' http://localhost:8080/kafka/publish   We got an error which would be something like this:  Caused by: java.lang.IllegalStateException: Topic(s) [user-name] is/are not present and missingTopicsFatal is true \tat org.springframework.kafka.listener.AbstractMessageListenerContainer.checkTopics(AbstractMessageListenerContainer.java:383) ~[spring-kafka-2.3.5.RELEASE.jar:2.3.5.RELEASE] \tat org.springframework.kafka.listener.ConcurrentMessageListenerContainer.doStart(ConcurrentMessageListenerContainer.java:136) ~[spring-kafka-2.3.5.RELEASE.jar:2.3.5.RELEASE] \tat org.springframework.kafka.listener.AbstractMessageListenerContainer.start(AbstractMessageListenerContainer.java:340) ~[spring-kafka-2.3.5.RELEASE.jar:2.3.5.RELEASE] \tat org.springframework.kafka.config.KafkaListenerEndpointRegistry.startIfNecessary(KafkaListenerEndpointRegistry.java:312) ~[spring-kafka-2.3.5.RELEASE.jar:2.3.5.RELEASE] \tat org.springframework.kafka.config.KafkaListenerEndpointRegistry.start(KafkaListenerEndpointRegistry.java:257) ~[spring-kafka-2.3.5.RELEASE.jar:2.3.5.RELEASE] \tat org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:182) ~[spring-context-5.2.3.RELEASE.jar:5.2.3.RELEASE] \t... 14 common frames omitted   We forgot to create a topic on kafka server. Todo that we will execute below command in kafka’s bin folder.   ./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic user-name   Let’s try again, and now we can successfully receive the message sent via Kafka, it would be something like this:   2020-05-03 02:13:23.524  INFO 5256 --- [nio-8080-exec-1] o.a.kafka.common.utils.AppInfoParser     : Kafka version: 2.3.1 2020-05-03 02:13:23.524  INFO 5256 --- [nio-8080-exec-1] o.a.kafka.common.utils.AppInfoParser     : Kafka commitId: 18a913733fb71c01 2020-05-03 02:13:23.524  INFO 5256 --- [nio-8080-exec-1] o.a.kafka.common.utils.AppInfoParser     : Kafka startTimeMs: 1588452203524 2020-05-03 02:13:23.529  INFO 5256 --- [ad | producer-1] org.apache.kafka.clients.Metadata        : [Producer clientId=producer-1] Cluster ID: y9U_vx0HRk6xe-fcDTKlmg Received: test    You can find the complete code at github.  ","categories": ["messaging"],
        "tags": [],
        "url": "https://kuros.in/messaging/2020/05/publish-and-consume-kafka-message-in-spring-boot-applicaton/",
        "teaser": null
      }]
